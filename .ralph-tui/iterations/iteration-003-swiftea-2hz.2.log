# Iteration 3 Log

## Metadata

- **Task ID**: swiftea-2hz.2
- **Task Title**: US-002: Fix crash on unknown search filter
- **Description**: As a user, I need the mail search command to handle invalid filter names gracefully so that typos don't crash the application.

## Context
Running `swea mail search "badfilter:value"` causes a fatal c...
- **Status**: completed
- **Task Completed**: Yes
- **Promise Detected**: Yes
- **Started At**: 2026-01-16T02:13:58.857Z
- **Ended At**: 2026-01-16T02:29:23.149Z
- **Duration**: 15m 24s
- **Agent**: claude
- **Epic**: swiftea-az6
--- RAW OUTPUT ---
{"type":"system","subtype":"hook_response","session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"ae8394da-7589-4fed-8f8a-0e9241321ba5","hook_name":"SessionStart:startup","hook_event":"SessionStart","stdout":"# Beads Workflow Context\n\n> **Context Recovery**: Run `bd prime` after compaction, clear, or new session\n> Hooks auto-call this in Claude Code when .beads/ detected\n\n# ðŸš¨ SESSION CLOSE PROTOCOL ðŸš¨\n\n**CRITICAL**: Before saying \"done\" or \"complete\", you MUST run this checklist:\n\n```\n[ ] 1. git status              (check what changed)\n[ ] 2. git add <files>         (stage code changes)\n[ ] 3. bd sync --from-main     (pull beads updates from main)\n[ ] 4. git commit -m \"...\"     (commit code changes)\n```\n\n**Note:** This is an ephemeral branch (no upstream). Code is merged to main locally, not pushed.\n\n## Core Rules\n- Track strategic work in beads (multi-session, dependencies, discovered work)\n- Use `bd create` for issues, TodoWrite for simple single-session execution\n- When in doubt, prefer bdâ€”persistence you don't need beats lost context\n- Git workflow: run `bd sync --from-main` at session end\n- Session management: check `bd ready` for available work\n\n## Essential Commands\n\n### Finding Work\n- `bd ready` - Show issues ready to work (no blockers)\n- `bd list --status=open` - All open issues\n- `bd list --status=in_progress` - Your active work\n- `bd show <id>` - Detailed issue view with dependencies\n\n### Creating & Updating\n- `bd create --title=\"...\" --type=task|bug|feature --priority=2` - New issue\n  - Priority: 0-4 or P0-P4 (0=critical, 2=medium, 4=backlog). NOT \"high\"/\"medium\"/\"low\"\n- `bd update <id> --status=in_progress` - Claim work\n- `bd update <id> --assignee=username` - Assign to someone\n- `bd close <id>` - Mark complete\n- `bd close <id1> <id2> ...` - Close multiple issues at once (more efficient)\n- `bd close <id> --reason=\"explanation\"` - Close with reason\n- **Tip**: When creating multiple issues/tasks/epics, use parallel subagents for efficiency\n\n### Dependencies & Blocking\n- `bd dep add <issue> <depends-on>` - Add dependency (issue depends on depends-on)\n- `bd blocked` - Show all blocked issues\n- `bd show <id>` - See what's blocking/blocked by this issue\n\n### Sync & Collaboration\n- `bd sync --from-main` - Pull beads updates from main (for ephemeral branches)\n- `bd sync --status` - Check sync status without syncing\n\n### Project Health\n- `bd stats` - Project statistics (open/closed/blocked counts)\n- `bd doctor` - Check for issues (sync problems, missing hooks)\n\n## Common Workflows\n\n**Starting work:**\n```bash\nbd ready           # Find available work\nbd show <id>       # Review issue details\nbd update <id> --status=in_progress  # Claim it\n```\n\n**Completing work:**\n```bash\nbd close <id1> <id2> ...    # Close all completed issues at once\nbd sync --from-main         # Pull latest beads from main\ngit add . && git commit -m \"...\"  # Commit your changes\n# Merge to main when ready (local merge, not push)\n```\n\n**Creating dependent work:**\n```bash\n# Run bd create commands in parallel (use subagents for many items)\nbd create --title=\"Implement feature X\" --type=feature\nbd create --title=\"Write tests for X\" --type=task\nbd dep add beads-yyy beads-xxx  # Tests depend on Feature (Feature blocks tests)\n```\n","stderr":"","exit_code":0}
{"type":"system","subtype":"init","cwd":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea","session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","tools":["Task","TaskOutput","Bash","Glob","Grep","ExitPlanMode","Read","Edit","Write","NotebookEdit","WebFetch","TodoWrite","WebSearch","KillShell","AskUserQuestion","Skill","EnterPlanMode","MCPSearch"],"mcp_servers":[],"model":"claude-opus-4-5-20251101","permissionMode":"bypassPermissions","slash_commands":["ralph-tui-create-beads","ralph-tui-prd","idea-interrogator","d-spec:d-spec-triage-issue","d-spec:d-spec-proposal","d-spec:d-spec-interview-me","d-spec:d-spec-explore","d-spec:d-spec-archive","d-spec:d-spec-review-pr","d-spec:d-spec-spec-delta-draft","d-spec:d-spec-test-matrix","d-spec:d-spec-summarize-context","d-spec:d-spec-plan-implementation","d-spec:d-spec-cleanup-stale","d-spec:d-spec-draft-release-notes","d-spec:d-spec-create-bd-issues","d-spec:d-spec-validate-specs","d-spec:d-spec-apply","commit-commands:commit-push-pr","commit-commands:clean_gone","commit-commands:commit","beads:stats","beads:label","beads:search","beads:template","beads:ready","beads:rename-prefix","beads:restore","beads:comments","beads:daemon","beads:quickstart","beads:workflow","beads:init","beads:list","beads:close","beads:audit","beads:version","beads:blocked","beads:epic","beads:create","beads:dep","beads:import","beads:delete","beads:sync","beads:update","beads:prime","beads:daemons","beads:show","beads:compact","beads:export","beads:reopen","canvas:canvas","beads:beads","canvas:calendar","canvas:flight","canvas:document","canvas:canvas","compact","context","cost","init","pr-comments","release-notes","review","security-review"],"apiKeySource":"none","claude_code_version":"2.1.7","output_style":"default","agents":["Bash","general-purpose","statusline-setup","Explore","Plan","beads:task-agent"],"skills":["ralph-tui-create-beads","ralph-tui-prd","beads:beads","canvas:calendar","canvas:flight","canvas:document","canvas:canvas"],"plugins":[{"name":"commit-commands","path":"/Users/I852000/.claude/plugins/cache/claude-plugins-official/commit-commands/96276205880a"},{"name":"beads","path":"/Users/I852000/.claude/plugins/cache/beads-marketplace/beads/0.47.2"},{"name":"swift-lsp","path":"/Users/I852000/.claude/plugins/cache/claude-plugins-official/swift-lsp/1.0.0"},{"name":"canvas","path":"/Users/I852000/.claude/plugins/cache/claude-canvas/canvas/0.1.0"}],"uuid":"eebfe517-de9c-492a-9f8e-a5bb9114803e"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_017LPVzkFYznyJGBK8xZJHtG","type":"message","role":"assistant","content":[{"type":"text","text":"I'll start by examining the current state of the mail search code to understand how filters are handled and where the crash occurs."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":7048,"cache_read_input_tokens":16888,"cache_creation":{"ephemeral_5m_input_tokens":7048,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"67a1de24-d2a4-4900-8931-e5c7f30c66a1"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_017LPVzkFYznyJGBK8xZJHtG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YZrY5JzXGbFxsYTLVkUvPN","name":"TodoWrite","input":{"todos":[{"content":"Find and analyze the mail search code","status":"in_progress","activeForm":"Finding and analyzing the mail search code"},{"content":"Implement graceful error handling for unknown filters","status":"pending","activeForm":"Implementing graceful error handling for unknown filters"},{"content":"Add user-friendly error message with valid filter list","status":"pending","activeForm":"Adding user-friendly error message with valid filter list"},{"content":"Run swift build and swift test","status":"pending","activeForm":"Running swift build and swift test"},{"content":"Commit and close the bead","status":"pending","activeForm":"Committing and closing the bead"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":7048,"cache_read_input_tokens":16888,"cache_creation":{"ephemeral_5m_input_tokens":7048,"ephemeral_1h_input_tokens":0},"output_tokens":220,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"d71e9a4a-a74f-49e9-924a-ceb31509ec72"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YZrY5JzXGbFxsYTLVkUvPN","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"e353bc84-b6d5-441c-90ae-8a05df92ae7f","tool_use_result":{"oldTodos":[],"newTodos":[{"content":"Find and analyze the mail search code","status":"in_progress","activeForm":"Finding and analyzing the mail search code"},{"content":"Implement graceful error handling for unknown filters","status":"pending","activeForm":"Implementing graceful error handling for unknown filters"},{"content":"Add user-friendly error message with valid filter list","status":"pending","activeForm":"Adding user-friendly error message with valid filter list"},{"content":"Run swift build and swift test","status":"pending","activeForm":"Running swift build and swift test"},{"content":"Commit and close the bead","status":"pending","activeForm":"Committing and closing the bead"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01RNosLun7wgqRgzsSXxN6ZJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0169wfBunv7ZBMHGvg48es7A","name":"Glob","input":{"pattern":"**/*MailSearch*.swift"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":293,"cache_read_input_tokens":23936,"cache_creation":{"ephemeral_5m_input_tokens":293,"ephemeral_1h_input_tokens":0},"output_tokens":26,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"d749b2bf-7e13-4dba-90ec-c600e737d9de"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01RNosLun7wgqRgzsSXxN6ZJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BVJq1NLyFmkRurHGbUkFVd","name":"Glob","input":{"pattern":"**/*Search*.swift"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":293,"cache_read_input_tokens":23936,"cache_creation":{"ephemeral_5m_input_tokens":293,"ephemeral_1h_input_tokens":0},"output_tokens":26,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"81ceb340-bb15-4a26-ae52-8989b013414f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0169wfBunv7ZBMHGvg48es7A","type":"tool_result","content":"No files found"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"82f7e30a-3c16-4f73-b5c9-4617e1dac251","tool_use_result":{"filenames":[],"durationMs":1098,"numFiles":0,"truncated":false}}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BVJq1NLyFmkRurHGbUkFVd","type":"tool_result","content":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEACLI/Commands/SearchCommand.swift\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/.build/checkouts/GRDB.swift/Tests/GRDBTests/AssociationRowScopeSearchTests.swift\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/.build/index-build/checkouts/GRDB.swift/Tests/GRDBTests/AssociationRowScopeSearchTests.swift"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"2266976d-9da8-44b9-8c28-056946462659","tool_use_result":{"filenames":["/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEACLI/Commands/SearchCommand.swift","/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/.build/checkouts/GRDB.swift/Tests/GRDBTests/AssociationRowScopeSearchTests.swift","/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/.build/index-build/checkouts/GRDB.swift/Tests/GRDBTests/AssociationRowScopeSearchTests.swift"],"durationMs":1101,"numFiles":3,"truncated":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_014TgeMg2mJqgnivGtHQ7FeC","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019itrmDyWyuV34MZDVR9p8B","name":"Read","input":{"file_path":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEACLI/Commands/SearchCommand.swift"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":311,"cache_read_input_tokens":24229,"cache_creation":{"ephemeral_5m_input_tokens":311,"ephemeral_1h_input_tokens":0},"output_tokens":91,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"a33d2a66-2d20-4ccf-885a-f781b2dd54fb"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019itrmDyWyuV34MZDVR9p8B","type":"tool_result","content":"     1â†’import ArgumentParser\n     2â†’import SwiftEAKit\n     3â†’\n     4â†’public struct Search: ParsableCommand {\n     5â†’    public static let configuration = CommandConfiguration(\n     6â†’        commandName: \"search\",\n     7â†’        abstract: \"Search across all modules\"\n     8â†’    )\n     9â†’\n    10â†’    @Argument(help: \"Search query\")\n    11â†’    var query: String\n    12â†’\n    13â†’    @Flag(name: .long, help: \"Search mail only\")\n    14â†’    var mail: Bool = false\n    15â†’\n    16â†’    @Flag(name: .long, help: \"Search calendar only\")\n    17â†’    var calendar: Bool = false\n    18â†’\n    19â†’    @Flag(name: .long, help: \"Output as JSON\")\n    20â†’    var json: Bool = false\n    21â†’\n    22â†’    public init() {}\n    23â†’\n    24â†’    public func run() throws {\n    25â†’        let vault = try VaultContext.require()\n    26â†’        print(\"Searching for: \\(query)\")\n    27â†’        print(\"Using vault: \\(vault.rootPath)\")\n    28â†’        if mail {\n    29â†’            print(\"Scope: mail\")\n    30â†’        }\n    31â†’        if calendar {\n    32â†’            print(\"Scope: calendar\")\n    33â†’        }\n    34â†’        if json {\n    35â†’            print(\"Output format: JSON\")\n    36â†’        }\n    37â†’    }\n    38â†’}\n    39â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"d53d68e7-a0bd-455c-ad04-070d4ade5c5c","tool_use_result":{"type":"text","file":{"filePath":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEACLI/Commands/SearchCommand.swift","content":"import ArgumentParser\nimport SwiftEAKit\n\npublic struct Search: ParsableCommand {\n    public static let configuration = CommandConfiguration(\n        commandName: \"search\",\n        abstract: \"Search across all modules\"\n    )\n\n    @Argument(help: \"Search query\")\n    var query: String\n\n    @Flag(name: .long, help: \"Search mail only\")\n    var mail: Bool = false\n\n    @Flag(name: .long, help: \"Search calendar only\")\n    var calendar: Bool = false\n\n    @Flag(name: .long, help: \"Output as JSON\")\n    var json: Bool = false\n\n    public init() {}\n\n    public func run() throws {\n        let vault = try VaultContext.require()\n        print(\"Searching for: \\(query)\")\n        print(\"Using vault: \\(vault.rootPath)\")\n        if mail {\n            print(\"Scope: mail\")\n        }\n        if calendar {\n            print(\"Scope: calendar\")\n        }\n        if json {\n            print(\"Output format: JSON\")\n        }\n    }\n}\n","numLines":39,"startLine":1,"totalLines":39}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01AreE8u3ZSsJNf63appGMrj","type":"message","role":"assistant","content":[{"type":"text","text":"This is a generic search command. Let me look for the mail-specific search command."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":560,"cache_read_input_tokens":24540,"cache_creation":{"ephemeral_5m_input_tokens":560,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"912222be-4435-4951-8d84-f002d83fadca"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01AreE8u3ZSsJNf63appGMrj","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012S22Wm2jBRsFHk6D5DbZ29","name":"Glob","input":{"pattern":"**/Mail*.swift","path":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":560,"cache_read_input_tokens":24540,"cache_creation":{"ephemeral_5m_input_tokens":560,"ephemeral_1h_input_tokens":0},"output_tokens":116,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"7d77bead-ccbe-48c9-9550-2da9cdad73a6"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012S22Wm2jBRsFHk6D5DbZ29","type":"tool_result","content":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEACLI/Commands/MailCommandUtilities.swift\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/MailModule/MailExporter.swift\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/MailModule/MailSync.swift\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/MailModule/MailSyncParallel.swift\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/MailModule/MailSyncBackward.swift\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEACLI/Commands/MailCommand.swift\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"04a2f0fb-0c30-4b45-b161-bb1535ac2d0c","tool_use_result":{"filenames":["/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEACLI/Commands/MailCommandUtilities.swift","/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/MailModule/MailExporter.swift","/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/MailModule/MailSync.swift","/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/MailModule/MailSyncParallel.swift","/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/MailModule/MailSyncBackward.swift","/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEACLI/Commands/MailCommand.swift","/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift"],"durationMs":448,"numFiles":7,"truncated":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_015eqnQegaXxEVUnNwS8kKeE","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0194CtpRmM1CiPQ51zT6fM2o","name":"Read","input":{"file_path":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEACLI/Commands/MailCommand.swift"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":443,"cache_read_input_tokens":25100,"cache_creation":{"ephemeral_5m_input_tokens":443,"ephemeral_1h_input_tokens":0},"output_tokens":92,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"190871b1-1c66-4b4c-bdf6-93697bc8c748"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"File content (35923 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content.","is_error":true,"tool_use_id":"toolu_0194CtpRmM1CiPQ51zT6fM2o"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"6c8a6590-65f1-4cef-9d5e-ac55ba935f9e","tool_use_result":"Error: File content (35923 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content."}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01PFUJsEiSszgGbPxrEM2G9F","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KzmPybFVgnX5nKFrHuYRp3","name":"Grep","input":{"pattern":"search|Search|filter|Filter","path":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEACLI/Commands/MailCommand.swift","output_mode":"content","-n":true}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":155,"cache_read_input_tokens":25543,"cache_creation":{"ephemeral_5m_input_tokens":155,"ephemeral_1h_input_tokens":0},"output_tokens":26,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"4da4b40b-5e5a-4a2f-9455-5877f9db17b2"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KzmPybFVgnX5nKFrHuYRp3","type":"tool_result","content":"28:        abstract: \"Mail operations (sync, search, show, export, actions)\",\n30:            swea mail commands interact with Apple Mail.app to sync, search,\n34:            The typical workflow is: sync -> search/show -> export\n38:              swea mail search \"query\"    # Search synced messages\n48:              # Search and export as needed\n49:              swea mail search \"from:alice@example.com\"\n83:              # Search for emails from a specific sender\n84:              swea mail search \"from:alice@example.com\"\n89:              # Export filtered mail to custom location\n106:            MailSearchCommand.self,\n134:            searching. By default, performs an incremental sync (only new/changed\n1203:struct MailSearchCommand: ParsableCommand {\n1205:        commandName: \"search\",\n1206:        abstract: \"Search mail using full-text search with structured filters\",\n1208:            Search for mail messages using full-text search and/or structured filters.\n1211:              from:email       - Filter by sender email or name\n1212:              to:email         - Filter by recipient email or name\n1213:              subject:text     - Filter by subject containing text\n1214:              mailbox:name     - Filter by mailbox name\n1230:              swea mail search \"from:alice@example.com project\"\n1231:              swea mail search \"is:unread is:flagged\"\n1232:              swea mail search \"after:2024-01-01 before:2024-02-01\"\n1233:              swea mail search \"mailbox:INBOX from:support\"\n1234:              swea mail search --status inbox \"from:support\"\n1235:              swea mail search --status archived \"\"\n1241:    @Argument(help: \"Search query with optional structured filters\")\n1244:    @Option(name: .long, help: \"Filter by mailbox status: inbox, archived, deleted\")\n1277:        // Parse the query for structured filters\n1278:        var filter = mailDatabase.parseQuery(query)\n1282:            filter.mailboxStatus = MailboxStatus(rawValue: statusValue.lowercased())\n1285:        // Use structured search if we have filters, otherwise fall back to basic FTS\n1287:        if filter.hasFilters || filter.hasFreeText {\n1288:            results = try mailDatabase.searchMessagesWithFilters(filter, limit: limit)\n1300:            // Output as JSON with filter info\n1321:            // Show filter summary if structured filters were used\n1322:            if filter.hasFilters {\n1323:                var filterDesc: [String] = []\n1324:                if let from = filter.from { filterDesc.append(\"from:\\(from)\") }\n1325:                if let to = filter.to { filterDesc.append(\"to:\\(to)\") }\n1326:                if let subject = filter.subject { filterDesc.append(\"subject:\\(subject)\") }\n1327:                if let mailbox = filter.mailbox { filterDesc.append(\"mailbox:\\(mailbox)\") }\n1328:                if let mailboxStatus = filter.mailboxStatus { filterDesc.append(\"status:\\(mailboxStatus.rawValue)\") }\n1329:                if let isRead = filter.isRead { filterDesc.append(isRead ? \"is:read\" : \"is:unread\") }\n1330:                if let isFlagged = filter.isFlagged { filterDesc.append(isFlagged ? \"is:flagged\" : \"is:unflagged\") }\n1331:                if filter.hasAttachments == true { filterDesc.append(\"has:attachments\") }\n1332:                if filter.dateAfter != nil || filter.dateBefore != nil {\n1335:                    if let after = filter.dateAfter { filterDesc.append(\"after:\\(df.string(from: after))\") }\n1336:                    if let before = filter.dateBefore { filterDesc.append(\"before:\\(df.string(from: before))\") }\n1338:                print(\"Filters: \\(filterDesc.joined(separator: \" \"))\")\n1339:                if let freeText = filter.freeText {\n1340:                    print(\"Search: \\(freeText)\")\n1553:            printError(\"  swea mail search <query>              # Search for messages\")\n1865:              swea mail threads --participant john@     # Filter by participant email\n1880:    @Option(name: .shortAndLong, help: \"Filter threads by participant email (partial match)\")\n1895:        // Get threads with filtering and sorting options\n1964:            output[\"participant_filter\"] = participant\n1986:            print(\"participant_filter: \\(participant)\")\n1996:            summaryLine += \" (filtered by: \\(participant))\"\n2046:            headerLine += \" (filtered by: \\(participant))\"\n2223:    @Option(name: .long, help: \"Search query to filter messages for export\")\n2287:        } else if let searchQuery = query {\n2289:            messages = try mailDatabase.searchMessages(query: searchQuery, limit: limit)"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"6939135b-8399-4c93-bada-1ced5f02ce5c","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"28:        abstract: \"Mail operations (sync, search, show, export, actions)\",\n30:            swea mail commands interact with Apple Mail.app to sync, search,\n34:            The typical workflow is: sync -> search/show -> export\n38:              swea mail search \"query\"    # Search synced messages\n48:              # Search and export as needed\n49:              swea mail search \"from:alice@example.com\"\n83:              # Search for emails from a specific sender\n84:              swea mail search \"from:alice@example.com\"\n89:              # Export filtered mail to custom location\n106:            MailSearchCommand.self,\n134:            searching. By default, performs an incremental sync (only new/changed\n1203:struct MailSearchCommand: ParsableCommand {\n1205:        commandName: \"search\",\n1206:        abstract: \"Search mail using full-text search with structured filters\",\n1208:            Search for mail messages using full-text search and/or structured filters.\n1211:              from:email       - Filter by sender email or name\n1212:              to:email         - Filter by recipient email or name\n1213:              subject:text     - Filter by subject containing text\n1214:              mailbox:name     - Filter by mailbox name\n1230:              swea mail search \"from:alice@example.com project\"\n1231:              swea mail search \"is:unread is:flagged\"\n1232:              swea mail search \"after:2024-01-01 before:2024-02-01\"\n1233:              swea mail search \"mailbox:INBOX from:support\"\n1234:              swea mail search --status inbox \"from:support\"\n1235:              swea mail search --status archived \"\"\n1241:    @Argument(help: \"Search query with optional structured filters\")\n1244:    @Option(name: .long, help: \"Filter by mailbox status: inbox, archived, deleted\")\n1277:        // Parse the query for structured filters\n1278:        var filter = mailDatabase.parseQuery(query)\n1282:            filter.mailboxStatus = MailboxStatus(rawValue: statusValue.lowercased())\n1285:        // Use structured search if we have filters, otherwise fall back to basic FTS\n1287:        if filter.hasFilters || filter.hasFreeText {\n1288:            results = try mailDatabase.searchMessagesWithFilters(filter, limit: limit)\n1300:            // Output as JSON with filter info\n1321:            // Show filter summary if structured filters were used\n1322:            if filter.hasFilters {\n1323:                var filterDesc: [String] = []\n1324:                if let from = filter.from { filterDesc.append(\"from:\\(from)\") }\n1325:                if let to = filter.to { filterDesc.append(\"to:\\(to)\") }\n1326:                if let subject = filter.subject { filterDesc.append(\"subject:\\(subject)\") }\n1327:                if let mailbox = filter.mailbox { filterDesc.append(\"mailbox:\\(mailbox)\") }\n1328:                if let mailboxStatus = filter.mailboxStatus { filterDesc.append(\"status:\\(mailboxStatus.rawValue)\") }\n1329:                if let isRead = filter.isRead { filterDesc.append(isRead ? \"is:read\" : \"is:unread\") }\n1330:                if let isFlagged = filter.isFlagged { filterDesc.append(isFlagged ? \"is:flagged\" : \"is:unflagged\") }\n1331:                if filter.hasAttachments == true { filterDesc.append(\"has:attachments\") }\n1332:                if filter.dateAfter != nil || filter.dateBefore != nil {\n1335:                    if let after = filter.dateAfter { filterDesc.append(\"after:\\(df.string(from: after))\") }\n1336:                    if let before = filter.dateBefore { filterDesc.append(\"before:\\(df.string(from: before))\") }\n1338:                print(\"Filters: \\(filterDesc.joined(separator: \" \"))\")\n1339:                if let freeText = filter.freeText {\n1340:                    print(\"Search: \\(freeText)\")\n1553:            printError(\"  swea mail search <query>              # Search for messages\")\n1865:              swea mail threads --participant john@     # Filter by participant email\n1880:    @Option(name: .shortAndLong, help: \"Filter threads by participant email (partial match)\")\n1895:        // Get threads with filtering and sorting options\n1964:            output[\"participant_filter\"] = participant\n1986:            print(\"participant_filter: \\(participant)\")\n1996:            summaryLine += \" (filtered by: \\(participant))\"\n2046:            headerLine += \" (filtered by: \\(participant))\"\n2223:    @Option(name: .long, help: \"Search query to filter messages for export\")\n2287:        } else if let searchQuery = query {\n2289:            messages = try mailDatabase.searchMessages(query: searchQuery, limit: limit)","numLines":62}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01QVJ2mUDomujfngfezSD7xb","type":"message","role":"assistant","content":[{"type":"text","text":"Let me look at the `parseQuery` function in the MailDatabase.swift file."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1387,"cache_read_input_tokens":25698,"cache_creation":{"ephemeral_5m_input_tokens":1387,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"b87e003b-1989-4010-823f-6868ea08d588"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01QVJ2mUDomujfngfezSD7xb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RQA2Q4FGsD86t2JGkX35t3","name":"Read","input":{"file_path":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1387,"cache_read_input_tokens":25698,"cache_creation":{"ephemeral_5m_input_tokens":1387,"ephemeral_1h_input_tokens":0},"output_tokens":116,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"053c1b3c-a5a6-4ea7-8c70-2c9346c97ade"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"File content (27385 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content.","is_error":true,"tool_use_id":"toolu_01RQA2Q4FGsD86t2JGkX35t3"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"7c5fdc2a-26c2-40db-a3c7-c97a3dab29d9","tool_use_result":"Error: File content (27385 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content."}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01CaFhkcujFR4Zg9p1XtPjJ3","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HzjoHgFbLG4EvETxcAjswQ","name":"Grep","input":{"pattern":"parseQuery|struct MailFilter|searchMessagesWithFilters","path":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift","output_mode":"content","-n":true}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":179,"cache_read_input_tokens":27085,"cache_creation":{"ephemeral_5m_input_tokens":179,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"2f820609-9267-4585-9a9d-f6bdc1170f89"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HzjoHgFbLG4EvETxcAjswQ","type":"tool_result","content":"700:    public func parseQuery(_ query: String) -> SearchFilter {\n787:    public func searchMessagesWithFilters(_ filter: SearchFilter, limit: Int = 50, offset: Int = 0) throws -> [MailMessage] {"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"2b9335f7-adce-4771-bc29-f100cfca718e","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"700:    public func parseQuery(_ query: String) -> SearchFilter {\n787:    public func searchMessagesWithFilters(_ filter: SearchFilter, limit: Int = 50, offset: Int = 0) throws -> [MailMessage] {","numLines":2}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_017U67j4RLEG2NyjhEL1G7hA","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01C49g99UoEESjijVNeZgEnY","name":"Read","input":{"file_path":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift","offset":700,"limit":150}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":417,"cache_read_input_tokens":27264,"cache_creation":{"ephemeral_5m_input_tokens":417,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"05af692c-3d00-4002-8f6c-aadec5b3e678"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01C49g99UoEESjijVNeZgEnY","type":"tool_result","content":"   700â†’    public func parseQuery(_ query: String) -> SearchFilter {\n   701â†’        var filter = SearchFilter()\n   702â†’\n   703â†’        // Regex patterns for structured filters\n   704â†’        let filterPatterns: [(pattern: String, handler: (String, inout SearchFilter) -> Void)] = [\n   705â†’            // from: filter (email or name)\n   706â†’            (\"from:\\\"([^\\\"]+)\\\"\", { value, f in f.from = value }),\n   707â†’            (\"from:(\\\\S+)\", { value, f in f.from = value }),\n   708â†’\n   709â†’            // to: filter\n   710â†’            (\"to:\\\"([^\\\"]+)\\\"\", { value, f in f.to = value }),\n   711â†’            (\"to:(\\\\S+)\", { value, f in f.to = value }),\n   712â†’\n   713â†’            // subject: filter\n   714â†’            (\"subject:\\\"([^\\\"]+)\\\"\", { value, f in f.subject = value }),\n   715â†’            (\"subject:(\\\\S+)\", { value, f in f.subject = value }),\n   716â†’\n   717â†’            // mailbox: filter\n   718â†’            (\"mailbox:\\\"([^\\\"]+)\\\"\", { value, f in f.mailbox = value }),\n   719â†’            (\"mailbox:(\\\\S+)\", { value, f in f.mailbox = value }),\n   720â†’\n   721â†’            // is: status filters\n   722â†’            (\"is:read\", { _, f in f.isRead = true }),\n   723â†’            (\"is:unread\", { _, f in f.isRead = false }),\n   724â†’            (\"is:flagged\", { _, f in f.isFlagged = true }),\n   725â†’            (\"is:unflagged\", { _, f in f.isFlagged = false }),\n   726â†’\n   727â†’            // has: filters\n   728â†’            (\"has:attachments?\", { _, f in f.hasAttachments = true }),\n   729â†’\n   730â†’            // Date filters (YYYY-MM-DD format)\n   731â†’            (\"after:(\\\\d{4}-\\\\d{2}-\\\\d{2})\", { value, f in f.dateAfter = parseDate(value) }),\n   732â†’            (\"before:(\\\\d{4}-\\\\d{2}-\\\\d{2})\", { value, f in f.dateBefore = parseDate(value) }),\n   733â†’            (\"date:(\\\\d{4}-\\\\d{2}-\\\\d{2})\", { value, f in\n   734â†’                // date: sets both after and before to cover the whole day\n   735â†’                if let date = parseDate(value) {\n   736â†’                    f.dateAfter = date\n   737â†’                    // Set before to end of day\n   738â†’                    if let endOfDay = Calendar.current.date(byAdding: .day, value: 1, to: date) {\n   739â†’                        f.dateBefore = endOfDay\n   740â†’                    }\n   741â†’                }\n   742â†’            })\n   743â†’        ]\n   744â†’\n   745â†’        var remainingQuery = query\n   746â†’\n   747â†’        // Process each filter pattern\n   748â†’        for (pattern, handler) in filterPatterns {\n   749â†’            if let regex = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive) {\n   750â†’                let range = NSRange(remainingQuery.startIndex..., in: remainingQuery)\n   751â†’                let matches = regex.matches(in: remainingQuery, options: [], range: range)\n   752â†’\n   753â†’                // Process matches in reverse to preserve indices\n   754â†’                for match in matches.reversed() {\n   755â†’                    // Extract captured group if present, otherwise use the whole match\n   756â†’                    let valueRange = match.numberOfRanges > 1 ? match.range(at: 1) : match.range\n   757â†’                    if let swiftRange = Range(valueRange, in: remainingQuery) {\n   758â†’                        let value = String(remainingQuery[swiftRange])\n   759â†’                        handler(value, &filter)\n   760â†’                    } else {\n   761â†’                        handler(\"\", &filter)\n   762â†’                    }\n   763â†’\n   764â†’                    // Remove matched text from query\n   765â†’                    if let swiftRange = Range(match.range, in: remainingQuery) {\n   766â†’                        remainingQuery.removeSubrange(swiftRange)\n   767â†’                    }\n   768â†’                }\n   769â†’            }\n   770â†’        }\n   771â†’\n   772â†’        // Clean up remaining query (free text for FTS)\n   773â†’        let cleanedFreeText = remainingQuery\n   774â†’            .trimmingCharacters(in: .whitespaces)\n   775â†’            .components(separatedBy: .whitespaces)\n   776â†’            .filter { !$0.isEmpty }\n   777â†’            .joined(separator: \" \")\n   778â†’\n   779â†’        if !cleanedFreeText.isEmpty {\n   780â†’            filter.freeText = cleanedFreeText\n   781â†’        }\n   782â†’\n   783â†’        return filter\n   784â†’    }\n   785â†’\n   786â†’    /// Search messages using structured filters and optional FTS\n   787â†’    public func searchMessagesWithFilters(_ filter: SearchFilter, limit: Int = 50, offset: Int = 0) throws -> [MailMessage] {\n   788â†’        guard let conn = connection else {\n   789â†’            throw MailDatabaseError.notInitialized\n   790â†’        }\n   791â†’\n   792â†’        var whereClauses: [String] = []\n   793â†’\n   794â†’        // Build WHERE clauses from filters\n   795â†’\n   796â†’        // from: filter (matches sender_name or sender_email)\n   797â†’        if let from = filter.from {\n   798â†’            let escaped = escapeSql(from)\n   799â†’            whereClauses.append(\"(m.sender_email LIKE '%\\(escaped)%' OR m.sender_name LIKE '%\\(escaped)%')\")\n   800â†’        }\n   801â†’\n   802â†’        // to: filter (requires join with recipients table)\n   803â†’        // For simplicity, we'll use a subquery\n   804â†’        if let to = filter.to {\n   805â†’            let escaped = escapeSql(to)\n   806â†’            whereClauses.append(\"\"\"\n   807â†’                EXISTS (SELECT 1 FROM recipients r WHERE r.message_id = m.id\n   808â†’                        AND (r.email LIKE '%\\(escaped)%' OR r.name LIKE '%\\(escaped)%'))\n   809â†’                \"\"\")\n   810â†’        }\n   811â†’\n   812â†’        // subject: filter\n   813â†’        if let subject = filter.subject {\n   814â†’            let escaped = escapeSql(subject)\n   815â†’            whereClauses.append(\"m.subject LIKE '%\\(escaped)%'\")\n   816â†’        }\n   817â†’\n   818â†’        // mailbox: filter\n   819â†’        if let mailbox = filter.mailbox {\n   820â†’            let escaped = escapeSql(mailbox)\n   821â†’            whereClauses.append(\"m.mailbox_name LIKE '%\\(escaped)%'\")\n   822â†’        }\n   823â†’\n   824â†’        // is:read / is:unread filter\n   825â†’        if let isRead = filter.isRead {\n   826â†’            whereClauses.append(\"m.is_read = \\(isRead ? 1 : 0)\")\n   827â†’        }\n   828â†’\n   829â†’        // is:flagged / is:unflagged filter\n   830â†’        if let isFlagged = filter.isFlagged {\n   831â†’            whereClauses.append(\"m.is_flagged = \\(isFlagged ? 1 : 0)\")\n   832â†’        }\n   833â†’\n   834â†’        // has:attachments filter\n   835â†’        if let hasAttachments = filter.hasAttachments, hasAttachments {\n   836â†’            whereClauses.append(\"m.has_attachments = 1\")\n   837â†’        }\n   838â†’\n   839â†’        // Date filters\n   840â†’        if let dateAfter = filter.dateAfter {\n   841â†’            let timestamp = Int(dateAfter.timeIntervalSince1970)\n   842â†’            whereClauses.append(\"m.date_received >= \\(timestamp)\")\n   843â†’        }\n   844â†’\n   845â†’        if let dateBefore = filter.dateBefore {\n   846â†’            let timestamp = Int(dateBefore.timeIntervalSince1970)\n   847â†’            whereClauses.append(\"m.date_received < \\(timestamp)\")\n   848â†’        }\n   849â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"9d1510c7-de1b-4c05-972b-7a94dd4ee89f","tool_use_result":{"type":"text","file":{"filePath":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift","content":"    public func parseQuery(_ query: String) -> SearchFilter {\n        var filter = SearchFilter()\n\n        // Regex patterns for structured filters\n        let filterPatterns: [(pattern: String, handler: (String, inout SearchFilter) -> Void)] = [\n            // from: filter (email or name)\n            (\"from:\\\"([^\\\"]+)\\\"\", { value, f in f.from = value }),\n            (\"from:(\\\\S+)\", { value, f in f.from = value }),\n\n            // to: filter\n            (\"to:\\\"([^\\\"]+)\\\"\", { value, f in f.to = value }),\n            (\"to:(\\\\S+)\", { value, f in f.to = value }),\n\n            // subject: filter\n            (\"subject:\\\"([^\\\"]+)\\\"\", { value, f in f.subject = value }),\n            (\"subject:(\\\\S+)\", { value, f in f.subject = value }),\n\n            // mailbox: filter\n            (\"mailbox:\\\"([^\\\"]+)\\\"\", { value, f in f.mailbox = value }),\n            (\"mailbox:(\\\\S+)\", { value, f in f.mailbox = value }),\n\n            // is: status filters\n            (\"is:read\", { _, f in f.isRead = true }),\n            (\"is:unread\", { _, f in f.isRead = false }),\n            (\"is:flagged\", { _, f in f.isFlagged = true }),\n            (\"is:unflagged\", { _, f in f.isFlagged = false }),\n\n            // has: filters\n            (\"has:attachments?\", { _, f in f.hasAttachments = true }),\n\n            // Date filters (YYYY-MM-DD format)\n            (\"after:(\\\\d{4}-\\\\d{2}-\\\\d{2})\", { value, f in f.dateAfter = parseDate(value) }),\n            (\"before:(\\\\d{4}-\\\\d{2}-\\\\d{2})\", { value, f in f.dateBefore = parseDate(value) }),\n            (\"date:(\\\\d{4}-\\\\d{2}-\\\\d{2})\", { value, f in\n                // date: sets both after and before to cover the whole day\n                if let date = parseDate(value) {\n                    f.dateAfter = date\n                    // Set before to end of day\n                    if let endOfDay = Calendar.current.date(byAdding: .day, value: 1, to: date) {\n                        f.dateBefore = endOfDay\n                    }\n                }\n            })\n        ]\n\n        var remainingQuery = query\n\n        // Process each filter pattern\n        for (pattern, handler) in filterPatterns {\n            if let regex = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive) {\n                let range = NSRange(remainingQuery.startIndex..., in: remainingQuery)\n                let matches = regex.matches(in: remainingQuery, options: [], range: range)\n\n                // Process matches in reverse to preserve indices\n                for match in matches.reversed() {\n                    // Extract captured group if present, otherwise use the whole match\n                    let valueRange = match.numberOfRanges > 1 ? match.range(at: 1) : match.range\n                    if let swiftRange = Range(valueRange, in: remainingQuery) {\n                        let value = String(remainingQuery[swiftRange])\n                        handler(value, &filter)\n                    } else {\n                        handler(\"\", &filter)\n                    }\n\n                    // Remove matched text from query\n                    if let swiftRange = Range(match.range, in: remainingQuery) {\n                        remainingQuery.removeSubrange(swiftRange)\n                    }\n                }\n            }\n        }\n\n        // Clean up remaining query (free text for FTS)\n        let cleanedFreeText = remainingQuery\n            .trimmingCharacters(in: .whitespaces)\n            .components(separatedBy: .whitespaces)\n            .filter { !$0.isEmpty }\n            .joined(separator: \" \")\n\n        if !cleanedFreeText.isEmpty {\n            filter.freeText = cleanedFreeText\n        }\n\n        return filter\n    }\n\n    /// Search messages using structured filters and optional FTS\n    public func searchMessagesWithFilters(_ filter: SearchFilter, limit: Int = 50, offset: Int = 0) throws -> [MailMessage] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        var whereClauses: [String] = []\n\n        // Build WHERE clauses from filters\n\n        // from: filter (matches sender_name or sender_email)\n        if let from = filter.from {\n            let escaped = escapeSql(from)\n            whereClauses.append(\"(m.sender_email LIKE '%\\(escaped)%' OR m.sender_name LIKE '%\\(escaped)%')\")\n        }\n\n        // to: filter (requires join with recipients table)\n        // For simplicity, we'll use a subquery\n        if let to = filter.to {\n            let escaped = escapeSql(to)\n            whereClauses.append(\"\"\"\n                EXISTS (SELECT 1 FROM recipients r WHERE r.message_id = m.id\n                        AND (r.email LIKE '%\\(escaped)%' OR r.name LIKE '%\\(escaped)%'))\n                \"\"\")\n        }\n\n        // subject: filter\n        if let subject = filter.subject {\n            let escaped = escapeSql(subject)\n            whereClauses.append(\"m.subject LIKE '%\\(escaped)%'\")\n        }\n\n        // mailbox: filter\n        if let mailbox = filter.mailbox {\n            let escaped = escapeSql(mailbox)\n            whereClauses.append(\"m.mailbox_name LIKE '%\\(escaped)%'\")\n        }\n\n        // is:read / is:unread filter\n        if let isRead = filter.isRead {\n            whereClauses.append(\"m.is_read = \\(isRead ? 1 : 0)\")\n        }\n\n        // is:flagged / is:unflagged filter\n        if let isFlagged = filter.isFlagged {\n            whereClauses.append(\"m.is_flagged = \\(isFlagged ? 1 : 0)\")\n        }\n\n        // has:attachments filter\n        if let hasAttachments = filter.hasAttachments, hasAttachments {\n            whereClauses.append(\"m.has_attachments = 1\")\n        }\n\n        // Date filters\n        if let dateAfter = filter.dateAfter {\n            let timestamp = Int(dateAfter.timeIntervalSince1970)\n            whereClauses.append(\"m.date_received >= \\(timestamp)\")\n        }\n\n        if let dateBefore = filter.dateBefore {\n            let timestamp = Int(dateBefore.timeIntervalSince1970)\n            whereClauses.append(\"m.date_received < \\(timestamp)\")\n        }\n","numLines":150,"startLine":700,"totalLines":2634}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Wk24ErvUGaRgJxXjjzVxyf","type":"message","role":"assistant","content":[{"type":"text","text":"Now I understand the issue. The `parseQuery` function processes known filters (from, to, subject, mailbox, is, has, after, before, date) and puts any unrecognized text (including unknown filters like \"badfilter:value\") into the `freeText` field. This `freeText` is then used in FTS search, but if it contains \"badfilter:value\", the search likely fails.\n\nLet me see the `searchMessagesWithFilters` continuation and understand where the error occurs."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2391,"cache_read_input_tokens":27681,"cache_creation":{"ephemeral_5m_input_tokens":2391,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"0714d6d8-8f5a-4d1c-9a9f-9108df496b39"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Wk24ErvUGaRgJxXjjzVxyf","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VxuezDntffdRq3MxCMqsej","name":"Read","input":{"file_path":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift","offset":849,"limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2391,"cache_read_input_tokens":27681,"cache_creation":{"ephemeral_5m_input_tokens":2391,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"101ec8cb-abdd-440a-96b4-ee2c3d333c78"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VxuezDntffdRq3MxCMqsej","type":"tool_result","content":"   849â†’\n   850â†’        // Mailbox status filter (inbox, archived, deleted)\n   851â†’        if let mailboxStatus = filter.mailboxStatus {\n   852â†’            whereClauses.append(\"m.mailbox_status = '\\(mailboxStatus.rawValue)'\")\n   853â†’        }\n   854â†’\n   855â†’        // Always exclude deleted messages\n   856â†’        whereClauses.append(\"m.is_deleted = 0\")\n   857â†’\n   858â†’        // Build the query\n   859â†’        var sql: String\n   860â†’\n   861â†’        if filter.hasFreeText, let freeText = filter.freeText {\n   862â†’            // Use FTS with additional filters\n   863â†’            let whereClause = whereClauses.isEmpty ? \"\" : \"AND \" + whereClauses.joined(separator: \" AND \")\n   864â†’            sql = \"\"\"\n   865â†’                SELECT m.* FROM messages m\n   866â†’                JOIN messages_fts fts ON m.rowid = fts.rowid\n   867â†’                WHERE messages_fts MATCH '\\(escapeSql(escapeFts5Query(freeText)))'\n   868â†’                \\(whereClause)\n   869â†’                ORDER BY bm25(messages_fts)\n   870â†’                LIMIT \\(limit) OFFSET \\(offset)\n   871â†’                \"\"\"\n   872â†’        } else if !whereClauses.isEmpty {\n   873â†’            // Filters only, no FTS\n   874â†’            let whereClause = whereClauses.joined(separator: \" AND \")\n   875â†’            sql = \"\"\"\n   876â†’                SELECT m.* FROM messages m\n   877â†’                WHERE \\(whereClause)\n   878â†’                ORDER BY m.date_received DESC\n   879â†’                LIMIT \\(limit) OFFSET \\(offset)\n   880â†’                \"\"\"\n   881â†’        } else {\n   882â†’            // No filters, return recent messages\n   883â†’            sql = \"\"\"\n   884â†’                SELECT * FROM messages m\n   885â†’                WHERE m.is_deleted = 0\n   886â†’                ORDER BY m.date_received DESC\n   887â†’                LIMIT \\(limit) OFFSET \\(offset)\n   888â†’                \"\"\"\n   889â†’        }\n   890â†’\n   891â†’        let result = try conn.query(sql)\n   892â†’\n   893â†’        var messages: [MailMessage] = []\n   894â†’        for row in result {\n   895â†’            if let message = try? rowToMessage(row) {\n   896â†’                messages.append(message)\n   897â†’            }\n   898â†’        }\n   899â†’        return messages\n   900â†’    }\n   901â†’\n   902â†’    /// Get all non-deleted messages (for export without search query)\n   903â†’    /// - Parameters:\n   904â†’    ///   - limit: Maximum number of messages to return\n   905â†’    ///   - offset: Number of messages to skip for pagination\n   906â†’    /// - Returns: Array of messages ordered by date received (newest first)\n   907â†’    public func getAllMessages(limit: Int = 100, offset: Int = 0) throws -> [MailMessage] {\n   908â†’        guard let conn = connection else {\n   909â†’            throw MailDatabaseError.notInitialized\n   910â†’        }\n   911â†’\n   912â†’        let query = \"\"\"\n   913â†’            SELECT * FROM messages\n   914â†’            WHERE is_deleted = 0\n   915â†’            ORDER BY date_received DESC\n   916â†’            LIMIT \\(limit) OFFSET \\(offset)\n   917â†’            \"\"\"\n   918â†’\n   919â†’        let result = try conn.query(query)\n   920â†’        var messages: [MailMessage] = []\n   921â†’        for row in result {\n   922â†’            if let message = try? rowToMessage(row) {\n   923â†’                messages.append(message)\n   924â†’            }\n   925â†’        }\n   926â†’        return messages\n   927â†’    }\n   928â†’\n   929â†’    /// Get messages that haven't been exported yet (export_path IS NULL)\n   930â†’    /// Used for incremental auto-export after sync\n   931â†’    /// - Parameter limit: Maximum number of messages to return (default: unlimited via 0)\n   932â†’    /// - Returns: Array of messages that need to be exported\n   933â†’    public func getMessagesNeedingExport(limit: Int = 0) throws -> [MailMessage] {\n   934â†’        guard let conn = connection else {\n   935â†’            throw MailDatabaseError.notInitialized\n   936â†’        }\n   937â†’\n   938â†’        var query = \"\"\"\n   939â†’            SELECT * FROM messages\n   940â†’            WHERE is_deleted = 0 AND export_path IS NULL\n   941â†’            ORDER BY date_received DESC\n   942â†’            \"\"\"\n   943â†’\n   944â†’        if limit > 0 {\n   945â†’            query += \" LIMIT \\(limit)\"\n   946â†’        }\n   947â†’\n   948â†’        let result = try conn.query(query)\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"3cc5a05a-8a21-413d-9ac8-f6e6dcc45bc7","tool_use_result":{"type":"text","file":{"filePath":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift","content":"\n        // Mailbox status filter (inbox, archived, deleted)\n        if let mailboxStatus = filter.mailboxStatus {\n            whereClauses.append(\"m.mailbox_status = '\\(mailboxStatus.rawValue)'\")\n        }\n\n        // Always exclude deleted messages\n        whereClauses.append(\"m.is_deleted = 0\")\n\n        // Build the query\n        var sql: String\n\n        if filter.hasFreeText, let freeText = filter.freeText {\n            // Use FTS with additional filters\n            let whereClause = whereClauses.isEmpty ? \"\" : \"AND \" + whereClauses.joined(separator: \" AND \")\n            sql = \"\"\"\n                SELECT m.* FROM messages m\n                JOIN messages_fts fts ON m.rowid = fts.rowid\n                WHERE messages_fts MATCH '\\(escapeSql(escapeFts5Query(freeText)))'\n                \\(whereClause)\n                ORDER BY bm25(messages_fts)\n                LIMIT \\(limit) OFFSET \\(offset)\n                \"\"\"\n        } else if !whereClauses.isEmpty {\n            // Filters only, no FTS\n            let whereClause = whereClauses.joined(separator: \" AND \")\n            sql = \"\"\"\n                SELECT m.* FROM messages m\n                WHERE \\(whereClause)\n                ORDER BY m.date_received DESC\n                LIMIT \\(limit) OFFSET \\(offset)\n                \"\"\"\n        } else {\n            // No filters, return recent messages\n            sql = \"\"\"\n                SELECT * FROM messages m\n                WHERE m.is_deleted = 0\n                ORDER BY m.date_received DESC\n                LIMIT \\(limit) OFFSET \\(offset)\n                \"\"\"\n        }\n\n        let result = try conn.query(sql)\n\n        var messages: [MailMessage] = []\n        for row in result {\n            if let message = try? rowToMessage(row) {\n                messages.append(message)\n            }\n        }\n        return messages\n    }\n\n    /// Get all non-deleted messages (for export without search query)\n    /// - Parameters:\n    ///   - limit: Maximum number of messages to return\n    ///   - offset: Number of messages to skip for pagination\n    /// - Returns: Array of messages ordered by date received (newest first)\n    public func getAllMessages(limit: Int = 100, offset: Int = 0) throws -> [MailMessage] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let query = \"\"\"\n            SELECT * FROM messages\n            WHERE is_deleted = 0\n            ORDER BY date_received DESC\n            LIMIT \\(limit) OFFSET \\(offset)\n            \"\"\"\n\n        let result = try conn.query(query)\n        var messages: [MailMessage] = []\n        for row in result {\n            if let message = try? rowToMessage(row) {\n                messages.append(message)\n            }\n        }\n        return messages\n    }\n\n    /// Get messages that haven't been exported yet (export_path IS NULL)\n    /// Used for incremental auto-export after sync\n    /// - Parameter limit: Maximum number of messages to return (default: unlimited via 0)\n    /// - Returns: Array of messages that need to be exported\n    public func getMessagesNeedingExport(limit: Int = 0) throws -> [MailMessage] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        var query = \"\"\"\n            SELECT * FROM messages\n            WHERE is_deleted = 0 AND export_path IS NULL\n            ORDER BY date_received DESC\n            \"\"\"\n\n        if limit > 0 {\n            query += \" LIMIT \\(limit)\"\n        }\n\n        let result = try conn.query(query)","numLines":100,"startLine":849,"totalLines":2634}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_012kqabJt4vcTmRvzabW8SZ5","type":"message","role":"assistant","content":[{"type":"text","text":"I see - the search is using FTS5. The issue is that when an unknown filter like \"badfilter:value\" is left in `freeText`, the FTS search may fail or work incorrectly. But wait, let me check if there's a `try!` somewhere. Let me search for it."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1558,"cache_read_input_tokens":30072,"cache_creation":{"ephemeral_5m_input_tokens":1558,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"03bbb984-b6da-4c02-bac3-a2120288601e"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_012kqabJt4vcTmRvzabW8SZ5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014k4rVCx82GXdLGymdkTLKZ","name":"Grep","input":{"pattern":"try!","path":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources","output_mode":"content","-n":true}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1558,"cache_read_input_tokens":30072,"cache_creation":{"ephemeral_5m_input_tokens":1558,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"5367cbab-1234-4889-befb-f312be92e434"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014k4rVCx82GXdLGymdkTLKZ","type":"tool_result","content":"No matches found"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"af535637-858a-417a-89f5-b4ab7e4dd9bf","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"","numLines":0}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01R7jSb7TBdqqXrh89eexdZ9","type":"message","role":"assistant","content":[{"type":"text","text":"No `try!` found. Let me check for the actual error. The error mentions `no such column: badfilter`. Let me look more carefully at the FTS escape function."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":215,"cache_read_input_tokens":31630,"cache_creation":{"ephemeral_5m_input_tokens":215,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"f8a39b7c-1443-4ba8-a4bc-7df09e7ae323"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01R7jSb7TBdqqXrh89eexdZ9","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01USX7BFe915V3cEGPi18zZT","name":"Grep","input":{"pattern":"escapeFts5Query|escapeFts","path":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift","output_mode":"content","-n":true,"-C":10}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":215,"cache_read_input_tokens":31630,"cache_creation":{"ephemeral_5m_input_tokens":215,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"870fd504-b1c2-4e17-84df-1119ee9081ef"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01USX7BFe915V3cEGPi18zZT","type":"tool_result","content":"642-\n643-    /// Search messages using FTS\n644-    public func searchMessages(query: String, limit: Int = 50, offset: Int = 0) throws -> [MailMessage] {\n645-        guard let conn = connection else {\n646-            throw MailDatabaseError.notInitialized\n647-        }\n648-\n649-        let result = try conn.query(\"\"\"\n650-            SELECT m.* FROM messages m\n651-            JOIN messages_fts fts ON m.rowid = fts.rowid\n652:            WHERE messages_fts MATCH '\\(escapeSql(escapeFts5Query(query)))'\n653-            ORDER BY bm25(messages_fts)\n654-            LIMIT \\(limit) OFFSET \\(offset)\n655-            \"\"\")\n656-\n657-        var messages: [MailMessage] = []\n658-        for row in result {\n659-            if let message = try? rowToMessage(row) {\n660-                messages.append(message)\n661-            }\n662-        }\n--\n857-\n858-        // Build the query\n859-        var sql: String\n860-\n861-        if filter.hasFreeText, let freeText = filter.freeText {\n862-            // Use FTS with additional filters\n863-            let whereClause = whereClauses.isEmpty ? \"\" : \"AND \" + whereClauses.joined(separator: \" AND \")\n864-            sql = \"\"\"\n865-                SELECT m.* FROM messages m\n866-                JOIN messages_fts fts ON m.rowid = fts.rowid\n867:                WHERE messages_fts MATCH '\\(escapeSql(escapeFts5Query(freeText)))'\n868-                \\(whereClause)\n869-                ORDER BY bm25(messages_fts)\n870-                LIMIT \\(limit) OFFSET \\(offset)\n871-                \"\"\"\n872-        } else if !whereClauses.isEmpty {\n873-            // Filters only, no FTS\n874-            let whereClause = whereClauses.joined(separator: \" AND \")\n875-            sql = \"\"\"\n876-                SELECT m.* FROM messages m\n877-                WHERE \\(whereClause)\n--\n2234-    private func escapeSql(_ string: String) -> String {\n2235-        string.replacingOccurrences(of: \"'\", with: \"''\")\n2236-    }\n2237-\n2238-    /// Escape a query string for safe use in FTS5 MATCH clauses.\n2239-    /// FTS5 has special syntax characters (\", *, OR, AND, NOT, NEAR, etc.) that can cause\n2240-    /// syntax errors if not properly escaped. This function wraps the query in double quotes\n2241-    /// to treat it as a literal phrase, escaping any embedded double quotes.\n2242-    / - Parameter query: The user's search query\n2243-    / - Returns: A safely escaped FTS5 query string\n2244:    private func escapeFts5Query(_ query: String) -> String {\n2245-        // Empty or whitespace-only queries should return empty (will match nothing)\n2246-        let trimmed = query.trimmingCharacters(in: .whitespacesAndNewlines)\n2247-        guard !trimmed.isEmpty else {\n2248-            return \"\\\"\\\"\"\n2249-        }\n2250-\n2251-        // In FTS5, wrapping a term in double quotes makes it a literal phrase.\n2252-        // Any double quotes within the phrase must be escaped by doubling them.\n2253-        / Example: search for hello\"world becomes \"hello\"\"world\"\n2254-        let escaped = trimmed.replacingOccurrences(of: \"\\\"\", with: \"\\\"\\\"\")"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"26dfc5dd-f972-48c3-90ca-8a8ae04f259b","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"642-\n643-    /// Search messages using FTS\n644-    public func searchMessages(query: String, limit: Int = 50, offset: Int = 0) throws -> [MailMessage] {\n645-        guard let conn = connection else {\n646-            throw MailDatabaseError.notInitialized\n647-        }\n648-\n649-        let result = try conn.query(\"\"\"\n650-            SELECT m.* FROM messages m\n651-            JOIN messages_fts fts ON m.rowid = fts.rowid\n652:            WHERE messages_fts MATCH '\\(escapeSql(escapeFts5Query(query)))'\n653-            ORDER BY bm25(messages_fts)\n654-            LIMIT \\(limit) OFFSET \\(offset)\n655-            \"\"\")\n656-\n657-        var messages: [MailMessage] = []\n658-        for row in result {\n659-            if let message = try? rowToMessage(row) {\n660-                messages.append(message)\n661-            }\n662-        }\n--\n857-\n858-        // Build the query\n859-        var sql: String\n860-\n861-        if filter.hasFreeText, let freeText = filter.freeText {\n862-            // Use FTS with additional filters\n863-            let whereClause = whereClauses.isEmpty ? \"\" : \"AND \" + whereClauses.joined(separator: \" AND \")\n864-            sql = \"\"\"\n865-                SELECT m.* FROM messages m\n866-                JOIN messages_fts fts ON m.rowid = fts.rowid\n867:                WHERE messages_fts MATCH '\\(escapeSql(escapeFts5Query(freeText)))'\n868-                \\(whereClause)\n869-                ORDER BY bm25(messages_fts)\n870-                LIMIT \\(limit) OFFSET \\(offset)\n871-                \"\"\"\n872-        } else if !whereClauses.isEmpty {\n873-            // Filters only, no FTS\n874-            let whereClause = whereClauses.joined(separator: \" AND \")\n875-            sql = \"\"\"\n876-                SELECT m.* FROM messages m\n877-                WHERE \\(whereClause)\n--\n2234-    private func escapeSql(_ string: String) -> String {\n2235-        string.replacingOccurrences(of: \"'\", with: \"''\")\n2236-    }\n2237-\n2238-    /// Escape a query string for safe use in FTS5 MATCH clauses.\n2239-    /// FTS5 has special syntax characters (\", *, OR, AND, NOT, NEAR, etc.) that can cause\n2240-    /// syntax errors if not properly escaped. This function wraps the query in double quotes\n2241-    /// to treat it as a literal phrase, escaping any embedded double quotes.\n2242-    / - Parameter query: The user's search query\n2243-    / - Returns: A safely escaped FTS5 query string\n2244:    private func escapeFts5Query(_ query: String) -> String {\n2245-        // Empty or whitespace-only queries should return empty (will match nothing)\n2246-        let trimmed = query.trimmingCharacters(in: .whitespacesAndNewlines)\n2247-        guard !trimmed.isEmpty else {\n2248-            return \"\\\"\\\"\"\n2249-        }\n2250-\n2251-        // In FTS5, wrapping a term in double quotes makes it a literal phrase.\n2252-        // Any double quotes within the phrase must be escaped by doubling them.\n2253-        / Example: search for hello\"world becomes \"hello\"\"world\"\n2254-        let escaped = trimmed.replacingOccurrences(of: \"\\\"\", with: \"\\\"\\\"\")","numLines":65}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01JMMJqLR6iYjczR6Y9VoP7J","type":"message","role":"assistant","content":[{"type":"text","text":"I see. The `escapeFts5Query` escapes the query, but the issue is FTS5 interprets `badfilter:value` as a column prefix search - it's looking for a column named `badfilter`. Let me see the full `escapeFts5Query` function."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1140,"cache_read_input_tokens":31845,"cache_creation":{"ephemeral_5m_input_tokens":1140,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"cec720c1-6cd3-4843-99c7-d245c9c4624d"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01JMMJqLR6iYjczR6Y9VoP7J","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016eVgBpv7AmoWvJir39EM55","name":"Read","input":{"file_path":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift","offset":2238,"limit":40}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1140,"cache_read_input_tokens":31845,"cache_creation":{"ephemeral_5m_input_tokens":1140,"ephemeral_1h_input_tokens":0},"output_tokens":197,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"472e539f-7e34-436d-9aec-85f9480dd1a5"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016eVgBpv7AmoWvJir39EM55","type":"tool_result","content":"  2238â†’    /// Escape a query string for safe use in FTS5 MATCH clauses.\n  2239â†’    /// FTS5 has special syntax characters (\", *, OR, AND, NOT, NEAR, etc.) that can cause\n  2240â†’    /// syntax errors if not properly escaped. This function wraps the query in double quotes\n  2241â†’    /// to treat it as a literal phrase, escaping any embedded double quotes.\n  2242â†’    /// - Parameter query: The user's search query\n  2243â†’    /// - Returns: A safely escaped FTS5 query string\n  2244â†’    private func escapeFts5Query(_ query: String) -> String {\n  2245â†’        // Empty or whitespace-only queries should return empty (will match nothing)\n  2246â†’        let trimmed = query.trimmingCharacters(in: .whitespacesAndNewlines)\n  2247â†’        guard !trimmed.isEmpty else {\n  2248â†’            return \"\\\"\\\"\"\n  2249â†’        }\n  2250â†’\n  2251â†’        // In FTS5, wrapping a term in double quotes makes it a literal phrase.\n  2252â†’        // Any double quotes within the phrase must be escaped by doubling them.\n  2253â†’        // Example: search for hello\"world becomes \"hello\"\"world\"\n  2254â†’        let escaped = trimmed.replacingOccurrences(of: \"\\\"\", with: \"\\\"\\\"\")\n  2255â†’        return \"\\\"\\(escaped)\\\"\"\n  2256â†’    }\n  2257â†’\n  2258â†’    /// Serialize a references array to JSON string for database storage\n  2259â†’    private func serializeReferences(_ references: [String]) -> String? {\n  2260â†’        guard !references.isEmpty else { return nil }\n  2261â†’        guard let data = try? JSONEncoder().encode(references),\n  2262â†’              let json = String(data: data, encoding: .utf8) else {\n  2263â†’            return nil\n  2264â†’        }\n  2265â†’        return json\n  2266â†’    }\n  2267â†’\n  2268â†’    /// Deserialize a JSON string to references array\n  2269â†’    private func deserializeReferences(_ json: String?) -> [String] {\n  2270â†’        guard let json = json,\n  2271â†’              let data = json.data(using: .utf8),\n  2272â†’              let references = try? JSONDecoder().decode([String].self, from: data) else {\n  2273â†’            return []\n  2274â†’        }\n  2275â†’        return references\n  2276â†’    }\n  2277â†’}\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"1784cdc8-ccd5-42cb-b76a-40d0a70ffc65","tool_use_result":{"type":"text","file":{"filePath":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift","content":"    /// Escape a query string for safe use in FTS5 MATCH clauses.\n    /// FTS5 has special syntax characters (\", *, OR, AND, NOT, NEAR, etc.) that can cause\n    /// syntax errors if not properly escaped. This function wraps the query in double quotes\n    /// to treat it as a literal phrase, escaping any embedded double quotes.\n    /// - Parameter query: The user's search query\n    /// - Returns: A safely escaped FTS5 query string\n    private func escapeFts5Query(_ query: String) -> String {\n        // Empty or whitespace-only queries should return empty (will match nothing)\n        let trimmed = query.trimmingCharacters(in: .whitespacesAndNewlines)\n        guard !trimmed.isEmpty else {\n            return \"\\\"\\\"\"\n        }\n\n        // In FTS5, wrapping a term in double quotes makes it a literal phrase.\n        // Any double quotes within the phrase must be escaped by doubling them.\n        // Example: search for hello\"world becomes \"hello\"\"world\"\n        let escaped = trimmed.replacingOccurrences(of: \"\\\"\", with: \"\\\"\\\"\")\n        return \"\\\"\\(escaped)\\\"\"\n    }\n\n    /// Serialize a references array to JSON string for database storage\n    private func serializeReferences(_ references: [String]) -> String? {\n        guard !references.isEmpty else { return nil }\n        guard let data = try? JSONEncoder().encode(references),\n              let json = String(data: data, encoding: .utf8) else {\n            return nil\n        }\n        return json\n    }\n\n    /// Deserialize a JSON string to references array\n    private func deserializeReferences(_ json: String?) -> [String] {\n        guard let json = json,\n              let data = json.data(using: .utf8),\n              let references = try? JSONDecoder().decode([String].self, from: data) else {\n            return []\n        }\n        return references\n    }\n}","numLines":40,"startLine":2238,"totalLines":2634}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VTQn1jbYjBJLX1cseyTRoc","type":"message","role":"assistant","content":[{"type":"text","text":"Interesting. The `escapeFts5Query` wraps the query in double quotes, which should treat colons as literal characters. Let me check where the actual error might be occurring. The error message mentions \"no such column: badfilter\", which is an FTS5-specific error when using column prefix syntax.\n\nWait - the previous fix for swiftea-2hz.3 was \"Fix crash on special characters in search query\". Let me check what was done there."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":920,"cache_read_input_tokens":32985,"cache_creation":{"ephemeral_5m_input_tokens":920,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"85c7f406-5dcf-45b3-acc8-0518b9440e79"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01VTQn1jbYjBJLX1cseyTRoc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NW6BLjAX7zoD5E2DW18bvc","name":"Bash","input":{"command":"cd /Users/I852000/Library/Mobile\\ Documents/com~apple~CloudDocs/swiftea && git show 0833bf4 --stat","description":"Check the special characters fix commit"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":920,"cache_read_input_tokens":32985,"cache_creation":{"ephemeral_5m_input_tokens":920,"ephemeral_1h_input_tokens":0},"output_tokens":212,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"2a9e0419-84e6-465b-9fce-67433570a6f8"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NW6BLjAX7zoD5E2DW18bvc","type":"tool_result","content":"commit 0833bf44d375becc456821b089ffe05ca80f854f\nAuthor: dwrekofc <derek@seshling.com>\nDate:   Thu Jan 15 19:13:30 2026 -0700\n\n    feat: swiftea-2hz.3 - US-003: Fix crash on special characters in search query\n    \n    Add FTS5 query escaping to handle special characters safely in mail search:\n    - Wrap search queries in double quotes for literal phrase matching\n    - Escape embedded double quotes by doubling them\n    - Handles single quotes, double quotes, SQL injection attempts, and FTS5\n      operators (AND, OR, NOT, NEAR) without crashing\n    \n    Queries like `'`, `\"`, `OR 1=1 --` now return empty results gracefully\n    instead of causing SQLite FTS5 syntax errors.\n    \n    Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\n\n .../Modules/MailModule/MailDatabase.swift          | 24 +++++-\n Tests/SwiftEAKitTests/MailDatabaseTests.swift      | 92 ++++++++++++++++++++++\n 2 files changed, 114 insertions(+), 2 deletions(-)","is_error":false}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"90cd8f58-aa8b-48aa-a8f9-2fd2b4150442","tool_use_result":{"stdout":"commit 0833bf44d375becc456821b089ffe05ca80f854f\nAuthor: dwrekofc <derek@seshling.com>\nDate:   Thu Jan 15 19:13:30 2026 -0700\n\n    feat: swiftea-2hz.3 - US-003: Fix crash on special characters in search query\n    \n    Add FTS5 query escaping to handle special characters safely in mail search:\n    - Wrap search queries in double quotes for literal phrase matching\n    - Escape embedded double quotes by doubling them\n    - Handles single quotes, double quotes, SQL injection attempts, and FTS5\n      operators (AND, OR, NOT, NEAR) without crashing\n    \n    Queries like `'`, `\"`, `OR 1=1 --` now return empty results gracefully\n    instead of causing SQLite FTS5 syntax errors.\n    \n    Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\n\n .../Modules/MailModule/MailDatabase.swift          | 24 +++++-\n Tests/SwiftEAKitTests/MailDatabaseTests.swift      | 92 ++++++++++++++++++++++\n 2 files changed, 114 insertions(+), 2 deletions(-)","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TrDgqQg6zxFSS2Gydnei32","type":"message","role":"assistant","content":[{"type":"text","text":"So the previous fix added the `escapeFts5Query` function. Let me test if the issue still exists by looking at the current test file and trying to understand the behavior."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":727,"cache_read_input_tokens":33905,"cache_creation":{"ephemeral_5m_input_tokens":727,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"1078f09c-4239-482c-8d45-0cf731f0197c"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TrDgqQg6zxFSS2Gydnei32","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Y3GbgkrANMatHdBcQkQA92","name":"Bash","input":{"command":"cd /Users/I852000/Library/Mobile\\ Documents/com~apple~CloudDocs/swiftea && swift build 2>&1","description":"Build the project to test current state","timeout":300000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":727,"cache_read_input_tokens":33905,"cache_creation":{"ephemeral_5m_input_tokens":727,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"a8d595a1-3620-46aa-9fdb-f525ee451a42"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Y3GbgkrANMatHdBcQkQA92","type":"tool_result","content":"warning: 'swiftea': found 1 file(s) which are unhandled; explicitly declare them as resources or exclude from the target\n    /Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/CalendarModule/README.md\n[0/1] Planning build\n[1/1] Compiling plugin GenerateManual\n[2/2] Compiling plugin GenerateDoccReference\nBuilding for debugging...\n[2/5] Write swift-version--58304C5D6DBC2206.txt\nBuild complete! (0.60s)","is_error":false}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"ea4cde71-b352-498c-87f8-3b9ecc9c42bb","tool_use_result":{"stdout":"warning: 'swiftea': found 1 file(s) which are unhandled; explicitly declare them as resources or exclude from the target\n    /Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/CalendarModule/README.md\n[0/1] Planning build\n[1/1] Compiling plugin GenerateManual\n[2/2] Compiling plugin GenerateDoccReference\nBuilding for debugging...\n[2/5] Write swift-version--58304C5D6DBC2206.txt\nBuild complete! (0.60s)","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01LUCZ4DJAC25RgukpshbGnH","type":"message","role":"assistant","content":[{"type":"text","text":"Good, it builds. Now let me look at how the command handles errors when executing the search."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":324,"cache_read_input_tokens":34632,"cache_creation":{"ephemeral_5m_input_tokens":324,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"538209fd-9dbb-40e2-9b0f-db15be75fe6b"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01LUCZ4DJAC25RgukpshbGnH","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015gAWWbhG4AhDaog8iAJ7u9","name":"Read","input":{"file_path":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEACLI/Commands/MailCommand.swift","offset":1270,"limit":60}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":324,"cache_read_input_tokens":34632,"cache_creation":{"ephemeral_5m_input_tokens":324,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"af457a6c-c994-49be-9bcc-98281df10863"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015gAWWbhG4AhDaog8iAJ7u9","type":"tool_result","content":"  1270â†’\n  1271â†’        // Open mail database\n  1272â†’        let mailDbPath = (vault.dataFolderPath as NSString).appendingPathComponent(\"mail.db\")\n  1273â†’        let mailDatabase = MailDatabase(databasePath: mailDbPath)\n  1274â†’        try mailDatabase.initialize()\n  1275â†’        defer { mailDatabase.close() }\n  1276â†’\n  1277â†’        // Parse the query for structured filters\n  1278â†’        var filter = mailDatabase.parseQuery(query)\n  1279â†’\n  1280â†’        // Apply --status option if provided\n  1281â†’        if let statusValue = status {\n  1282â†’            filter.mailboxStatus = MailboxStatus(rawValue: statusValue.lowercased())\n  1283â†’        }\n  1284â†’\n  1285â†’        // Use structured search if we have filters, otherwise fall back to basic FTS\n  1286â†’        let results: [MailMessage]\n  1287â†’        if filter.hasFilters || filter.hasFreeText {\n  1288â†’            results = try mailDatabase.searchMessagesWithFilters(filter, limit: limit)\n  1289â†’        } else {\n  1290â†’            // Empty query - show recent messages\n  1291â†’            results = try mailDatabase.getAllMessages(limit: limit)\n  1292â†’        }\n  1293â†’\n  1294â†’        if results.isEmpty {\n  1295â†’            printError(\"No messages found for: \\(query)\")\n  1296â†’            return\n  1297â†’        }\n  1298â†’\n  1299â†’        if json {\n  1300â†’            // Output as JSON with filter info\n  1301â†’            var output: [[String: Any]] = []\n  1302â†’            for msg in results {\n  1303â†’                let msgDict: [String: Any] = [\n  1304â†’                    \"id\": msg.id,\n  1305â†’                    \"subject\": msg.subject,\n  1306â†’                    \"sender\": msg.senderEmail ?? \"\",\n  1307â†’                    \"senderName\": msg.senderName ?? \"\",\n  1308â†’                    \"date\": msg.dateSent?.description ?? \"\",\n  1309â†’                    \"mailbox\": msg.mailboxName ?? \"\",\n  1310â†’                    \"isRead\": msg.isRead,\n  1311â†’                    \"isFlagged\": msg.isFlagged,\n  1312â†’                    \"hasAttachments\": msg.hasAttachments\n  1313â†’                ]\n  1314â†’                output.append(msgDict)\n  1315â†’            }\n  1316â†’            if let data = try? JSONSerialization.data(withJSONObject: output, options: .prettyPrinted),\n  1317â†’               let jsonString = String(data: data, encoding: .utf8) {\n  1318â†’                print(jsonString)\n  1319â†’            }\n  1320â†’        } else {\n  1321â†’            // Show filter summary if structured filters were used\n  1322â†’            if filter.hasFilters {\n  1323â†’                var filterDesc: [String] = []\n  1324â†’                if let from = filter.from { filterDesc.append(\"from:\\(from)\") }\n  1325â†’                if let to = filter.to { filterDesc.append(\"to:\\(to)\") }\n  1326â†’                if let subject = filter.subject { filterDesc.append(\"subject:\\(subject)\") }\n  1327â†’                if let mailbox = filter.mailbox { filterDesc.append(\"mailbox:\\(mailbox)\") }\n  1328â†’                if let mailboxStatus = filter.mailboxStatus { filterDesc.append(\"status:\\(mailboxStatus.rawValue)\") }\n  1329â†’                if let isRead = filter.isRead { filterDesc.append(isRead ? \"is:read\" : \"is:unread\") }\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"ea821d98-51ce-4287-8ba1-cab0998d1116","tool_use_result":{"type":"text","file":{"filePath":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEACLI/Commands/MailCommand.swift","content":"\n        // Open mail database\n        let mailDbPath = (vault.dataFolderPath as NSString).appendingPathComponent(\"mail.db\")\n        let mailDatabase = MailDatabase(databasePath: mailDbPath)\n        try mailDatabase.initialize()\n        defer { mailDatabase.close() }\n\n        // Parse the query for structured filters\n        var filter = mailDatabase.parseQuery(query)\n\n        // Apply --status option if provided\n        if let statusValue = status {\n            filter.mailboxStatus = MailboxStatus(rawValue: statusValue.lowercased())\n        }\n\n        // Use structured search if we have filters, otherwise fall back to basic FTS\n        let results: [MailMessage]\n        if filter.hasFilters || filter.hasFreeText {\n            results = try mailDatabase.searchMessagesWithFilters(filter, limit: limit)\n        } else {\n            // Empty query - show recent messages\n            results = try mailDatabase.getAllMessages(limit: limit)\n        }\n\n        if results.isEmpty {\n            printError(\"No messages found for: \\(query)\")\n            return\n        }\n\n        if json {\n            // Output as JSON with filter info\n            var output: [[String: Any]] = []\n            for msg in results {\n                let msgDict: [String: Any] = [\n                    \"id\": msg.id,\n                    \"subject\": msg.subject,\n                    \"sender\": msg.senderEmail ?? \"\",\n                    \"senderName\": msg.senderName ?? \"\",\n                    \"date\": msg.dateSent?.description ?? \"\",\n                    \"mailbox\": msg.mailboxName ?? \"\",\n                    \"isRead\": msg.isRead,\n                    \"isFlagged\": msg.isFlagged,\n                    \"hasAttachments\": msg.hasAttachments\n                ]\n                output.append(msgDict)\n            }\n            if let data = try? JSONSerialization.data(withJSONObject: output, options: .prettyPrinted),\n               let jsonString = String(data: data, encoding: .utf8) {\n                print(jsonString)\n            }\n        } else {\n            // Show filter summary if structured filters were used\n            if filter.hasFilters {\n                var filterDesc: [String] = []\n                if let from = filter.from { filterDesc.append(\"from:\\(from)\") }\n                if let to = filter.to { filterDesc.append(\"to:\\(to)\") }\n                if let subject = filter.subject { filterDesc.append(\"subject:\\(subject)\") }\n                if let mailbox = filter.mailbox { filterDesc.append(\"mailbox:\\(mailbox)\") }\n                if let mailboxStatus = filter.mailboxStatus { filterDesc.append(\"status:\\(mailboxStatus.rawValue)\") }\n                if let isRead = filter.isRead { filterDesc.append(isRead ? \"is:read\" : \"is:unread\") }","numLines":60,"startLine":1270,"totalLines":3605}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01SVNJkDDb27FnKxEQpifSua","type":"message","role":"assistant","content":[{"type":"text","text":"Now I understand the problem better. When a user types `badfilter:value`, the `parseQuery` method doesn't recognize it as a valid filter and leaves it in `freeText`. This `freeText` then goes to `escapeFts5Query` which wraps it in quotes, becoming `\"badfilter:value\"`. \n\nHowever, the issue is in FTS5, even in double quotes, the colon character in specific contexts can still be interpreted as a column prefix. Let me look at a test to verify."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1178,"cache_read_input_tokens":34956,"cache_creation":{"ephemeral_5m_input_tokens":1178,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"cef0b794-308c-4423-ac50-5ff67796e4e9"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01SVNJkDDb27FnKxEQpifSua","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014X9iJUYgKrvd6BJSEYwXcG","name":"Grep","input":{"pattern":"badfilter|unknown.*filter|invalid.*filter","path":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests","output_mode":"content","-n":true}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1178,"cache_read_input_tokens":34956,"cache_creation":{"ephemeral_5m_input_tokens":1178,"ephemeral_1h_input_tokens":0},"output_tokens":257,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"a861a01e-cbde-4a14-8771-66a3f6371974"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014X9iJUYgKrvd6BJSEYwXcG","type":"tool_result","content":"No matches found"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"30955c1a-e7f6-4c70-89a3-1c66eca6d689","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"","numLines":0}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01XpQKFhoKEWiLw7i4t4wQ8o","type":"message","role":"assistant","content":[{"type":"text","text":"Let me check the existing tests for mail search."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":272,"cache_read_input_tokens":36134,"cache_creation":{"ephemeral_5m_input_tokens":272,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"641dd110-0fa6-4f05-a7c7-3fafae77cee8"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01XpQKFhoKEWiLw7i4t4wQ8o","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01K46BE6g2XznMBka5vFddgy","name":"Grep","input":{"pattern":"testSearch|testFTS|searchMessages","path":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests","output_mode":"content","-n":true,"-C":3}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":272,"cache_read_input_tokens":36134,"cache_creation":{"ephemeral_5m_input_tokens":272,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"35fce622-bc8e-42b2-bece-3be746153467"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01K46BE6g2XznMBka5vFddgy","type":"tool_result","content":"<persisted-output>\nOutput too large (23.2KB). Full output saved to: /Users/I852000/.claude/projects/-Users-I852000-Library-Mobile-Documents-com-apple-CloudDocs-swiftea/5a947bfe-0fe0-45e8-8f0b-a1aaf572731b/tool-results/toolu_01K46BE6g2XznMBka5vFddgy.txt\n\nPreview (first 2KB):\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailSyncTests.swift-407-        XCTAssertTrue(retrieved?.bodyText?.contains(\"simple test email body\") == true)\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailSyncTests.swift-408-\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailSyncTests.swift-409-        // Verify FTS works\nTests/SwiftEAKitTests/MailSyncTests.swift:410:        let searchResults = try mailDatabase.searchMessages(query: \"simple test\")\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailSyncTests.swift-411-        XCTAssertEqual(searchResults.count, 1)\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailSyncTests.swift-412-        XCTAssertEqual(searchResults.first?.id, id)\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailSyncTests.swift-413-    }\n--\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/CalendarDatabaseTests.swift-401-\nTests/SwiftEAKitTests/CalendarDatabaseTests.swift-402-    / MARK: - FTS Search\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/CalendarDatabaseTests.swift-403-\nTests/SwiftEAKitTests/CalendarDatabaseTests.swift:404:    func testFTSSearch() throws {\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/CalendarDatabaseTests.swift-405-        try database.initialize()\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/CalendarDatabaseTests.swift-406-\nTests/SwiftEAKitTests/CalendarDatabaseTests.swift-407-        let calendar = StoredCalendar(id: \"cal-fts\", title: \"FTS Test\")\n--\n...\n</persisted-output>"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"7a6d481b-5eb8-4d80-bf52-a41970fd69c8","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailSyncTests.swift-407-        XCTAssertTrue(retrieved?.bodyText?.contains(\"simple test email body\") == true)\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailSyncTests.swift-408-\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailSyncTests.swift-409-        // Verify FTS works\nTests/SwiftEAKitTests/MailSyncTests.swift:410:        let searchResults = try mailDatabase.searchMessages(query: \"simple test\")\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailSyncTests.swift-411-        XCTAssertEqual(searchResults.count, 1)\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailSyncTests.swift-412-        XCTAssertEqual(searchResults.first?.id, id)\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailSyncTests.swift-413-    }\n--\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/CalendarDatabaseTests.swift-401-\nTests/SwiftEAKitTests/CalendarDatabaseTests.swift-402-    / MARK: - FTS Search\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/CalendarDatabaseTests.swift-403-\nTests/SwiftEAKitTests/CalendarDatabaseTests.swift:404:    func testFTSSearch() throws {\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/CalendarDatabaseTests.swift-405-        try database.initialize()\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/CalendarDatabaseTests.swift-406-\nTests/SwiftEAKitTests/CalendarDatabaseTests.swift-407-        let calendar = StoredCalendar(id: \"cal-fts\", title: \"FTS Test\")\n--\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/CalendarDatabaseTests.swift-426-        XCTAssertTrue(results.contains { $0.id == \"fts-3\" })\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/CalendarDatabaseTests.swift-427-    }\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/CalendarDatabaseTests.swift-428-\nTests/SwiftEAKitTests/CalendarDatabaseTests.swift:429:    func testFTSSearchDescription() throws {\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/CalendarDatabaseTests.swift-430-        try database.initialize()\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/CalendarDatabaseTests.swift-431-\nTests/SwiftEAKitTests/CalendarDatabaseTests.swift-432-        let calendar = StoredCalendar(id: \"cal-fts-desc\", title: \"FTS Desc Test\")\n--\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEACLITests/MailCommandValidationTests.swift-58-\nTests/SwiftEACLITests/MailCommandValidationTests.swift-59-    / MARK: - MailSearchCommand Validation Tests\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEACLITests/MailCommandValidationTests.swift-60-\nTests/SwiftEACLITests/MailCommandValidationTests.swift:61:    func testSearchCommandLimitZeroIsInvalid() throws {\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEACLITests/MailCommandValidationTests.swift-62-        XCTAssertThrowsError(try MailSearchCommand.parseAsRoot([\"test query\", \"--limit\", \"0\"])) { error in\nTests/SwiftEACLITests/MailCommandValidationTests.swift-63-            guard let validationError = extractValidationError(from: error) else {\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEACLITests/MailCommandValidationTests.swift-64-                XCTFail(\"Expected MailValidationError.invalidLimit, got \\(error)\")\n--\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEACLITests/MailCommandValidationTests.swift-72-        }\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEACLITests/MailCommandValidationTests.swift-73-    }\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEACLITests/MailCommandValidationTests.swift-74-\nTests/SwiftEACLITests/MailCommandValidationTests.swift:75:    func testSearchCommandNegativeLimitIsInvalid() throws {\nTests/SwiftEACLITests/MailCommandValidationTests.swift-76-        / Note: ArgumentParser may parse \"-5\" as a flag rather than a value\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEACLITests/MailCommandValidationTests.swift-77-        // We test with a clearly negative number\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEACLITests/MailCommandValidationTests.swift-78-        XCTAssertThrowsError(try MailSearchCommand.parseAsRoot([\"test query\", \"--limit=0\"])) { error in\n--\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEACLITests/MailCommandValidationTests.swift-84-        }\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEACLITests/MailCommandValidationTests.swift-85-    }\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEACLITests/MailCommandValidationTests.swift-86-\nTests/SwiftEACLITests/MailCommandValidationTests.swift:87:    func testSearchCommandPositiveLimitIsValid() throws {\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEACLITests/MailCommandValidationTests.swift-88-        XCTAssertNoThrow(try MailSearchCommand.parseAsRoot([\"test query\", \"--limit\", \"10\"]))\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEACLITests/MailCommandValidationTests.swift-89-    }\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEACLITests/MailCommandValidationTests.swift-90-\nTests/SwiftEACLITests/MailCommandValidationTests.swift:91:    func testSearchCommandDefaultLimitIsValid() throws {\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEACLITests/MailCommandValidationTests.swift-92-        XCTAssertNoThrow(try MailSearchCommand.parseAsRoot([\"test query\"]))\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEACLITests/MailCommandValidationTests.swift-93-    }\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEACLITests/MailCommandValidationTests.swift-94-\n--\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-169-\nTests/SwiftEAKitTests/MailDatabaseTests.swift-170-    / MARK: - FTS Search\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-171-\nTests/SwiftEAKitTests/MailDatabaseTests.swift:172:    func testSearchMessages() throws {\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-173-        try database.initialize()\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-174-\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-175-        // Insert multiple messages\n--\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-184-        }\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-185-\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-186-        // Search for \"alpha\"\nTests/SwiftEAKitTests/MailDatabaseTests.swift:187:        let results = try database.searchMessages(query: \"alpha\")\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-188-\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-189-        XCTAssertEqual(results.count, 2)\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-190-        XCTAssertTrue(results.contains { $0.id == \"search-1\" })\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-191-        XCTAssertTrue(results.contains { $0.id == \"search-3\" })\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-192-    }\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-193-\nTests/SwiftEAKitTests/MailDatabaseTests.swift:194:    func testSearchWithNoResults() throws {\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-195-        try database.initialize()\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-196-\nTests/SwiftEAKitTests/MailDatabaseTests.swift-197-        let message = MailMessage(id: \"no-match\", subject: \"Hello world\")\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-198-        try database.upsertMessage(message)\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-199-\nTests/SwiftEAKitTests/MailDatabaseTests.swift:200:        let results = try database.searchMessages(query: \"nonexistent\")\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-201-\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-202-        XCTAssertTrue(results.isEmpty)\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-203-    }\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-204-\nTests/SwiftEAKitTests/MailDatabaseTests.swift:205:    func testSearchWithLimit() throws {\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-206-        try database.initialize()\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-207-\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-208-        // Insert many messages\n--\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-211-            try database.upsertMessage(msg)\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-212-        }\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-213-\nTests/SwiftEAKitTests/MailDatabaseTests.swift:214:        let results = try database.searchMessages(query: \"keyword\", limit: 5)\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-215-\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-216-        XCTAssertEqual(results.count, 5)\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-217-    }\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-218-\nTests/SwiftEAKitTests/MailDatabaseTests.swift-219-    / MARK: - FTS5 Special Character Handling\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-220-\nTests/SwiftEAKitTests/MailDatabaseTests.swift:221:    func testSearchWithSingleQuote() throws {\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-222-        try database.initialize()\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-223-\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-224-        // Insert message containing a single quote\n--\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-226-        try database.upsertMessage(message)\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-227-\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-228-        // Search for single quote - should not crash, should return empty or matching results\nTests/SwiftEAKitTests/MailDatabaseTests.swift:229:        let results = try database.searchMessages(query: \"'\")\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-230-        // The query should execute without throwing\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-231-        XCTAssertNotNil(results)\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-232-    }\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-233-\nTests/SwiftEAKitTests/MailDatabaseTests.swift:234:    func testSearchWithDoubleQuote() throws {\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-235-        try database.initialize()\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-236-\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-237-        // Insert message containing double quotes\n--\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-239-        try database.upsertMessage(message)\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-240-\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-241-        // Search for double quote - should not crash\nTests/SwiftEAKitTests/MailDatabaseTests.swift:242:        let results = try database.searchMessages(query: \"\\\"\")\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-243-        XCTAssertNotNil(results)\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-244-    }\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-245-\nTests/SwiftEAKitTests/MailDatabaseTests.swift:246:    func testSearchWithSqlInjectionAttempt() throws {\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-247-        try database.initialize()\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-248-\nTests/SwiftEAKitTests/MailDatabaseTests.swift-249-        let message = MailMessage(id: \"sql-test\", subject: \"Normal email\")\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-250-        try database.upsertMessage(message)\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-251-\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-252-        // SQL injection-like syntax should not crash or cause errors\nTests/SwiftEAKitTests/MailDatabaseTests.swift:253:        let results = try database.searchMessages(query: \"OR 1=1 --\")\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-254-        XCTAssertNotNil(results)\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-255-        // Should return empty since this is treated as literal text, not SQL\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-256-        XCTAssertTrue(results.isEmpty)\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-257-    }\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-258-\nTests/SwiftEAKitTests/MailDatabaseTests.swift:259:    func testSearchWithFts5Operators() throws {\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-260-        try database.initialize()\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-261-\nTests/SwiftEAKitTests/MailDatabaseTests.swift-262-        let message = MailMessage(id: \"fts-test\", subject: \"Test AND or OR words\", bodyText: \"NOT near NEAR\")\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-263-        try database.upsertMessage(message)\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-264-\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-265-        // FTS5 operators (AND, OR, NOT, NEAR) should be treated as literal text\nTests/SwiftEAKitTests/MailDatabaseTests.swift:266:        XCTAssertNoThrow(try database.searchMessages(query: \"AND\"))\nTests/SwiftEAKitTests/MailDatabaseTests.swift:267:        XCTAssertNoThrow(try database.searchMessages(query: \"OR\"))\nTests/SwiftEAKitTests/MailDatabaseTests.swift:268:        XCTAssertNoThrow(try database.searchMessages(query: \"NOT\"))\nTests/SwiftEAKitTests/MailDatabaseTests.swift:269:        XCTAssertNoThrow(try database.searchMessages(query: \"NEAR\"))\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-270-    }\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-271-\nTests/SwiftEAKitTests/MailDatabaseTests.swift:272:    func testSearchWithSpecialCharacters() throws {\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-273-        try database.initialize()\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-274-\nTests/SwiftEAKitTests/MailDatabaseTests.swift-275-        let message = MailMessage(id: \"special-test\", subject: \"Special chars: * ( ) { } [ ]\")\n--\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-278-        // Various special characters should not crash\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-279-        let specialChars = [\"*\", \"(\", \")\", \"{\", \"}\", \"[\", \"]\", \"+\", \"-\", \"^\", \"~\"]\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-280-        for char in specialChars {\nTests/SwiftEAKitTests/MailDatabaseTests.swift:281:            XCTAssertNoThrow(try database.searchMessages(query: char), \"Search should not crash for character: \\(char)\")\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-282-        }\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-283-    }\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-284-\nTests/SwiftEAKitTests/MailDatabaseTests.swift:285:    func testSearchWithMixedSpecialCharacters() throws {\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-286-        try database.initialize()\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-287-\nTests/SwiftEAKitTests/MailDatabaseTests.swift-288-        let message = MailMessage(id: \"mixed-test\", subject: \"Can't say \\\"hello (world)\\\"\")\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-289-        try database.upsertMessage(message)\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-290-\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-291-        // Complex query with multiple special characters\nTests/SwiftEAKitTests/MailDatabaseTests.swift:292:        let results = try database.searchMessages(query: \"Can't say \\\"hello\\\"\")\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-293-        XCTAssertNotNil(results)\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-294-    }\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-295-\nTests/SwiftEAKitTests/MailDatabaseTests.swift:296:    func testSearchWithEmptyQuery() throws {\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-297-        try database.initialize()\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-298-\nTests/SwiftEAKitTests/MailDatabaseTests.swift-299-        let message = MailMessage(id: \"empty-test\", subject: \"Test message\")\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-300-        try database.upsertMessage(message)\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-301-\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-302-        // Empty query should not crash\nTests/SwiftEAKitTests/MailDatabaseTests.swift:303:        let results = try database.searchMessages(query: \"\")\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-304-        XCTAssertNotNil(results)\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-305-\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-306-        // Whitespace-only query should not crash\nTests/SwiftEAKitTests/MailDatabaseTests.swift:307:        let results2 = try database.searchMessages(query: \"   \")\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-308-        XCTAssertNotNil(results2)\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-309-    }\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift-310-","numLines":185}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01F3V9YNcTsPqXDs2Sdfwfg1","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012fWPFEE4Wq27CqKjZDj2dj","name":"Grep","input":{"pattern":"testSpecialCharacter|escapeFts5Query|special.*search","path":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift","output_mode":"content","-n":true,"-C":5}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":974,"cache_read_input_tokens":36406,"cache_creation":{"ephemeral_5m_input_tokens":974,"ephemeral_1h_input_tokens":0},"output_tokens":26,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"155f4a4e-6ecf-441e-b441-72c86133fea4"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012fWPFEE4Wq27CqKjZDj2dj","type":"tool_result","content":"No matches found"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"a72ddf0c-95e3-4a6e-a5e7-c53a94ac5c03","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"","numLines":0}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01PEgfoZK3gAQCDdz5dtbcRJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BzfgWA69KNmeHVVz3dQe2r","name":"Grep","input":{"pattern":"special|escape","path":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift","output_mode":"content","-n":true,"-C":10}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":193,"cache_read_input_tokens":37380,"cache_creation":{"ephemeral_5m_input_tokens":193,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"9f992dfe-af1d-47aa-8424-4719a0674dcf"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BzfgWA69KNmeHVVz3dQe2r","type":"tool_result","content":"129-        XCTAssertEqual(retrieved?.subject, \"Updated Subject\")\n130-        XCTAssertEqual(retrieved?.isRead, true)\n131-    }\n132-\n133-    / MARK: - Special Characters\n134-\n135-    func testMessageWithSpecialCharactersInSubject() throws {\n136-        try database.initialize()\n137-\n138-        let message = MailMessage(\n139:            id: \"special-chars\",\n140-            subject: \"Test with 'quotes' and \\\"double\\\" and emoji ðŸŽ‰\"\n141-        )\n142-\n143-        try database.upsertMessage(message)\n144-\n145:        let retrieved = try database.getMessage(id: \"special-chars\")\n146-        XCTAssertEqual(retrieved?.subject, \"Test with 'quotes' and \\\"double\\\" and emoji ðŸŽ‰\")\n147-    }\n148-\n149-    func testMessageWithSqlInjectionAttempt() throws {\n150-        try database.initialize()\n151-\n152-        let message = MailMessage(\n153-            id: \"sql-inject\",\n154-            subject: \"Test'; DROP TABLE messages; --\"\n155-        )\n--\n265-        // FTS5 operators (AND, OR, NOT, NEAR) should be treated as literal text\n266-        XCTAssertNoThrow(try database.searchMessages(query: \"AND\"))\n267-        XCTAssertNoThrow(try database.searchMessages(query: \"OR\"))\n268-        XCTAssertNoThrow(try database.searchMessages(query: \"NOT\"))\n269-        XCTAssertNoThrow(try database.searchMessages(query: \"NEAR\"))\n270-    }\n271-\n272-    func testSearchWithSpecialCharacters() throws {\n273-        try database.initialize()\n274-\n275:        let message = MailMessage(id: \"special-test\", subject: \"Special chars: * ( ) { } [ ]\")\n276-        try database.upsertMessage(message)\n277-\n278:        // Various special characters should not crash\n279:        let specialChars = [\"*\", \"(\", \")\", \"{\", \"}\", \"[\", \"]\", \"+\", \"-\", \"^\", \"~\"]\n280:        for char in specialChars {\n281-            XCTAssertNoThrow(try database.searchMessages(query: char), \"Search should not crash for character: \\(char)\")\n282-        }\n283-    }\n284-\n285-    func testSearchWithMixedSpecialCharacters() throws {\n286-        try database.initialize()\n287-\n288-        let message = MailMessage(id: \"mixed-test\", subject: \"Can't say \\\"hello (world)\\\"\")\n289-        try database.upsertMessage(message)\n290-\n291:        // Complex query with multiple special characters\n292-        let results = try database.searchMessages(query: \"Can't say \\\"hello\\\"\")\n293-        XCTAssertNotNil(results)\n294-    }\n295-\n296-    func testSearchWithEmptyQuery() throws {\n297-        try database.initialize()\n298-\n299-        let message = MailMessage(id: \"empty-test\", subject: \"Test message\")\n300-        try database.upsertMessage(message)\n301-\n--\n384-        )\n385-\n386-        let retrieved = try database.getMessage(id: \"html-only-test\")\n387-        XCTAssertNil(retrieved?.bodyText)\n388-        XCTAssertEqual(retrieved?.bodyHtml, \"<html><body>HTML content</body></html>\")\n389-    }\n390-\n391-    func testUpdateMessageBodyWithSpecialCharacters() throws {\n392-        try database.initialize()\n393-\n394:        let message = MailMessage(id: \"special-body-test\", subject: \"Special Body Test\")\n395-        try database.upsertMessage(message)\n396-\n397:        // Body with SQL-injection-like content and special characters\n398-        let bodyText = \"Test with 'quotes' and \\\"double quotes\\\" and emoji ðŸŽ‰ and O'Brien's code\"\n399-        let bodyHtml = \"<p>Test's \\\"content\\\" with <script>alert('xss')</script></p>\"\n400-\n401-        try database.updateMessageBody(\n402:            id: \"special-body-test\",\n403-            bodyText: bodyText,\n404-            bodyHtml: bodyHtml\n405-        )\n406-\n407:        let retrieved = try database.getMessage(id: \"special-body-test\")\n408-        XCTAssertEqual(retrieved?.bodyText, bodyText)\n409-        XCTAssertEqual(retrieved?.bodyHtml, bodyHtml)\n410-    }\n411-\n412-    func testUpdateMessageBodyOverwritesExistingBody() throws {\n413-        try database.initialize()\n414-\n415-        // Insert message with initial body\n416-        let message = MailMessage(\n417-            id: \"overwrite-body-test\",\n--\n875-        XCTAssertEqual(result.inserted, 0)\n876-        XCTAssertEqual(result.updated, 0)\n877-        XCTAssertEqual(result.failed, 0)\n878-        XCTAssertTrue(result.errors.isEmpty)\n879-    }\n880-\n881-    func testBatchUpsertMessagesWithSpecialCharacters() throws {\n882-        try database.initialize()\n883-\n884-        let messages = [\n885:            MailMessage(id: \"special-1\", subject: \"Test with 'single quotes'\"),\n886:            MailMessage(id: \"special-2\", subject: \"Test with \\\"double quotes\\\"\"),\n887:            MailMessage(id: \"special-3\", subject: \"Test with emoji ðŸŽ‰\"),\n888:            MailMessage(id: \"special-4\", subject: \"Test'; DROP TABLE messages; --\")\n889-        ]\n890-\n891-        let result = try database.batchUpsertMessages(messages)\n892-\n893-        XCTAssertEqual(result.inserted, 4)\n894-        XCTAssertEqual(result.failed, 0)\n895-\n896:        let retrieved1 = try database.getMessage(id: \"special-1\")\n897-        XCTAssertEqual(retrieved1?.subject, \"Test with 'single quotes'\")\n898-\n899:        let retrieved4 = try database.getMessage(id: \"special-4\")\n900-        XCTAssertEqual(retrieved4?.subject, \"Test'; DROP TABLE messages; --\")\n901-    }\n902-\n903-    func testBatchUpsertMessagesPerformance() throws {\n904-        try database.initialize()\n905-\n906-        // Create a large batch of messages\n907-        let messageCount = 1000\n908-        let messages = (1...messageCount).map { i in\n909-            MailMessage("}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"b77ca6ee-ede8-44c6-9d60-e6a18014af2c","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"129-        XCTAssertEqual(retrieved?.subject, \"Updated Subject\")\n130-        XCTAssertEqual(retrieved?.isRead, true)\n131-    }\n132-\n133-    / MARK: - Special Characters\n134-\n135-    func testMessageWithSpecialCharactersInSubject() throws {\n136-        try database.initialize()\n137-\n138-        let message = MailMessage(\n139:            id: \"special-chars\",\n140-            subject: \"Test with 'quotes' and \\\"double\\\" and emoji ðŸŽ‰\"\n141-        )\n142-\n143-        try database.upsertMessage(message)\n144-\n145:        let retrieved = try database.getMessage(id: \"special-chars\")\n146-        XCTAssertEqual(retrieved?.subject, \"Test with 'quotes' and \\\"double\\\" and emoji ðŸŽ‰\")\n147-    }\n148-\n149-    func testMessageWithSqlInjectionAttempt() throws {\n150-        try database.initialize()\n151-\n152-        let message = MailMessage(\n153-            id: \"sql-inject\",\n154-            subject: \"Test'; DROP TABLE messages; --\"\n155-        )\n--\n265-        // FTS5 operators (AND, OR, NOT, NEAR) should be treated as literal text\n266-        XCTAssertNoThrow(try database.searchMessages(query: \"AND\"))\n267-        XCTAssertNoThrow(try database.searchMessages(query: \"OR\"))\n268-        XCTAssertNoThrow(try database.searchMessages(query: \"NOT\"))\n269-        XCTAssertNoThrow(try database.searchMessages(query: \"NEAR\"))\n270-    }\n271-\n272-    func testSearchWithSpecialCharacters() throws {\n273-        try database.initialize()\n274-\n275:        let message = MailMessage(id: \"special-test\", subject: \"Special chars: * ( ) { } [ ]\")\n276-        try database.upsertMessage(message)\n277-\n278:        // Various special characters should not crash\n279:        let specialChars = [\"*\", \"(\", \")\", \"{\", \"}\", \"[\", \"]\", \"+\", \"-\", \"^\", \"~\"]\n280:        for char in specialChars {\n281-            XCTAssertNoThrow(try database.searchMessages(query: char), \"Search should not crash for character: \\(char)\")\n282-        }\n283-    }\n284-\n285-    func testSearchWithMixedSpecialCharacters() throws {\n286-        try database.initialize()\n287-\n288-        let message = MailMessage(id: \"mixed-test\", subject: \"Can't say \\\"hello (world)\\\"\")\n289-        try database.upsertMessage(message)\n290-\n291:        // Complex query with multiple special characters\n292-        let results = try database.searchMessages(query: \"Can't say \\\"hello\\\"\")\n293-        XCTAssertNotNil(results)\n294-    }\n295-\n296-    func testSearchWithEmptyQuery() throws {\n297-        try database.initialize()\n298-\n299-        let message = MailMessage(id: \"empty-test\", subject: \"Test message\")\n300-        try database.upsertMessage(message)\n301-\n--\n384-        )\n385-\n386-        let retrieved = try database.getMessage(id: \"html-only-test\")\n387-        XCTAssertNil(retrieved?.bodyText)\n388-        XCTAssertEqual(retrieved?.bodyHtml, \"<html><body>HTML content</body></html>\")\n389-    }\n390-\n391-    func testUpdateMessageBodyWithSpecialCharacters() throws {\n392-        try database.initialize()\n393-\n394:        let message = MailMessage(id: \"special-body-test\", subject: \"Special Body Test\")\n395-        try database.upsertMessage(message)\n396-\n397:        // Body with SQL-injection-like content and special characters\n398-        let bodyText = \"Test with 'quotes' and \\\"double quotes\\\" and emoji ðŸŽ‰ and O'Brien's code\"\n399-        let bodyHtml = \"<p>Test's \\\"content\\\" with <script>alert('xss')</script></p>\"\n400-\n401-        try database.updateMessageBody(\n402:            id: \"special-body-test\",\n403-            bodyText: bodyText,\n404-            bodyHtml: bodyHtml\n405-        )\n406-\n407:        let retrieved = try database.getMessage(id: \"special-body-test\")\n408-        XCTAssertEqual(retrieved?.bodyText, bodyText)\n409-        XCTAssertEqual(retrieved?.bodyHtml, bodyHtml)\n410-    }\n411-\n412-    func testUpdateMessageBodyOverwritesExistingBody() throws {\n413-        try database.initialize()\n414-\n415-        // Insert message with initial body\n416-        let message = MailMessage(\n417-            id: \"overwrite-body-test\",\n--\n875-        XCTAssertEqual(result.inserted, 0)\n876-        XCTAssertEqual(result.updated, 0)\n877-        XCTAssertEqual(result.failed, 0)\n878-        XCTAssertTrue(result.errors.isEmpty)\n879-    }\n880-\n881-    func testBatchUpsertMessagesWithSpecialCharacters() throws {\n882-        try database.initialize()\n883-\n884-        let messages = [\n885:            MailMessage(id: \"special-1\", subject: \"Test with 'single quotes'\"),\n886:            MailMessage(id: \"special-2\", subject: \"Test with \\\"double quotes\\\"\"),\n887:            MailMessage(id: \"special-3\", subject: \"Test with emoji ðŸŽ‰\"),\n888:            MailMessage(id: \"special-4\", subject: \"Test'; DROP TABLE messages; --\")\n889-        ]\n890-\n891-        let result = try database.batchUpsertMessages(messages)\n892-\n893-        XCTAssertEqual(result.inserted, 4)\n894-        XCTAssertEqual(result.failed, 0)\n895-\n896:        let retrieved1 = try database.getMessage(id: \"special-1\")\n897-        XCTAssertEqual(retrieved1?.subject, \"Test with 'single quotes'\")\n898-\n899:        let retrieved4 = try database.getMessage(id: \"special-4\")\n900-        XCTAssertEqual(retrieved4?.subject, \"Test'; DROP TABLE messages; --\")\n901-    }\n902-\n903-    func testBatchUpsertMessagesPerformance() throws {\n904-        try database.initialize()\n905-\n906-        // Create a large batch of messages\n907-        let messageCount = 1000\n908-        let messages = (1...messageCount).map { i in\n909-            MailMessage(","numLines":136}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GJHHzn77YhsMLtjTXXJsEB","type":"message","role":"assistant","content":[{"type":"text","text":"The tests cover special characters but not unknown filter names. Let me see the full list of special character tests to understand what's covered. Now let me also understand the actual issue - the `escapeFts5Query` wraps things in quotes. Let me check what happens with a query containing `badfilter:value`.\n\nLooking at the `escapeFts5Query` function:\n```swift\nlet escaped = trimmed.replacingOccurrences(of: \"\\\"\", with: \"\\\"\\\"\")\nreturn \"\\\"\\(escaped)\\\"\"\n```\n\nSo `badfilter:value` becomes `\"badfilter:value\"`. In FTS5, when a term is in double quotes, it should be treated as a literal phrase, not as a column prefix. However, I need to verify if this is actually working.\n\nLet me check if there's a test that specifically tries `badfilter:test` style queries:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2080,"cache_read_input_tokens":37573,"cache_creation":{"ephemeral_5m_input_tokens":2080,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"bdcb9c8d-d888-4fb8-b8d0-ed047c92fe26"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GJHHzn77YhsMLtjTXXJsEB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QJi9Abp3QSWgqqP6bch4kA","name":"Grep","input":{"pattern":"colon|:","path":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift","output_mode":"content","-n":true,"-C":3}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2080,"cache_read_input_tokens":37573,"cache_creation":{"ephemeral_5m_input_tokens":2080,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"c190388f-2609-40ab-a435-6a3e56554cbd"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QJi9Abp3QSWgqqP6bch4kA","type":"tool_result","content":"<persisted-output>\nOutput too large (80.7KB). Full output saved to: /Users/I852000/.claude/projects/-Users-I852000-Library-Mobile-Documents-com-apple-CloudDocs-swiftea/5a947bfe-0fe0-45e8-8f0b-a1aaf572731b/tool-results/toolu_01QJi9Abp3QSWgqqP6bch4kA.txt\n\nPreview (first 2KB):\n1-import XCTest\n2-@testable import SwiftEAKit\n3-\n4:final class MailDatabaseTests: XCTestCase {\n5:    var testDir: String!\n6:    var database: MailDatabase!\n7-\n8-    override func setUp() {\n9-        super.setUp()\n10-        testDir = NSTemporaryDirectory() + \"swiftea-maildb-test-\\(UUID().uuidString)\"\n11:        try? FileManager.default.createDirectory(atPath: testDir, withIntermediateDirectories: true)\n12-\n13-        let dbPath = (testDir as NSString).appendingPathComponent(\"mail.db\")\n14:        database = MailDatabase(databasePath: dbPath)\n15-    }\n16-\n17-    override func tearDown() {\n18-        database.close()\n19:        try? FileManager.default.removeItem(atPath: testDir)\n20-        database = nil\n21-        super.tearDown()\n22-    }\n23-\n24:    // MARK: - Initialization\n25-\n26-    func testInitializeCreatesDatabase() throws {\n27-        try database.initialize()\n28-\n29-        let dbPath = (testDir as NSString).appendingPathComponent(\"mail.db\")\n30:        XCTAssertTrue(FileManager.default.fileExists(atPath: dbPath))\n31-    }\n32-\n33-    func testInitializeTwiceSucceeds() throws {\n--\n35-        try database.initialize() // Should not throw\n36-    }\n37-\n38:    // MARK: - Message CRUD\n39-\n40-    func testUpsertAndGetMessage() throws {\n41-        try database.initialize()\n42-\n43-        let message = MailMessage(\n44:            id: \"test-id-123\",\n45:            appleRowId: 12345,\n46:            messageId: \"<test@example.com>\",\n47:            mailboxId: 1,\n48:            mailboxName: \"INBOX\",\n49:            accountId: \"account-1\",\n50:            subject: \"Test Subject\",\n51:            senderName: \"John Doe\",\n52:            senderEmail: \"john@example.com\",\n53:            dateSent: Date(timeIntervalSince1970: 1736177400),\n54:            dateReceived: Date(timeIntervalSince1970: 1736177500),\n55:            isRead: true,\n56:            isFlagged: false,\n57:            isDeleted: false,\n58:            hasAttachments: true,\n59:            emlxPath: \"/path/to/12345.emlx\",\n...\n</persisted-output>"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"6674f248-0341-4586-ae13-b6e9a518c293","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"1-import XCTest\n2-@testable import SwiftEAKit\n3-\n4:final class MailDatabaseTests: XCTestCase {\n5:    var testDir: String!\n6:    var database: MailDatabase!\n7-\n8-    override func setUp() {\n9-        super.setUp()\n10-        testDir = NSTemporaryDirectory() + \"swiftea-maildb-test-\\(UUID().uuidString)\"\n11:        try? FileManager.default.createDirectory(atPath: testDir, withIntermediateDirectories: true)\n12-\n13-        let dbPath = (testDir as NSString).appendingPathComponent(\"mail.db\")\n14:        database = MailDatabase(databasePath: dbPath)\n15-    }\n16-\n17-    override func tearDown() {\n18-        database.close()\n19:        try? FileManager.default.removeItem(atPath: testDir)\n20-        database = nil\n21-        super.tearDown()\n22-    }\n23-\n24:    // MARK: - Initialization\n25-\n26-    func testInitializeCreatesDatabase() throws {\n27-        try database.initialize()\n28-\n29-        let dbPath = (testDir as NSString).appendingPathComponent(\"mail.db\")\n30:        XCTAssertTrue(FileManager.default.fileExists(atPath: dbPath))\n31-    }\n32-\n33-    func testInitializeTwiceSucceeds() throws {\n--\n35-        try database.initialize() // Should not throw\n36-    }\n37-\n38:    // MARK: - Message CRUD\n39-\n40-    func testUpsertAndGetMessage() throws {\n41-        try database.initialize()\n42-\n43-        let message = MailMessage(\n44:            id: \"test-id-123\",\n45:            appleRowId: 12345,\n46:            messageId: \"<test@example.com>\",\n47:            mailboxId: 1,\n48:            mailboxName: \"INBOX\",\n49:            accountId: \"account-1\",\n50:            subject: \"Test Subject\",\n51:            senderName: \"John Doe\",\n52:            senderEmail: \"john@example.com\",\n53:            dateSent: Date(timeIntervalSince1970: 1736177400),\n54:            dateReceived: Date(timeIntervalSince1970: 1736177500),\n55:            isRead: true,\n56:            isFlagged: false,\n57:            isDeleted: false,\n58:            hasAttachments: true,\n59:            emlxPath: \"/path/to/12345.emlx\",\n60:            bodyText: \"This is the body text.\",\n61:            bodyHtml: nil\n62-        )\n63-\n64-        try database.upsertMessage(message)\n65-\n66:        let retrieved = try database.getMessage(id: \"test-id-123\")\n67-\n68-        XCTAssertNotNil(retrieved)\n69-        XCTAssertEqual(retrieved?.id, \"test-id-123\")\n--\n84-        try database.initialize()\n85-\n86-        let message = MailMessage(\n87:            id: \"row-test-id\",\n88:            appleRowId: 99999,\n89:            subject: \"Row Test\"\n90-        )\n91-\n92-        try database.upsertMessage(message)\n93-\n94:        let retrieved = try database.getMessage(appleRowId: 99999)\n95-\n96-        XCTAssertNotNil(retrieved)\n97-        XCTAssertEqual(retrieved?.id, \"row-test-id\")\n--\n101-    func testGetNonexistentMessageReturnsNil() throws {\n102-        try database.initialize()\n103-\n104:        let retrieved = try database.getMessage(id: \"nonexistent-id\")\n105-        XCTAssertNil(retrieved)\n106-    }\n107-\n--\n110-\n111-        // Insert initial message\n112-        let message1 = MailMessage(\n113:            id: \"update-test\",\n114:            subject: \"Original Subject\",\n115:            isRead: false\n116-        )\n117-        try database.upsertMessage(message1)\n118-\n119-        // Update the message\n120-        let message2 = MailMessage(\n121:            id: \"update-test\",\n122:            subject: \"Updated Subject\",\n123:            isRead: true\n124-        )\n125-        try database.upsertMessage(message2)\n126-\n127:        let retrieved = try database.getMessage(id: \"update-test\")\n128-\n129-        XCTAssertEqual(retrieved?.subject, \"Updated Subject\")\n130-        XCTAssertEqual(retrieved?.isRead, true)\n131-    }\n132-\n133:    // MARK: - Special Characters\n134-\n135-    func testMessageWithSpecialCharactersInSubject() throws {\n136-        try database.initialize()\n137-\n138-        let message = MailMessage(\n139:            id: \"special-chars\",\n140:            subject: \"Test with 'quotes' and \\\"double\\\" and emoji ðŸŽ‰\"\n141-        )\n142-\n143-        try database.upsertMessage(message)\n144-\n145:        let retrieved = try database.getMessage(id: \"special-chars\")\n146-        XCTAssertEqual(retrieved?.subject, \"Test with 'quotes' and \\\"double\\\" and emoji ðŸŽ‰\")\n147-    }\n148-\n--\n150-        try database.initialize()\n151-\n152-        let message = MailMessage(\n153:            id: \"sql-inject\",\n154:            subject: \"Test'; DROP TABLE messages; --\"\n155-        )\n156-\n157-        try database.upsertMessage(message)\n158-\n159:        let retrieved = try database.getMessage(id: \"sql-inject\")\n160-        XCTAssertNotNil(retrieved)\n161-        XCTAssertEqual(retrieved?.subject, \"Test'; DROP TABLE messages; --\")\n162-\n163-        // Verify table still exists by inserting another message\n164:        let message2 = MailMessage(id: \"after-inject\", subject: \"After\")\n165-        try database.upsertMessage(message2)\n166:        let retrieved2 = try database.getMessage(id: \"after-inject\")\n167-        XCTAssertNotNil(retrieved2)\n168-    }\n169-\n170:    // MARK: - FTS Search\n171-\n172-    func testSearchMessages() throws {\n173-        try database.initialize()\n174-\n175-        // Insert multiple messages\n176-        let messages = [\n177:            MailMessage(id: \"search-1\", subject: \"Meeting about project Alpha\", senderEmail: \"alice@example.com\", bodyText: \"Let's discuss the alpha project timeline.\"),\n178:            MailMessage(id: \"search-2\", subject: \"Quarterly report\", senderEmail: \"bob@example.com\", bodyText: \"Q4 financial results attached.\"),\n179:            MailMessage(id: \"search-3\", subject: \"Re: Project Alpha update\", senderEmail: \"charlie@example.com\", bodyText: \"Great progress on alpha milestone.\")\n180-        ]\n181-\n182-        for msg in messages {\n--\n184-        }\n185-\n186-        // Search for \"alpha\"\n187:        let results = try database.searchMessages(query: \"alpha\")\n188-\n189-        XCTAssertEqual(results.count, 2)\n190-        XCTAssertTrue(results.contains { $0.id == \"search-1\" })\n--\n194-    func testSearchWithNoResults() throws {\n195-        try database.initialize()\n196-\n197:        let message = MailMessage(id: \"no-match\", subject: \"Hello world\")\n198-        try database.upsertMessage(message)\n199-\n200:        let results = try database.searchMessages(query: \"nonexistent\")\n201-\n202-        XCTAssertTrue(results.isEmpty)\n203-    }\n--\n207-\n208-        // Insert many messages\n209-        for i in 1...10 {\n210:            let msg = MailMessage(id: \"limit-\\(i)\", subject: \"Test subject \\(i)\", bodyText: \"Common keyword\")\n211-            try database.upsertMessage(msg)\n212-        }\n213-\n214:        let results = try database.searchMessages(query: \"keyword\", limit: 5)\n215-\n216-        XCTAssertEqual(results.count, 5)\n217-    }\n218-\n219:    // MARK: - FTS5 Special Character Handling\n220-\n221-    func testSearchWithSingleQuote() throws {\n222-        try database.initialize()\n223-\n224-        // Insert message containing a single quote\n225:        let message = MailMessage(id: \"quote-test\", subject: \"It's a test\", bodyText: \"Don't forget to check this.\")\n226-        try database.upsertMessage(message)\n227-\n228-        // Search for single quote - should not crash, should return empty or matching results\n229:        let results = try database.searchMessages(query: \"'\")\n230-        // The query should execute without throwing\n231-        XCTAssertNotNil(results)\n232-    }\n--\n235-        try database.initialize()\n236-\n237-        // Insert message containing double quotes\n238:        let message = MailMessage(id: \"dquote-test\", subject: \"He said \\\"hello\\\"\", bodyText: \"Test with quotes\")\n239-        try database.upsertMessage(message)\n240-\n241-        // Search for double quote - should not crash\n242:        let results = try database.searchMessages(query: \"\\\"\")\n243-        XCTAssertNotNil(results)\n244-    }\n245-\n246-    func testSearchWithSqlInjectionAttempt() throws {\n247-        try database.initialize()\n248-\n249:        let message = MailMessage(id: \"sql-test\", subject: \"Normal email\")\n250-        try database.upsertMessage(message)\n251-\n252-        // SQL injection-like syntax should not crash or cause errors\n253:        let results = try database.searchMessages(query: \"OR 1=1 --\")\n254-        XCTAssertNotNil(results)\n255-        // Should return empty since this is treated as literal text, not SQL\n256-        XCTAssertTrue(results.isEmpty)\n--\n259-    func testSearchWithFts5Operators() throws {\n260-        try database.initialize()\n261-\n262:        let message = MailMessage(id: \"fts-test\", subject: \"Test AND or OR words\", bodyText: \"NOT near NEAR\")\n263-        try database.upsertMessage(message)\n264-\n265-        // FTS5 operators (AND, OR, NOT, NEAR) should be treated as literal text\n266:        XCTAssertNoThrow(try database.searchMessages(query: \"AND\"))\n267:        XCTAssertNoThrow(try database.searchMessages(query: \"OR\"))\n268:        XCTAssertNoThrow(try database.searchMessages(query: \"NOT\"))\n269:        XCTAssertNoThrow(try database.searchMessages(query: \"NEAR\"))\n270-    }\n271-\n272-    func testSearchWithSpecialCharacters() throws {\n273-        try database.initialize()\n274-\n275:        let message = MailMessage(id: \"special-test\", subject: \"Special chars: * ( ) { } [ ]\")\n276-        try database.upsertMessage(message)\n277-\n278-        // Various special characters should not crash\n279-        let specialChars = [\"*\", \"(\", \")\", \"{\", \"}\", \"[\", \"]\", \"+\", \"-\", \"^\", \"~\"]\n280-        for char in specialChars {\n281:            XCTAssertNoThrow(try database.searchMessages(query: char), \"Search should not crash for character: \\(char)\")\n282-        }\n283-    }\n284-\n285-    func testSearchWithMixedSpecialCharacters() throws {\n286-        try database.initialize()\n287-\n288:        let message = MailMessage(id: \"mixed-test\", subject: \"Can't say \\\"hello (world)\\\"\")\n289-        try database.upsertMessage(message)\n290-\n291-        // Complex query with multiple special characters\n292:        let results = try database.searchMessages(query: \"Can't say \\\"hello\\\"\")\n293-        XCTAssertNotNil(results)\n294-    }\n295-\n296-    func testSearchWithEmptyQuery() throws {\n297-        try database.initialize()\n298-\n299:        let message = MailMessage(id: \"empty-test\", subject: \"Test message\")\n300-        try database.upsertMessage(message)\n301-\n302-        // Empty query should not crash\n303:        let results = try database.searchMessages(query: \"\")\n304-        XCTAssertNotNil(results)\n305-\n306-        // Whitespace-only query should not crash\n307:        let results2 = try database.searchMessages(query: \"   \")\n308-        XCTAssertNotNil(results2)\n309-    }\n310-\n311:    // MARK: - Export Path\n312-\n313-    func testUpdateExportPath() throws {\n314-        try database.initialize()\n315-\n316:        let message = MailMessage(id: \"export-test\", subject: \"Export Test\")\n317-        try database.upsertMessage(message)\n318-\n319:        try database.updateExportPath(id: \"export-test\", path: \"/exports/email.md\")\n320-\n321:        let retrieved = try database.getMessage(id: \"export-test\")\n322-        XCTAssertEqual(retrieved?.exportPath, \"/exports/email.md\")\n323-    }\n324-\n325:    // MARK: - Update Message Body (On-Demand Fetching)\n326-\n327-    func testUpdateMessageBodyWithBothTextAndHtml() throws {\n328-        try database.initialize()\n329-\n330-        // Insert message without body\n331-        let message = MailMessage(\n332:            id: \"body-update-test\",\n333:            subject: \"Body Update Test\",\n334:            bodyText: nil,\n335:            bodyHtml: nil\n336-        )\n337-        try database.upsertMessage(message)\n338-\n339-        // Verify body is initially nil\n340:        let initialRetrieved = try database.getMessage(id: \"body-update-test\")\n341-        XCTAssertNil(initialRetrieved?.bodyText)\n342-        XCTAssertNil(initialRetrieved?.bodyHtml)\n343-\n344-        // Update body\n345-        try database.updateMessageBody(\n346:            id: \"body-update-test\",\n347:            bodyText: \"Plain text body\",\n348:            bodyHtml: \"<p>HTML body</p>\"\n349-        )\n350-\n351-        // Verify body was updated\n352:        let retrieved = try database.getMessage(id: \"body-update-test\")\n353-        XCTAssertEqual(retrieved?.bodyText, \"Plain text body\")\n354-        XCTAssertEqual(retrieved?.bodyHtml, \"<p>HTML body</p>\")\n355-    }\n--\n357-    func testUpdateMessageBodyTextOnly() throws {\n358-        try database.initialize()\n359-\n360:        let message = MailMessage(id: \"text-only-test\", subject: \"Text Only Test\")\n361-        try database.upsertMessage(message)\n362-\n363-        try database.updateMessageBody(\n364:            id: \"text-only-test\",\n365:            bodyText: \"Only plain text\",\n366:            bodyHtml: nil\n367-        )\n368-\n369:        let retrieved = try database.getMessage(id: \"text-only-test\")\n370-        XCTAssertEqual(retrieved?.bodyText, \"Only plain text\")\n371-        XCTAssertNil(retrieved?.bodyHtml)\n372-    }\n--\n374-    func testUpdateMessageBodyHtmlOnly() throws {\n375-        try database.initialize()\n376-\n377:        let message = MailMessage(id: \"html-only-test\", subject: \"HTML Only Test\")\n378-        try database.upsertMessage(message)\n379-\n380-        try database.updateMessageBody(\n381:            id: \"html-only-test\",\n382:            bodyText: nil,\n383:            bodyHtml: \"<html><body>HTML content</body></html>\"\n384-        )\n385-\n386:        let retrieved = try database.getMessage(id: \"html-only-test\")\n387-        XCTAssertNil(retrieved?.bodyText)\n388-        XCTAssertEqual(retrieved?.bodyHtml, \"<html><body>HTML content</body></html>\")\n389-    }\n--\n391-    func testUpdateMessageBodyWithSpecialCharacters() throws {\n392-        try database.initialize()\n393-\n394:        let message = MailMessage(id: \"special-body-test\", subject: \"Special Body Test\")\n395-        try database.upsertMessage(message)\n396-\n397-        // Body with SQL-injection-like content and special characters\n--\n399-        let bodyHtml = \"<p>Test's \\\"content\\\" with <script>alert('xss')</script></p>\"\n400-\n401-        try database.updateMessageBody(\n402:            id: \"special-body-test\",\n403:            bodyText: bodyText,\n404:            bodyHtml: bodyHtml\n405-        )\n406-\n407:        let retrieved = try database.getMessage(id: \"special-body-test\")\n408-        XCTAssertEqual(retrieved?.bodyText, bodyText)\n409-        XCTAssertEqual(retrieved?.bodyHtml, bodyHtml)\n410-    }\n--\n414-\n415-        // Insert message with initial body\n416-        let message = MailMessage(\n417:            id: \"overwrite-body-test\",\n418:            subject: \"Overwrite Body Test\",\n419:            bodyText: \"Original text\",\n420:            bodyHtml: \"<p>Original HTML</p>\"\n421-        )\n422-        try database.upsertMessage(message)\n423-\n424-        // Update body\n425-        try database.updateMessageBody(\n426:            id: \"overwrite-body-test\",\n427:            bodyText: \"New text\",\n428:            bodyHtml: \"<p>New HTML</p>\"\n429-        )\n430-\n431:        let retrieved = try database.getMessage(id: \"overwrite-body-test\")\n432-        XCTAssertEqual(retrieved?.bodyText, \"New text\")\n433-        XCTAssertEqual(retrieved?.bodyHtml, \"<p>New HTML</p>\")\n434-    }\n435-\n436-    func testUpdateMessageBodyBeforeInitializeThrows() throws {\n437-        // Don't call initialize()\n438:        XCTAssertThrowsError(try database.updateMessageBody(id: \"test\", bodyText: \"text\", bodyHtml: nil)) { error in\n439-            guard case MailDatabaseError.notInitialized = error else {\n440-                XCTFail(\"Expected MailDatabaseError.notInitialized, got \\(error)\")\n441-                return\n--\n443-        }\n444-    }\n445-\n446:    // MARK: - Sync Status\n447-\n448-    func testSetAndGetSyncStatus() throws {\n449-        try database.initialize()\n450-\n451:        try database.setSyncStatus(key: \"test_key\", value: \"test_value\")\n452-\n453:        let value = try database.getSyncStatus(key: \"test_key\")\n454-        XCTAssertEqual(value, \"test_value\")\n455-    }\n456-\n457-    func testGetNonexistentSyncStatus() throws {\n458-        try database.initialize()\n459-\n460:        let value = try database.getSyncStatus(key: \"nonexistent_key\")\n461-        XCTAssertNil(value)\n462-    }\n463-\n464-    func testUpdateSyncStatus() throws {\n465-        try database.initialize()\n466-\n467:        try database.setSyncStatus(key: \"update_key\", value: \"original\")\n468:        try database.setSyncStatus(key: \"update_key\", value: \"updated\")\n469-\n470:        let value = try database.getSyncStatus(key: \"update_key\")\n471-        XCTAssertEqual(value, \"updated\")\n472-    }\n473-\n474-    func testSetAndGetLastSyncTime() throws {\n475-        try database.initialize()\n476-\n477:        let syncTime = Date(timeIntervalSince1970: 1736177400)\n478-        try database.setLastSyncTime(syncTime)\n479-\n480-        let retrieved = try database.getLastSyncTime()\n481-        XCTAssertNotNil(retrieved)\n482:        XCTAssertEqual(retrieved!.timeIntervalSince1970, 1736177400, accuracy: 1.0)\n483-    }\n484-\n485-    func testGetLastSyncTimeWhenNotSet() throws {\n--\n489-        XCTAssertNil(retrieved)\n490-    }\n491-\n492:    // MARK: - Sync Status Tracking\n493-\n494-    func testRecordSyncStart() throws {\n495-        try database.initialize()\n496-\n497:        try database.recordSyncStart(isIncremental: true)\n498-\n499-        let summary = try database.getSyncStatusSummary()\n500-        XCTAssertEqual(summary.state, .running)\n--\n506-    func testRecordSyncSuccess() throws {\n507-        try database.initialize()\n508-\n509:        try database.recordSyncStart(isIncremental: false)\n510-\n511-        let result = SyncResult(\n512:            messagesProcessed: 100,\n513:            messagesAdded: 50,\n514:            messagesUpdated: 30,\n515:            messagesDeleted: 5,\n516:            messagesUnchanged: 15,\n517:            mailboxesProcessed: 10,\n518:            errors: [],\n519:            duration: 5.5,\n520:            isIncremental: false\n521-        )\n522-\n523:        try database.recordSyncSuccess(result: result)\n524-\n525-        let summary = try database.getSyncStatusSummary()\n526-        XCTAssertEqual(summary.state, .success)\n--\n530-        XCTAssertEqual(summary.messagesUpdated, 30)\n531-        XCTAssertEqual(summary.messagesDeleted, 5)\n532-        XCTAssertNotNil(summary.duration)\n533:        XCTAssertEqual(summary.duration!, 5.5, accuracy: 0.01)\n534-        XCTAssertNil(summary.lastSyncError)\n535-    }\n536-\n537-    func testRecordSyncFailure() throws {\n538-        try database.initialize()\n539-\n540:        try database.recordSyncStart(isIncremental: true)\n541-\n542:        let error = NSError(domain: \"MailSync\", code: 1, userInfo: [\n543:            NSLocalizedDescriptionKey: \"Test sync failure\"\n544-        ])\n545:        try database.recordSyncFailure(error: error)\n546-\n547-        let summary = try database.getSyncStatusSummary()\n548-        XCTAssertEqual(summary.state, .failed)\n--\n569-        try database.initialize()\n570-\n571-        // First, record a failure\n572:        try database.recordSyncStart(isIncremental: true)\n573:        let error = NSError(domain: \"MailSync\", code: 1, userInfo: [\n574:            NSLocalizedDescriptionKey: \"Previous failure\"\n575-        ])\n576:        try database.recordSyncFailure(error: error)\n577-\n578-        // Then record success\n579:        try database.recordSyncStart(isIncremental: false)\n580-        let result = SyncResult(\n581:            messagesProcessed: 10,\n582:            messagesAdded: 10,\n583:            messagesUpdated: 0,\n584:            mailboxesProcessed: 1,\n585:            errors: [],\n586:            duration: 1.0\n587-        )\n588:        try database.recordSyncSuccess(result: result)\n589-\n590-        let summary = try database.getSyncStatusSummary()\n591-        XCTAssertEqual(summary.state, .success)\n592-        XCTAssertNil(summary.lastSyncError)\n593-    }\n594-\n595:    // MARK: - Mailbox Operations\n596-\n597-    func testUpsertAndGetMailboxes() throws {\n598-        try database.initialize()\n599-\n600-        let mailboxes = [\n601:            Mailbox(id: 1, accountId: \"account-1\", name: \"INBOX\", fullPath: \"INBOX\", messageCount: 100, unreadCount: 10),\n602:            Mailbox(id: 2, accountId: \"account-1\", name: \"Sent\", fullPath: \"Sent\", messageCount: 50, unreadCount: 0),\n603:            Mailbox(id: 3, accountId: \"account-1\", name: \"Archive\", fullPath: \"Archive\", parentId: nil, messageCount: 200, unreadCount: 0)\n604-        ]\n605-\n606-        for mailbox in mailboxes {\n--\n617-    func testUpdateMailbox() throws {\n618-        try database.initialize()\n619-\n620:        let mailbox1 = Mailbox(id: 1, accountId: \"account-1\", name: \"INBOX\", fullPath: \"INBOX\", messageCount: 100, unreadCount: 10)\n621-        try database.upsertMailbox(mailbox1)\n622-\n623:        let mailbox2 = Mailbox(id: 1, accountId: \"account-1\", name: \"INBOX\", fullPath: \"INBOX\", messageCount: 150, unreadCount: 5)\n624-        try database.upsertMailbox(mailbox2)\n625-\n626-        let retrieved = try database.getMailboxes()\n--\n630-        XCTAssertEqual(retrieved.first?.unreadCount, 5)\n631-    }\n632-\n633:    // MARK: - Error Handling\n634-\n635-    func testOperationsBeforeInitializeThrow() throws {\n636-        // Don't call initialize()\n637-\n638:        XCTAssertThrowsError(try database.getMessage(id: \"test\")) { error in\n639-            guard case MailDatabaseError.notInitialized = error else {\n640-                XCTFail(\"Expected MailDatabaseError.notInitialized, got \\(error)\")\n641-                return\n--\n643-        }\n644-    }\n645-\n646:    // MARK: - Data Model Tests\n647-\n648-    func testMailMessageInitialization() {\n649-        let message = MailMessage(\n650:            id: \"msg-1\",\n651:            appleRowId: 123,\n652:            messageId: \"<msg@test.com>\",\n653:            mailboxId: 1,\n654:            mailboxName: \"INBOX\",\n655:            accountId: \"acc-1\",\n656:            subject: \"Test\",\n657:            senderName: \"Sender\",\n658:            senderEmail: \"sender@test.com\",\n659:            dateSent: Date(),\n660:            dateReceived: Date(),\n661:            isRead: true,\n662:            isFlagged: true,\n663:            isDeleted: false,\n664:            hasAttachments: true,\n665:            emlxPath: \"/path/to.emlx\",\n666:            bodyText: \"Body\",\n667:            bodyHtml: \"<p>Body</p>\",\n668:            exportPath: \"/export/path\"\n669-        )\n670-\n671-        XCTAssertEqual(message.id, \"msg-1\")\n--\n677-    }\n678-\n679-    func testMailMessageDefaults() {\n680:        let message = MailMessage(id: \"minimal\", subject: \"Minimal\")\n681-\n682-        XCTAssertNil(message.appleRowId)\n683-        XCTAssertNil(message.messageId)\n--\n689-\n690-    func testMailboxInitialization() {\n691-        let mailbox = Mailbox(\n692:            id: 1,\n693:            accountId: \"acc-1\",\n694:            name: \"INBOX\",\n695:            fullPath: \"INBOX\",\n696:            parentId: nil,\n697:            messageCount: 100,\n698:            unreadCount: 10\n699-        )\n700-\n701-        XCTAssertEqual(mailbox.id, 1)\n--\n707-\n708-    func testMailAttachmentInitialization() {\n709-        let attachment = MailAttachment(\n710:            id: 1,\n711:            messageId: \"msg-1\",\n712:            filename: \"doc.pdf\",\n713:            mimeType: \"application/pdf\",\n714:            size: 1024,\n715:            contentId: \"cid123\",\n716:            isInline: false\n717-        )\n718-\n719-        XCTAssertEqual(attachment.id, 1)\n--\n724-        XCTAssertFalse(attachment.isInline)\n725-    }\n726-\n727:    // MARK: - Error Description Tests\n728-\n729-    func testMailDatabaseErrorDescriptions() {\n730:        let errors: [MailDatabaseError] = [\n731:            .connectionFailed(underlying: NSError(domain: \"test\", code: 1)),\n732:            .migrationFailed(underlying: NSError(domain: \"test\", code: 2)),\n733:            .queryFailed(underlying: NSError(domain: \"test\", code: 3)),\n734-            .notInitialized\n735-        ]\n736-\n--\n740-        }\n741-    }\n742-\n743:    // MARK: - Close and Reopen\n744-\n745-    func testCloseAndReopenDatabase() throws {\n746-        try database.initialize()\n747-\n748:        let message = MailMessage(id: \"persist-test\", subject: \"Persist\")\n749-        try database.upsertMessage(message)\n750-\n751-        database.close()\n752-\n753-        // Create new database instance\n754-        let dbPath = (testDir as NSString).appendingPathComponent(\"mail.db\")\n755:        let newDatabase = MailDatabase(databasePath: dbPath)\n756-        try newDatabase.initialize()\n757-\n758:        let retrieved = try newDatabase.getMessage(id: \"persist-test\")\n759-        XCTAssertNotNil(retrieved)\n760-        XCTAssertEqual(retrieved?.subject, \"Persist\")\n761-\n762-        newDatabase.close()\n763-    }\n764-\n765:    // MARK: - Batch Insert Tests\n766-\n767-    func testBatchUpsertMessagesInsertsAll() throws {\n768-        try database.initialize()\n769-\n770-        let messages = (1...100).map { i in\n771-            MailMessage(\n772:                id: \"batch-\\(i)\",\n773:                appleRowId: i,\n774:                subject: \"Batch Test \\(i)\",\n775:                senderEmail: \"sender\\(i)@example.com\",\n776:                isRead: i % 2 == 0,\n777:                isFlagged: i % 3 == 0\n778-            )\n779-        }\n780-\n--\n787-        XCTAssertGreaterThan(result.duration, 0)\n788-\n789-        // Verify messages were inserted\n790:        let retrieved1 = try database.getMessage(id: \"batch-1\")\n791-        XCTAssertNotNil(retrieved1)\n792-        XCTAssertEqual(retrieved1?.subject, \"Batch Test 1\")\n793-\n794:        let retrieved50 = try database.getMessage(id: \"batch-50\")\n795-        XCTAssertNotNil(retrieved50)\n796-        XCTAssertEqual(retrieved50?.subject, \"Batch Test 50\")\n797-\n798:        let retrieved100 = try database.getMessage(id: \"batch-100\")\n799-        XCTAssertNotNil(retrieved100)\n800-        XCTAssertEqual(retrieved100?.subject, \"Batch Test 100\")\n801-    }\n--\n805-\n806-        // Insert initial messages\n807-        let initialMessages = (1...50).map { i in\n808:            MailMessage(id: \"batch-\\(i)\", subject: \"Initial \\(i)\")\n809-        }\n810-        _ = try database.batchUpsertMessages(initialMessages)\n811-\n812-        // Update with new messages (some new, some updates)\n813-        let updateMessages = (25...75).map { i in\n814:            MailMessage(id: \"batch-\\(i)\", subject: \"Updated \\(i)\")\n815-        }\n816-\n817-        let result = try database.batchUpsertMessages(updateMessages)\n--\n822-        XCTAssertEqual(result.failed, 0)\n823-\n824-        // Verify updates\n825:        let retrieved25 = try database.getMessage(id: \"batch-25\")\n826-        XCTAssertEqual(retrieved25?.subject, \"Updated 25\")\n827-\n828:        let retrieved50 = try database.getMessage(id: \"batch-50\")\n829-        XCTAssertEqual(retrieved50?.subject, \"Updated 50\")\n830-\n831-        // Verify original unchanged\n832:        let retrieved1 = try database.getMessage(id: \"batch-1\")\n833-        XCTAssertEqual(retrieved1?.subject, \"Initial 1\")\n834-    }\n835-\n--\n837-        try database.initialize()\n838-\n839-        let messages = (1...500).map { i in\n840:            MailMessage(id: \"custom-batch-\\(i)\", subject: \"Custom Batch \\(i)\")\n841-        }\n842-\n843-        // Use small batch size\n844:        let config = MailDatabase.BatchInsertConfig(batchSize: 50)\n845:        let result = try database.batchUpsertMessages(messages, config: config)\n846-\n847-        XCTAssertEqual(result.inserted, 500)\n848-        XCTAssertEqual(result.updated, 0)\n849-        XCTAssertEqual(result.failed, 0)\n850-\n851-        // Verify all were inserted\n852:        let retrieved = try database.getMessage(id: \"custom-batch-250\")\n853-        XCTAssertNotNil(retrieved)\n854-        XCTAssertEqual(retrieved?.subject, \"Custom Batch 250\")\n855-    }\n--\n860-    }\n861-\n862-    func testBatchUpsertMessagesConfigMinimumBatchSize() {\n863:        let config = MailDatabase.BatchInsertConfig(batchSize: 0)\n864-        XCTAssertEqual(config.batchSize, 1)\n865-\n866:        let negativeConfig = MailDatabase.BatchInsertConfig(batchSize: -10)\n867-        XCTAssertEqual(negativeConfig.batchSize, 1)\n868-    }\n869-\n--\n882-        try database.initialize()\n883-\n884-        let messages = [\n885:            MailMessage(id: \"special-1\", subject: \"Test with 'single quotes'\"),\n886:            MailMessage(id: \"special-2\", subject: \"Test with \\\"double quotes\\\"\"),\n887:            MailMessage(id: \"special-3\", subject: \"Test with emoji ðŸŽ‰\"),\n888:            MailMessage(id: \"special-4\", subject: \"Test'; DROP TABLE messages; --\")\n889-        ]\n890-\n891-        let result = try database.batchUpsertMessages(messages)\n--\n893-        XCTAssertEqual(result.inserted, 4)\n894-        XCTAssertEqual(result.failed, 0)\n895-\n896:        let retrieved1 = try database.getMessage(id: \"special-1\")\n897-        XCTAssertEqual(retrieved1?.subject, \"Test with 'single quotes'\")\n898-\n899:        let retrieved4 = try database.getMessage(id: \"special-4\")\n900-        XCTAssertEqual(retrieved4?.subject, \"Test'; DROP TABLE messages; --\")\n901-    }\n902-\n--\n907-        let messageCount = 1000\n908-        let messages = (1...messageCount).map { i in\n909-            MailMessage(\n910:                id: \"perf-\\(i)\",\n911:                appleRowId: i,\n912:                messageId: \"<perf\\(i)@test.com>\",\n913:                mailboxId: 1,\n914:                mailboxName: \"INBOX\",\n915:                accountId: \"acc-1\",\n916:                subject: \"Performance Test \\(i)\",\n917:                senderName: \"Sender \\(i)\",\n918:                senderEmail: \"sender\\(i)@test.com\",\n919:                dateSent: Date(),\n920:                dateReceived: Date(),\n921:                isRead: i % 2 == 0,\n922:                isFlagged: i % 5 == 0,\n923:                bodyText: \"This is the body text for message \\(i)\"\n924-            )\n925-        }\n926-\n--\n937-\n938-        // Log performance for reference\n939-        print(\"Batch insert of \\(messageCount) messages took \\(batchDuration) seconds\")\n940:        print(\"Rate: \\(Double(messageCount) / batchDuration) messages/second\")\n941-    }\n942-\n943-    func testBatchUpsertMailboxes() throws {\n944-        try database.initialize()\n945-\n946-        let mailboxes = [\n947:            Mailbox(id: 1, accountId: \"acc-1\", name: \"INBOX\", fullPath: \"INBOX\", messageCount: 100, unreadCount: 10),\n948:            Mailbox(id: 2, accountId: \"acc-1\", name: \"Sent\", fullPath: \"Sent\", messageCount: 50, unreadCount: 0),\n949:            Mailbox(id: 3, accountId: \"acc-1\", name: \"Archive\", fullPath: \"Archive\", messageCount: 200, unreadCount: 0)\n950-        ]\n951-\n952-        try database.batchUpsertMailboxes(mailboxes)\n--\n963-\n964-        // Insert initial mailboxes\n965-        let initial = [\n966:            Mailbox(id: 1, accountId: \"acc-1\", name: \"INBOX\", fullPath: \"INBOX\", messageCount: 100, unreadCount: 10)\n967-        ]\n968-        try database.batchUpsertMailboxes(initial)\n969-\n970-        // Update mailbox\n971-        let updated = [\n972:            Mailbox(id: 1, accountId: \"acc-1\", name: \"INBOX\", fullPath: \"INBOX\", messageCount: 150, unreadCount: 5)\n973-        ]\n974-        try database.batchUpsertMailboxes(updated)\n975-\n--\n981-\n982-    func testBatchInsertResultInitialization() {\n983-        let result = MailDatabase.BatchInsertResult(\n984:            inserted: 10,\n985:            updated: 5,\n986:            failed: 2,\n987:            errors: [\"Error 1\", \"Error 2\"],\n988:            duration: 1.5\n989-        )\n990-\n991-        XCTAssertEqual(result.inserted, 10)\n--\n995-        XCTAssertEqual(result.duration, 1.5)\n996-    }\n997-\n998:    // MARK: - Migration V2 Tests (Mailbox Status Tracking)\n999-\n1000-    func testMigrationV2CreatesMailboxStatusColumn() throws {\n1001-        try database.initialize()\n1002-\n1003-        // Insert a message with default mailbox status\n1004:        let message = MailMessage(id: \"v2-test-1\", subject: \"V2 Test\")\n1005-        try database.upsertMessage(message)\n1006-\n1007-        // Retrieve and verify default mailbox_status is 'inbox'\n1008:        let retrieved = try database.getMessage(id: \"v2-test-1\")\n1009-        XCTAssertNotNil(retrieved)\n1010-        XCTAssertEqual(retrieved?.mailboxStatus, .inbox)\n1011-    }\n--\n1014-        try database.initialize()\n1015-\n1016-        // Insert a message without pending sync action\n1017:        let message1 = MailMessage(id: \"v2-sync-1\", subject: \"No Action\")\n1018-        try database.upsertMessage(message1)\n1019-\n1020:        let retrieved1 = try database.getMessage(id: \"v2-sync-1\")\n1021-        XCTAssertNil(retrieved1?.pendingSyncAction)\n1022-\n1023-        // Insert a message with pending archive action\n1024-        let message2 = MailMessage(\n1025:            id: \"v2-sync-2\",\n1026:            subject: \"With Archive Action\",\n1027:            pendingSyncAction: .archive\n1028-        )\n1029-        try database.upsertMessage(message2)\n1030-\n1031:        let retrieved2 = try database.getMessage(id: \"v2-sync-2\")\n1032-        XCTAssertEqual(retrieved2?.pendingSyncAction, .archive)\n1033-\n1034-        // Insert a message with pending delete action\n1035-        let message3 = MailMessage(\n1036:            id: \"v2-sync-3\",\n1037:            subject: \"With Delete Action\",\n1038:            pendingSyncAction: .delete\n1039-        )\n1040-        try database.upsertMessage(message3)\n1041-\n1042:        let retrieved3 = try database.getMessage(id: \"v2-sync-3\")\n1043-        XCTAssertEqual(retrieved3?.pendingSyncAction, .delete)\n1044-    }\n1045-\n--\n1047-        try database.initialize()\n1048-\n1049-        // Insert a message without last known mailbox id\n1050:        let message1 = MailMessage(id: \"v2-mailbox-1\", subject: \"No Mailbox\")\n1051-        try database.upsertMessage(message1)\n1052-\n1053:        let retrieved1 = try database.getMessage(id: \"v2-mailbox-1\")\n1054-        XCTAssertNil(retrieved1?.lastKnownMailboxId)\n1055-\n1056-        // Insert a message with last known mailbox id\n1057-        let message2 = MailMessage(\n1058:            id: \"v2-mailbox-2\",\n1059:            subject: \"With Mailbox\",\n1060:            lastKnownMailboxId: 42\n1061-        )\n1062-        try database.upsertMessage(message2)\n1063-\n1064:        let retrieved2 = try database.getMessage(id: \"v2-mailbox-2\")\n1065-        XCTAssertEqual(retrieved2?.lastKnownMailboxId, 42)\n1066-    }\n1067-\n--\n1071-        XCTAssertEqual(MailboxStatus.deleted.rawValue, \"deleted\")\n1072-\n1073-        // Test parsing from raw value\n1074:        XCTAssertEqual(MailboxStatus(rawValue: \"inbox\"), .inbox)\n1075:        XCTAssertEqual(MailboxStatus(rawValue: \"archived\"), .archived)\n1076:        XCTAssertEqual(MailboxStatus(rawValue: \"deleted\"), .deleted)\n1077:        XCTAssertNil(MailboxStatus(rawValue: \"unknown\"))\n1078-    }\n1079-\n1080-    func testSyncActionEnumValues() {\n--\n1082-        XCTAssertEqual(SyncAction.delete.rawValue, \"delete\")\n1083-\n1084-        // Test parsing from raw value\n1085:        XCTAssertEqual(SyncAction(rawValue: \"archive\"), .archive)\n1086:        XCTAssertEqual(SyncAction(rawValue: \"delete\"), .delete)\n1087:        XCTAssertNil(SyncAction(rawValue: \"unknown\"))\n1088-    }\n1089-\n1090-    func testMessageWithAllV2Fields() throws {\n1091-        try database.initialize()\n1092-\n1093-        let message = MailMessage(\n1094:            id: \"v2-full-test\",\n1095:            appleRowId: 12345,\n1096:            mailboxId: 1,\n1097:            mailboxName: \"INBOX\",\n1098:            subject: \"Full V2 Test\",\n1099:            mailboxStatus: .archived,\n1100:            pendingSyncAction: .delete,\n1101:            lastKnownMailboxId: 99\n1102-        )\n1103-\n1104-        try database.upsertMessage(message)\n1105-\n1106:        let retrieved = try database.getMessage(id: \"v2-full-test\")\n1107-        XCTAssertNotNil(retrieved)\n1108-        XCTAssertEqual(retrieved?.mailboxStatus, .archived)\n1109-        XCTAssertEqual(retrieved?.pendingSyncAction, .delete)\n--\n1115-        try database.initialize()\n1116-\n1117-        // Insert a message using minimal fields (simulating pre-V2 message)\n1118:        let message = MailMessage(id: \"pre-v2-msg\", subject: \"Pre-V2 Message\")\n1119-        try database.upsertMessage(message)\n1120-\n1121:        let retrieved = try database.getMessage(id: \"pre-v2-msg\")\n1122-        XCTAssertEqual(retrieved?.mailboxStatus, .inbox, \"Existing messages should default to inbox status\")\n1123-    }\n1124-\n--\n1127-\n1128-        // Insert initial message\n1129-        let message1 = MailMessage(\n1130:            id: \"status-update-test\",\n1131:            subject: \"Initial\",\n1132:            mailboxStatus: .inbox\n1133-        )\n1134-        try database.upsertMessage(message1)\n1135-\n1136-        // Update to archived\n1137-        let message2 = MailMessage(\n1138:            id: \"status-update-test\",\n1139:            subject: \"Initial\",\n1140:            mailboxStatus: .archived\n1141-        )\n1142-        try database.upsertMessage(message2)\n1143-\n1144:        let retrieved = try database.getMessage(id: \"status-update-test\")\n1145-        XCTAssertEqual(retrieved?.mailboxStatus, .archived)\n1146-    }\n1147-\n--\n1149-        try database.initialize()\n1150-\n1151-        let messages = [\n1152:            MailMessage(id: \"batch-v2-1\", subject: \"Batch 1\", mailboxStatus: .inbox),\n1153:            MailMessage(id: \"batch-v2-2\", subject: \"Batch 2\", mailboxStatus: .archived, pendingSyncAction: .archive),\n1154:            MailMessage(id: \"batch-v2-3\", subject: \"Batch 3\", mailboxStatus: .deleted, pendingSyncAction: .delete, lastKnownMailboxId: 5)\n1155-        ]\n1156-\n1157-        let result = try database.batchUpsertMessages(messages)\n1158-        XCTAssertEqual(result.inserted, 3)\n1159-        XCTAssertEqual(result.failed, 0)\n1160-\n1161:        let retrieved1 = try database.getMessage(id: \"batch-v2-1\")\n1162-        XCTAssertEqual(retrieved1?.mailboxStatus, .inbox)\n1163-        XCTAssertNil(retrieved1?.pendingSyncAction)\n1164-\n1165:        let retrieved2 = try database.getMessage(id: \"batch-v2-2\")\n1166-        XCTAssertEqual(retrieved2?.mailboxStatus, .archived)\n1167-        XCTAssertEqual(retrieved2?.pendingSyncAction, .archive)\n1168-\n1169:        let retrieved3 = try database.getMessage(id: \"batch-v2-3\")\n1170-        XCTAssertEqual(retrieved3?.mailboxStatus, .deleted)\n1171-        XCTAssertEqual(retrieved3?.pendingSyncAction, .delete)\n1172-        XCTAssertEqual(retrieved3?.lastKnownMailboxId, 5)\n1173-    }\n1174-\n1175-    func testMailMessageV2DefaultsInInit() {\n1176:        let message = MailMessage(id: \"defaults-test\", subject: \"Defaults\")\n1177-\n1178-        XCTAssertEqual(message.mailboxStatus, .inbox, \"Default mailboxStatus should be inbox\")\n1179-        XCTAssertNil(message.pendingSyncAction, \"Default pendingSyncAction should be nil\")\n1180-        XCTAssertNil(message.lastKnownMailboxId, \"Default lastKnownMailboxId should be nil\")\n1181-    }\n1182-\n1183:    // MARK: - US-002: Mailbox Status Query and Update Methods\n1184-\n1185-    func testUpdateMailboxStatus() throws {\n1186-        try database.initialize()\n1187-\n1188-        // Insert a message\n1189:        let message = MailMessage(id: \"status-test\", subject: \"Status Test\", mailboxStatus: .inbox)\n1190-        try database.upsertMessage(message)\n1191-\n1192-        // Update status to archived\n1193:        try database.updateMailboxStatus(id: \"status-test\", status: .archived)\n1194-\n1195:        let retrieved = try database.getMessage(id: \"status-test\")\n1196-        XCTAssertEqual(retrieved?.mailboxStatus, .archived)\n1197-\n1198-        // Update status to deleted\n1199:        try database.updateMailboxStatus(id: \"status-test\", status: .deleted)\n1200-\n1201:        let retrieved2 = try database.getMessage(id: \"status-test\")\n1202-        XCTAssertEqual(retrieved2?.mailboxStatus, .deleted)\n1203-\n1204-        // Update back to inbox\n1205:        try database.updateMailboxStatus(id: \"status-test\", status: .inbox)\n1206-\n1207:        let retrieved3 = try database.getMessage(id: \"status-test\")\n1208-        XCTAssertEqual(retrieved3?.mailboxStatus, .inbox)\n1209-    }\n1210-\n--\n1212-        try database.initialize()\n1213-\n1214-        // This should not throw, it just won't update anything\n1215:        try database.updateMailboxStatus(id: \"nonexistent\", status: .archived)\n1216-\n1217-        // Verify nothing was created\n1218:        let retrieved = try database.getMessage(id: \"nonexistent\")\n1219-        XCTAssertNil(retrieved)\n1220-    }\n1221-\n1222-    func testSetPendingSyncAction() throws {\n1223-        try database.initialize()\n1224-\n1225:        let message = MailMessage(id: \"action-test\", subject: \"Action Test\")\n1226-        try database.upsertMessage(message)\n1227-\n1228-        // Set archive action\n1229:        try database.setPendingSyncAction(id: \"action-test\", action: .archive)\n1230-\n1231:        let retrieved = try database.getMessage(id: \"action-test\")\n1232-        XCTAssertEqual(retrieved?.pendingSyncAction, .archive)\n1233-\n1234-        // Change to delete action\n1235:        try database.setPendingSyncAction(id: \"action-test\", action: .delete)\n1236-\n1237:        let retrieved2 = try database.getMessage(id: \"action-test\")\n1238-        XCTAssertEqual(retrieved2?.pendingSyncAction, .delete)\n1239-    }\n1240-\n--\n1242-        try database.initialize()\n1243-\n1244-        // This should not throw, it just won't update anything\n1245:        try database.setPendingSyncAction(id: \"nonexistent\", action: .archive)\n1246-\n1247-        // Verify nothing was created\n1248:        let retrieved = try database.getMessage(id: \"nonexistent\")\n1249-        XCTAssertNil(retrieved)\n1250-    }\n1251-\n--\n1254-\n1255-        // Insert a message with pending action\n1256-        let message = MailMessage(\n1257:            id: \"clear-action-test\",\n1258:            subject: \"Clear Action Test\",\n1259:            pendingSyncAction: .archive\n1260-        )\n1261-        try database.upsertMessage(message)\n1262-\n1263-        // Verify action is set\n1264:        let retrieved1 = try database.getMessage(id: \"clear-action-test\")\n1265-        XCTAssertEqual(retrieved1?.pendingSyncAction, .archive)\n1266-\n1267-        // Clear the action\n1268:        try database.clearPendingSyncAction(id: \"clear-action-test\")\n1269-\n1270-        // Verify action is cleared\n1271:        let retrieved2 = try database.getMessage(id: \"clear-action-test\")\n1272-        XCTAssertNil(retrieved2?.pendingSyncAction)\n1273-    }\n1274-\n--\n1276-        try database.initialize()\n1277-\n1278-        // This should not throw, it just won't update anything\n1279:        try database.clearPendingSyncAction(id: \"nonexistent\")\n1280-\n1281-        // Verify nothing was created\n1282:        let retrieved = try database.getMessage(id: \"nonexistent\")\n1283-        XCTAssertNil(retrieved)\n1284-    }\n1285-\n--\n1288-\n1289-        // Insert messages with and without pending actions\n1290-        let messages = [\n1291:            MailMessage(id: \"pending-1\", subject: \"Pending Archive\", pendingSyncAction: .archive),\n1292:            MailMessage(id: \"pending-2\", subject: \"Pending Delete\", pendingSyncAction: .delete),\n1293:            MailMessage(id: \"no-action\", subject: \"No Action\"),\n1294:            MailMessage(id: \"pending-3\", subject: \"Another Archive\", pendingSyncAction: .archive)\n1295-        ]\n1296-\n1297-        for msg in messages {\n--\n1312-        try database.initialize()\n1313-\n1314-        // Insert messages without pending actions\n1315:        let message = MailMessage(id: \"no-action\", subject: \"No Action\")\n1316-        try database.upsertMessage(message)\n1317-\n1318-        let pending = try database.getMessagesWithPendingActions()\n--\n1325-\n1326-        // Insert a message with pending action but marked as deleted\n1327-        let message = MailMessage(\n1328:            id: \"deleted-pending\",\n1329:            subject: \"Deleted with Action\",\n1330:            isDeleted: true,\n1331:            pendingSyncAction: .archive\n1332-        )\n1333-        try database.upsertMessage(message)\n1334-\n--\n1342-\n1343-        // Insert messages with different statuses\n1344-        let messages = [\n1345:            MailMessage(id: \"inbox-1\", subject: \"Inbox 1\", mailboxStatus: .inbox),\n1346:            MailMessage(id: \"inbox-2\", subject: \"Inbox 2\", mailboxStatus: .inbox),\n1347:            MailMessage(id: \"archived-1\", subject: \"Archived 1\", mailboxStatus: .archived),\n1348:            MailMessage(id: \"deleted-1\", subject: \"Deleted 1\", mailboxStatus: .deleted)\n1349-        ]\n1350-\n1351-        for msg in messages {\n--\n1374-        // Insert many inbox messages\n1375-        for i in 1...10 {\n1376-            let message = MailMessage(\n1377:                id: \"inbox-\\(i)\",\n1378:                subject: \"Inbox \\(i)\",\n1379:                dateReceived: Date(timeIntervalSince1970: Double(1000000 + i)),\n1380:                mailboxStatus: .inbox\n1381-            )\n1382-            try database.upsertMessage(message)\n1383-        }\n1384-\n1385-        // Get with limit\n1386:        let limited = try database.getMessagesByStatus(.inbox, limit: 5)\n1387-        XCTAssertEqual(limited.count, 5)\n1388-\n1389-        // Get with offset\n1390:        let offset = try database.getMessagesByStatus(.inbox, limit: 5, offset: 5)\n1391-        XCTAssertEqual(offset.count, 5)\n1392-\n1393-        // Verify no overlap\n1394-        let limitedIds = Set(limited.map { $0.id })\n1395-        let offsetIds = Set(offset.map { $0.id })\n1396:        XCTAssertTrue(limitedIds.isDisjoint(with: offsetIds))\n1397-    }\n1398-\n1399-    func testGetMessagesByStatusEmpty() throws {\n1400-        try database.initialize()\n1401-\n1402-        // Insert inbox messages only\n1403:        let message = MailMessage(id: \"inbox-only\", subject: \"Inbox\", mailboxStatus: .inbox)\n1404-        try database.upsertMessage(message)\n1405-\n1406-        // Query for archived (should be empty)\n--\n1413-\n1414-        // Insert a message that's in inbox but soft-deleted\n1415-        let message = MailMessage(\n1416:            id: \"soft-deleted\",\n1417:            subject: \"Soft Deleted\",\n1418:            isDeleted: true,\n1419:            mailboxStatus: .inbox\n1420-        )\n1421-        try database.upsertMessage(message)\n1422-\n--\n1430-\n1431-        // Insert messages with different statuses\n1432-        let messages = [\n1433:            MailMessage(id: \"inbox-1\", subject: \"Inbox 1\", mailboxStatus: .inbox),\n1434:            MailMessage(id: \"inbox-2\", subject: \"Inbox 2\", mailboxStatus: .inbox),\n1435:            MailMessage(id: \"inbox-3\", subject: \"Inbox 3\", mailboxStatus: .inbox),\n1436:            MailMessage(id: \"archived-1\", subject: \"Archived 1\", mailboxStatus: .archived),\n1437:            MailMessage(id: \"archived-2\", subject: \"Archived 2\", mailboxStatus: .archived),\n1438:            MailMessage(id: \"deleted-1\", subject: \"Deleted 1\", mailboxStatus: .deleted)\n1439-        ]\n1440-\n1441-        for msg in messages {\n--\n1465-\n1466-        // Insert a soft-deleted message\n1467-        let message = MailMessage(\n1468:            id: \"soft-deleted\",\n1469:            subject: \"Soft Deleted\",\n1470:            isDeleted: true,\n1471:            mailboxStatus: .inbox\n1472-        )\n1473-        try database.upsertMessage(message)\n1474-\n--\n1480-    func testStatusMethodsBeforeInitializeThrow() throws {\n1481-        // Don't call initialize()\n1482-\n1483:        XCTAssertThrowsError(try database.updateMailboxStatus(id: \"test\", status: .archived)) { error in\n1484-            guard case MailDatabaseError.notInitialized = error else {\n1485-                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n1486-                return\n1487-            }\n1488-        }\n1489-\n1490:        XCTAssertThrowsError(try database.setPendingSyncAction(id: \"test\", action: .archive)) { error in\n1491-            guard case MailDatabaseError.notInitialized = error else {\n1492-                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n1493-                return\n1494-            }\n1495-        }\n1496-\n1497:        XCTAssertThrowsError(try database.clearPendingSyncAction(id: \"test\")) { error in\n1498-            guard case MailDatabaseError.notInitialized = error else {\n1499-                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n1500-                return\n--\n1523-        }\n1524-    }\n1525-\n1526:    // MARK: - Migration V5: Thread-Messages Junction Table Tests\n1527-\n1528-    func testAddMessageToThread() throws {\n1529-        try database.initialize()\n1530-\n1531-        // Create a thread and a message\n1532:        let thread = Thread(id: \"thread-1\", subject: \"Test Thread\")\n1533-        try database.upsertThread(thread)\n1534-\n1535:        let message = MailMessage(id: \"msg-1\", subject: \"Test Message\")\n1536-        try database.upsertMessage(message)\n1537-\n1538-        // Add message to thread\n1539:        try database.addMessageToThread(messageId: \"msg-1\", threadId: \"thread-1\")\n1540-\n1541-        // Verify the relationship exists\n1542:        let messageIds = try database.getMessageIdsInThread(threadId: \"thread-1\")\n1543-        XCTAssertEqual(messageIds.count, 1)\n1544-        XCTAssertEqual(messageIds.first, \"msg-1\")\n1545-    }\n--\n1548-        try database.initialize()\n1549-\n1550-        // Create thread and message\n1551:        let thread = Thread(id: \"thread-dup\", subject: \"Duplicate Test\")\n1552-        try database.upsertThread(thread)\n1553-\n1554:        let message = MailMessage(id: \"msg-dup\", subject: \"Duplicate Message\")\n1555-        try database.upsertMessage(message)\n1556-\n1557-        // Add same message twice - should not throw\n1558:        try database.addMessageToThread(messageId: \"msg-dup\", threadId: \"thread-dup\")\n1559:        try database.addMessageToThread(messageId: \"msg-dup\", threadId: \"thread-dup\")\n1560-\n1561-        // Should still only have one entry\n1562:        let messageIds = try database.getMessageIdsInThread(threadId: \"thread-dup\")\n1563-        XCTAssertEqual(messageIds.count, 1)\n1564-    }\n1565-\n--\n1567-        try database.initialize()\n1568-\n1569-        // Setup thread and message\n1570:        let thread = Thread(id: \"thread-remove\", subject: \"Remove Test\")\n1571-        try database.upsertThread(thread)\n1572-\n1573:        let message = MailMessage(id: \"msg-remove\", subject: \"To Be Removed\")\n1574-        try database.upsertMessage(message)\n1575-\n1576:        try database.addMessageToThread(messageId: \"msg-remove\", threadId: \"thread-remove\")\n1577-\n1578-        // Verify it exists\n1579:        var messageIds = try database.getMessageIdsInThread(threadId: \"thread-remove\")\n1580-        XCTAssertEqual(messageIds.count, 1)\n1581-\n1582-        // Remove it\n1583:        try database.removeMessageFromThread(messageId: \"msg-remove\", threadId: \"thread-remove\")\n1584-\n1585-        // Verify it's gone\n1586:        messageIds = try database.getMessageIdsInThread(threadId: \"thread-remove\")\n1587-        XCTAssertEqual(messageIds.count, 0)\n1588-    }\n1589-\n--\n1591-        try database.initialize()\n1592-\n1593-        // Should not throw even if relationship doesn't exist\n1594:        try database.removeMessageFromThread(messageId: \"nonexistent\", threadId: \"nonexistent\")\n1595-    }\n1596-\n1597-    func testGetMessageIdsInThread() throws {\n1598-        try database.initialize()\n1599-\n1600-        // Create thread and multiple messages\n1601:        let thread = Thread(id: \"thread-multi\", subject: \"Multi Message Thread\")\n1602-        try database.upsertThread(thread)\n1603-\n1604-        for i in 1...5 {\n1605:            let message = MailMessage(id: \"multi-msg-\\(i)\", subject: \"Message \\(i)\")\n1606-            try database.upsertMessage(message)\n1607:            try database.addMessageToThread(messageId: \"multi-msg-\\(i)\", threadId: \"thread-multi\")\n1608-        }\n1609-\n1610:        let messageIds = try database.getMessageIdsInThread(threadId: \"thread-multi\")\n1611-        XCTAssertEqual(messageIds.count, 5)\n1612-        for i in 1...5 {\n1613-            XCTAssertTrue(messageIds.contains(\"multi-msg-\\(i)\"))\n--\n1617-    func testGetMessageIdsInThreadEmpty() throws {\n1618-        try database.initialize()\n1619-\n1620:        let messageIds = try database.getMessageIdsInThread(threadId: \"nonexistent-thread\")\n1621-        XCTAssertTrue(messageIds.isEmpty)\n1622-    }\n1623-\n--\n1626-\n1627-        // Create multiple threads and one message\n1628-        for i in 1...3 {\n1629:            let thread = Thread(id: \"multi-thread-\\(i)\", subject: \"Thread \\(i)\")\n1630-            try database.upsertThread(thread)\n1631-        }\n1632-\n1633:        let message = MailMessage(id: \"shared-msg\", subject: \"Shared Message\")\n1634-        try database.upsertMessage(message)\n1635-\n1636-        // Add message to all threads\n1637-        for i in 1...3 {\n1638:            try database.addMessageToThread(messageId: \"shared-msg\", threadId: \"multi-thread-\\(i)\")\n1639-        }\n1640-\n1641:        let threadIds = try database.getThreadIdsForMessage(messageId: \"shared-msg\")\n1642-        XCTAssertEqual(threadIds.count, 3)\n1643-        for i in 1...3 {\n1644-            XCTAssertTrue(threadIds.contains(\"multi-thread-\\(i)\"))\n--\n1648-    func testGetThreadIdsForMessageEmpty() throws {\n1649-        try database.initialize()\n1650-\n1651:        let threadIds = try database.getThreadIdsForMessage(messageId: \"nonexistent-message\")\n1652-        XCTAssertTrue(threadIds.isEmpty)\n1653-    }\n1654-\n--\n1656-        try database.initialize()\n1657-\n1658-        // Create thread\n1659:        let thread = Thread(id: \"full-thread\", subject: \"Full Thread Test\")\n1660-        try database.upsertThread(thread)\n1661-\n1662-        // Create messages with different dates\n1663:        let baseDate = Date(timeIntervalSince1970: 1000000)\n1664-        for i in 1...3 {\n1665-            let message = MailMessage(\n1666:                id: \"full-msg-\\(i)\",\n1667:                subject: \"Full Message \\(i)\",\n1668:                dateReceived: Date(timeIntervalSince1970: baseDate.timeIntervalSince1970 + Double(i * 100))\n1669-            )\n1670-            try database.upsertMessage(message)\n1671:            try database.addMessageToThread(messageId: \"full-msg-\\(i)\", threadId: \"full-thread\")\n1672-        }\n1673-\n1674:        let messages = try database.getMessagesInThreadViaJunction(threadId: \"full-thread\")\n1675-        XCTAssertEqual(messages.count, 3)\n1676-\n1677-        // Verify ordering by date_received ASC\n--\n1684-        try database.initialize()\n1685-\n1686-        // Create thread\n1687:        let thread = Thread(id: \"deleted-test-thread\", subject: \"Deleted Test\")\n1688-        try database.upsertThread(thread)\n1689-\n1690-        // Create one normal message and one deleted message\n1691:        let normalMsg = MailMessage(id: \"normal-msg\", subject: \"Normal\")\n1692:        let deletedMsg = MailMessage(id: \"deleted-msg\", subject: \"Deleted\", isDeleted: true)\n1693-\n1694-        try database.upsertMessage(normalMsg)\n1695-        try database.upsertMessage(deletedMsg)\n1696-\n1697:        try database.addMessageToThread(messageId: \"normal-msg\", threadId: \"deleted-test-thread\")\n1698:        try database.addMessageToThread(messageId: \"deleted-msg\", threadId: \"deleted-test-thread\")\n1699-\n1700:        let messages = try database.getMessagesInThreadViaJunction(threadId: \"deleted-test-thread\")\n1701-        XCTAssertEqual(messages.count, 1)\n1702-        XCTAssertEqual(messages.first?.id, \"normal-msg\")\n1703-    }\n--\n1705-    func testGetMessagesInThreadViaJunctionWithLimitAndOffset() throws {\n1706-        try database.initialize()\n1707-\n1708:        let thread = Thread(id: \"paginated-thread\", subject: \"Paginated Thread\")\n1709-        try database.upsertThread(thread)\n1710-\n1711-        // Create 10 messages\n1712-        for i in 1...10 {\n1713-            let message = MailMessage(\n1714:                id: \"paginated-msg-\\(i)\",\n1715:                subject: \"Message \\(i)\",\n1716:                dateReceived: Date(timeIntervalSince1970: Double(1000000 + i))\n1717-            )\n1718-            try database.upsertMessage(message)\n1719:            try database.addMessageToThread(messageId: \"paginated-msg-\\(i)\", threadId: \"paginated-thread\")\n1720-        }\n1721-\n1722-        // Get first 5\n1723:        let first5 = try database.getMessagesInThreadViaJunction(threadId: \"paginated-thread\", limit: 5)\n1724-        XCTAssertEqual(first5.count, 5)\n1725-\n1726-        // Get next 5\n1727:        let next5 = try database.getMessagesInThreadViaJunction(threadId: \"paginated-thread\", limit: 5, offset: 5)\n1728-        XCTAssertEqual(next5.count, 5)\n1729-\n1730-        // Verify no overlap\n1731-        let first5Ids = Set(first5.map { $0.id })\n1732-        let next5Ids = Set(next5.map { $0.id })\n1733:        XCTAssertTrue(first5Ids.isDisjoint(with: next5Ids))\n1734-    }\n1735-\n1736-    func testGetThreadsForMessage() throws {\n1737-        try database.initialize()\n1738-\n1739-        // Create threads with different dates\n1740:        let baseDate = Date(timeIntervalSince1970: 1000000)\n1741-        for i in 1...3 {\n1742-            let thread = Thread(\n1743:                id: \"msg-threads-\\(i)\",\n1744:                subject: \"Thread \\(i)\",\n1745:                lastDate: Date(timeIntervalSince1970: baseDate.timeIntervalSince1970 + Double(i * 100))\n1746-            )\n1747-            try database.upsertThread(thread)\n1748-        }\n1749-\n1750:        let message = MailMessage(id: \"thread-query-msg\", subject: \"Query Message\")\n1751-        try database.upsertMessage(message)\n1752-\n1753-        // Add message to all threads\n1754-        for i in 1...3 {\n1755:            try database.addMessageToThread(messageId: \"thread-query-msg\", threadId: \"msg-threads-\\(i)\")\n1756-        }\n1757-\n1758:        let threads = try database.getThreadsForMessage(messageId: \"thread-query-msg\")\n1759-        XCTAssertEqual(threads.count, 3)\n1760-\n1761-        // Verify ordering by last_date DESC\n--\n1767-    func testGetThreadsForMessageEmpty() throws {\n1768-        try database.initialize()\n1769-\n1770:        let threads = try database.getThreadsForMessage(messageId: \"nonexistent\")\n1771-        XCTAssertTrue(threads.isEmpty)\n1772-    }\n1773-\n1774-    func testGetMessageCountInThread() throws {\n1775-        try database.initialize()\n1776-\n1777:        let thread = Thread(id: \"count-thread\", subject: \"Count Thread\")\n1778-        try database.upsertThread(thread)\n1779-\n1780-        // Initially empty\n1781:        var count = try database.getMessageCountInThread(threadId: \"count-thread\")\n1782-        XCTAssertEqual(count, 0)\n1783-\n1784-        // Add messages\n1785-        for i in 1...5 {\n1786:            let message = MailMessage(id: \"count-msg-\\(i)\", subject: \"Count Message \\(i)\")\n1787-            try database.upsertMessage(message)\n1788:            try database.addMessageToThread(messageId: \"count-msg-\\(i)\", threadId: \"count-thread\")\n1789-        }\n1790-\n1791:        count = try database.getMessageCountInThread(threadId: \"count-thread\")\n1792-        XCTAssertEqual(count, 5)\n1793-    }\n1794-\n1795-    func testGetMessageCountInThreadNonexistent() throws {\n1796-        try database.initialize()\n1797-\n1798:        let count = try database.getMessageCountInThread(threadId: \"nonexistent\")\n1799-        XCTAssertEqual(count, 0)\n1800-    }\n1801-\n1802-    func testIsMessageInThread() throws {\n1803-        try database.initialize()\n1804-\n1805:        let thread = Thread(id: \"check-thread\", subject: \"Check Thread\")\n1806-        try database.upsertThread(thread)\n1807-\n1808:        let message = MailMessage(id: \"check-msg\", subject: \"Check Message\")\n1809-        try database.upsertMessage(message)\n1810-\n1811-        // Initially not in thread\n1812:        var inThread = try database.isMessageInThread(messageId: \"check-msg\", threadId: \"check-thread\")\n1813-        XCTAssertFalse(inThread)\n1814-\n1815-        // Add to thread\n1816:        try database.addMessageToThread(messageId: \"check-msg\", threadId: \"check-thread\")\n1817-\n1818-        // Now in thread\n1819:        inThread = try database.isMessageInThread(messageId: \"check-msg\", threadId: \"check-thread\")\n1820-        XCTAssertTrue(inThread)\n1821-\n1822-        // Remove from thread\n1823:        try database.removeMessageFromThread(messageId: \"check-msg\", threadId: \"check-thread\")\n1824-\n1825-        // Not in thread anymore\n1826:        inThread = try database.isMessageInThread(messageId: \"check-msg\", threadId: \"check-thread\")\n1827-        XCTAssertFalse(inThread)\n1828-    }\n1829-\n1830-    func testIsMessageInThreadNonexistent() throws {\n1831-        try database.initialize()\n1832-\n1833:        let inThread = try database.isMessageInThread(messageId: \"nonexistent\", threadId: \"nonexistent\")\n1834-        XCTAssertFalse(inThread)\n1835-    }\n1836-\n--\n1838-        try database.initialize()\n1839-\n1840-        // Create thread and message\n1841:        let thread = Thread(id: \"fk-thread\", subject: \"FK Thread\")\n1842-        try database.upsertThread(thread)\n1843-\n1844:        let message = MailMessage(id: \"fk-msg\", subject: \"FK Message\")\n1845-        try database.upsertMessage(message)\n1846-\n1847:        try database.addMessageToThread(messageId: \"fk-msg\", threadId: \"fk-thread\")\n1848-\n1849-        // Verify relationship exists\n1850:        var messageIds = try database.getMessageIdsInThread(threadId: \"fk-thread\")\n1851-        XCTAssertEqual(messageIds.count, 1)\n1852-\n1853:        // Note: SQLite's foreign key CASCADE delete would clean up thread_messages\n1854-        // when the thread is deleted. However, we don't have a deleteThread method yet.\n1855-        // This test verifies the junction table is working correctly.\n1856-    }\n--\n1861-        // Create multiple threads\n1862-        let threads = [\"thread-a\", \"thread-b\", \"thread-c\"]\n1863-        for threadId in threads {\n1864:            try database.upsertThread(Thread(id: threadId, subject: \"Thread \\(threadId)\"))\n1865-        }\n1866-\n1867-        // Create multiple messages\n1868-        let messages = [\"msg-1\", \"msg-2\", \"msg-3\"]\n1869-        for msgId in messages {\n1870:            try database.upsertMessage(MailMessage(id: msgId, subject: \"Message \\(msgId)\"))\n1871-        }\n1872-\n1873:        // Create many-to-many relationships:\n1874-        // msg-1 -> thread-a, thread-b\n1875-        // msg-2 -> thread-b, thread-c\n1876-        // msg-3 -> thread-a, thread-c\n1877:        try database.addMessageToThread(messageId: \"msg-1\", threadId: \"thread-a\")\n1878:        try database.addMessageToThread(messageId: \"msg-1\", threadId: \"thread-b\")\n1879:        try database.addMessageToThread(messageId: \"msg-2\", threadId: \"thread-b\")\n1880:        try database.addMessageToThread(messageId: \"msg-2\", threadId: \"thread-c\")\n1881:        try database.addMessageToThread(messageId: \"msg-3\", threadId: \"thread-a\")\n1882:        try database.addMessageToThread(messageId: \"msg-3\", threadId: \"thread-c\")\n1883-\n1884-        // Verify thread-a has msg-1 and msg-3\n1885:        let threadAMessages = try database.getMessageIdsInThread(threadId: \"thread-a\")\n1886-        XCTAssertEqual(threadAMessages.count, 2)\n1887-        XCTAssertTrue(threadAMessages.contains(\"msg-1\"))\n1888-        XCTAssertTrue(threadAMessages.contains(\"msg-3\"))\n1889-\n1890-        // Verify thread-b has msg-1 and msg-2\n1891:        let threadBMessages = try database.getMessageIdsInThread(threadId: \"thread-b\")\n1892-        XCTAssertEqual(threadBMessages.count, 2)\n1893-        XCTAssertTrue(threadBMessages.contains(\"msg-1\"))\n1894-        XCTAssertTrue(threadBMessages.contains(\"msg-2\"))\n1895-\n1896-        // Verify thread-c has msg-2 and msg-3\n1897:        let threadCMessages = try database.getMessageIdsInThread(threadId: \"thread-c\")\n1898-        XCTAssertEqual(threadCMessages.count, 2)\n1899-        XCTAssertTrue(threadCMessages.contains(\"msg-2\"))\n1900-        XCTAssertTrue(threadCMessages.contains(\"msg-3\"))\n1901-\n1902-        // Verify msg-1 is in thread-a and thread-b\n1903:        let msg1Threads = try database.getThreadIdsForMessage(messageId: \"msg-1\")\n1904-        XCTAssertEqual(msg1Threads.count, 2)\n1905-        XCTAssertTrue(msg1Threads.contains(\"thread-a\"))\n1906-        XCTAssertTrue(msg1Threads.contains(\"thread-b\"))\n--\n1909-    func testThreadMessageJunctionMethodsBeforeInitializeThrow() throws {\n1910-        // Don't call initialize()\n1911-\n1912:        XCTAssertThrowsError(try database.addMessageToThread(messageId: \"test\", threadId: \"test\")) { error in\n1913-            guard case MailDatabaseError.notInitialized = error else {\n1914-                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n1915-                return\n1916-            }\n1917-        }\n1918-\n1919:        XCTAssertThrowsError(try database.removeMessageFromThread(messageId: \"test\", threadId: \"test\")) { error in\n1920-            guard case MailDatabaseError.notInitialized = error else {\n1921-                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n1922-                return\n1923-            }\n1924-        }\n1925-\n1926:        XCTAssertThrowsError(try database.getMessageIdsInThread(threadId: \"test\")) { error in\n1927-            guard case MailDatabaseError.notInitialized = error else {\n1928-                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n1929-                return\n1930-            }\n1931-        }\n1932-\n1933:        XCTAssertThrowsError(try database.getThreadIdsForMessage(messageId: \"test\")) { error in\n1934-            guard case MailDatabaseError.notInitialized = error else {\n1935-                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n1936-                return\n1937-            }\n1938-        }\n1939-\n1940:        XCTAssertThrowsError(try database.getMessagesInThreadViaJunction(threadId: \"test\")) { error in\n1941-            guard case MailDatabaseError.notInitialized = error else {\n1942-                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n1943-                return\n1944-            }\n1945-        }\n1946-\n1947:        XCTAssertThrowsError(try database.getThreadsForMessage(messageId: \"test\")) { error in\n1948-            guard case MailDatabaseError.notInitialized = error else {\n1949-                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n1950-                return\n1951-            }\n1952-        }\n1953-\n1954:        XCTAssertThrowsError(try database.getMessageCountInThread(threadId: \"test\")) { error in\n1955-            guard case MailDatabaseError.notInitialized = error else {\n1956-                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n1957-                return\n1958-            }\n1959-        }\n1960-\n1961:        XCTAssertThrowsError(try database.isMessageInThread(messageId: \"test\", threadId: \"test\")) { error in\n1962-            guard case MailDatabaseError.notInitialized = error else {\n1963-                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n1964-                return\n--\n1966-        }\n1967-    }\n1968-\n1969:    // MARK: - US-004: Thread Index Tests\n1970-\n1971-    func testThreadIdIndexExistsOnMessagesTable() throws {\n1972-        try database.initialize()\n1973-\n1974:        let indexes = try database.getIndexes(on: \"messages\")\n1975-\n1976-        XCTAssertTrue(indexes.contains(\"idx_messages_thread_id\"),\n1977:                      \"Index idx_messages_thread_id should exist on messages table. Found: \\(indexes)\")\n1978-    }\n1979-\n1980-    func testThreadsTableHasPrimaryKeyIndex() throws {\n--\n1982-\n1983-        // SQLite automatically creates an index for the PRIMARY KEY\n1984-        // We can verify this by checking the table info\n1985:        let indexes = try database.getIndexes(on: \"threads\")\n1986-\n1987-        // The threads table should have an index on last_date\n1988-        XCTAssertTrue(indexes.contains(\"idx_threads_last_date\"),\n1989:                      \"Index idx_threads_last_date should exist on threads table. Found: \\(indexes)\")\n1990-    }\n1991-\n1992-    func testThreadMessagesIndexesExist() throws {\n1993-        try database.initialize()\n1994-\n1995:        let indexes = try database.getIndexes(on: \"thread_messages\")\n1996-\n1997-        XCTAssertTrue(indexes.contains(\"idx_thread_messages_thread_id\"),\n1998:                      \"Index idx_thread_messages_thread_id should exist on thread_messages table. Found: \\(indexes)\")\n1999-        XCTAssertTrue(indexes.contains(\"idx_thread_messages_message_id\"),\n2000:                      \"Index idx_thread_messages_message_id should exist on thread_messages table. Found: \\(indexes)\")\n2001-    }\n2002-\n2003-    func testExplainQueryPlanUsesThreadIdIndex() throws {\n2004-        try database.initialize()\n2005-\n2006-        // Create thread first (required for foreign key constraint)\n2007:        let thread = Thread(id: \"test-thread-id\", subject: \"Test Thread\")\n2008-        try database.upsertThread(thread)\n2009-\n2010-        // Insert some test data to ensure table has data\n2011:        let message = MailMessage(id: \"plan-test-msg\", subject: \"Plan Test\", threadId: \"test-thread-id\")\n2012-        try database.upsertMessage(message)\n2013-\n2014-        // Query plan for looking up messages by thread_id\n--\n2018-\n2019-        // The plan should show usage of the index\n2020-        // SQLite's EXPLAIN QUERY PLAN typically shows \"SEARCH\" with index usage\n2021:        let planString = plan.joined(separator: \" \")\n2022-        XCTAssertTrue(\n2023-            planString.contains(\"idx_messages_thread_id\") || planString.contains(\"USING INDEX\"),\n2024:            \"Query should use idx_messages_thread_id index. Plan: \\(planString)\"\n2025-        )\n2026-    }\n2027-\n--\n2029-        try database.initialize()\n2030-\n2031-        // Insert test data\n2032:        let thread = Thread(id: \"plan-thread\", subject: \"Plan Thread\")\n2033-        try database.upsertThread(thread)\n2034:        let message = MailMessage(id: \"plan-msg\", subject: \"Plan Message\")\n2035-        try database.upsertMessage(message)\n2036:        try database.addMessageToThread(messageId: \"plan-msg\", threadId: \"plan-thread\")\n2037-\n2038-        // Query plan for looking up messages in a thread via junction table\n2039-        let plan = try database.explainQueryPlan(\n--\n2042-\n2043-        // The plan should show usage of an index (could be explicit index or autoindex for primary key)\n2044-        // SQLite may use sqlite_autoindex_thread_messages_1 which is the covering index for the composite primary key\n2045:        let planString = plan.joined(separator: \" \")\n2046-        XCTAssertTrue(\n2047-            planString.contains(\"idx_thread_messages_thread_id\") ||\n2048-            planString.contains(\"USING INDEX\") ||\n2049-            planString.contains(\"USING COVERING INDEX\") ||\n2050-            planString.contains(\"sqlite_autoindex\"),\n2051:            \"Query should use an index. Plan: \\(planString)\"\n2052-        )\n2053-    }\n2054-\n2055-    func testIndexVerificationMethodsBeforeInitializeThrow() throws {\n2056-        // Don't call initialize()\n2057-\n2058:        XCTAssertThrowsError(try database.getIndexes(on: \"messages\")) { error in\n2059-            guard case MailDatabaseError.notInitialized = error else {\n2060-                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n2061-                return\n--\n2070-        }\n2071-    }\n2072-\n2073:    // MARK: - US-023: Large Inbox Query Optimization Tests\n2074-\n2075-    func testMigrationV7IndexesExist() throws {\n2076-        try database.initialize()\n2077-\n2078-        // Verify indexes added in migration V7 for large inbox optimization\n2079:        let threadIndexes = try database.getIndexes(on: \"threads\")\n2080-        XCTAssertTrue(threadIndexes.contains(\"idx_threads_subject\"),\n2081:                      \"Index idx_threads_subject should exist on threads table. Found: \\(threadIndexes)\")\n2082-        XCTAssertTrue(threadIndexes.contains(\"idx_threads_message_count\"),\n2083:                      \"Index idx_threads_message_count should exist on threads table. Found: \\(threadIndexes)\")\n2084-\n2085:        let messageIndexes = try database.getIndexes(on: \"messages\")\n2086-        XCTAssertTrue(messageIndexes.contains(\"idx_messages_sender_email\"),\n2087:                      \"Index idx_messages_sender_email should exist on messages table. Found: \\(messageIndexes)\")\n2088-        XCTAssertTrue(messageIndexes.contains(\"idx_messages_thread_position\"),\n2089:                      \"Index idx_messages_thread_position should exist on messages table. Found: \\(messageIndexes)\")\n2090-\n2091:        let recipientIndexes = try database.getIndexes(on: \"recipients\")\n2092-        XCTAssertTrue(recipientIndexes.contains(\"idx_recipients_email\"),\n2093:                      \"Index idx_recipients_email should exist on recipients table. Found: \\(recipientIndexes)\")\n2094-    }\n2095-\n2096-    func testThreadListingUsesLastDateIndex() throws {\n2097-        try database.initialize()\n2098-\n2099-        // Insert test data\n2100:        let thread = Thread(id: \"perf-thread\", subject: \"Performance Test\")\n2101-        try database.upsertThread(thread)\n2102-\n2103-        // Query plan for basic thread listing by date\n--\n2105-            \"SELECT * FROM threads ORDER BY last_date DESC LIMIT 50\"\n2106-        )\n2107-\n2108:        let planString = plan.joined(separator: \" \")\n2109-        XCTAssertTrue(\n2110-            planString.contains(\"idx_threads_last_date\") || planString.contains(\"USING INDEX\"),\n2111:            \"Thread listing by date should use idx_threads_last_date. Plan: \\(planString)\"\n2112-        )\n2113-    }\n2114-\n2115-    func testThreadListingBySubjectUsesIndex() throws {\n2116-        try database.initialize()\n2117-\n2118:        let thread = Thread(id: \"subj-thread\", subject: \"Subject Test\")\n2119-        try database.upsertThread(thread)\n2120-\n2121-        // Query plan for thread listing by subject\n--\n2123-            \"SELECT * FROM threads ORDER BY subject LIMIT 50\"\n2124-        )\n2125-\n2126:        let planString = plan.joined(separator: \" \")\n2127-        XCTAssertTrue(\n2128-            planString.contains(\"idx_threads_subject\") || planString.contains(\"USING INDEX\") || planString.contains(\"SCAN\"),\n2129:            \"Query should use idx_threads_subject or scan. Plan: \\(planString)\"\n2130-        )\n2131-    }\n2132-\n2133-    func testThreadListingByMessageCountUsesIndex() throws {\n2134-        try database.initialize()\n2135-\n2136:        let thread = Thread(id: \"count-thread\", subject: \"Count Test\", messageCount: 5)\n2137-        try database.upsertThread(thread)\n2138-\n2139-        // Query plan for thread listing by message count\n--\n2141-            \"SELECT * FROM threads ORDER BY message_count DESC LIMIT 50\"\n2142-        )\n2143-\n2144:        let planString = plan.joined(separator: \" \")\n2145-        XCTAssertTrue(\n2146-            planString.contains(\"idx_threads_message_count\") || planString.contains(\"USING INDEX\") || planString.contains(\"SCAN\"),\n2147:            \"Query should use idx_threads_message_count or scan. Plan: \\(planString)\"\n2148-        )\n2149-    }\n2150-\n--\n2152-        try database.initialize()\n2153-\n2154-        // Create a thread with 15 messages to trigger batch update\n2155:        let thread = Thread(id: \"batch-thread\", subject: \"Batch Update Test\")\n2156-        try database.upsertThread(thread)\n2157-\n2158-        for i in 1...15 {\n2159-            let message = MailMessage(\n2160:                id: \"batch-msg-\\(i)\",\n2161:                subject: \"Message \\(i)\",\n2162:                dateReceived: Date(timeIntervalSince1970: Double(1700000000 + i * 100)),\n2163:                threadId: \"batch-thread\"\n2164-            )\n2165-            try database.upsertMessage(message)\n2166:            try database.addMessageToThread(messageId: \"batch-msg-\\(i)\", threadId: \"batch-thread\")\n2167-        }\n2168-\n2169-        // Update thread positions using batch update\n2170:        try database.updateThreadPositions(threadId: \"batch-thread\")\n2171-\n2172-        // Verify positions were updated correctly\n2173:        let messages = try database.getMessagesInThreadViaJunction(threadId: \"batch-thread\", limit: 100, offset: 0)\n2174-        XCTAssertEqual(messages.count, 15)\n2175-\n2176-        for (index, message) in messages.enumerated() {\n--\n2185-        try database.initialize()\n2186-\n2187-        // Create a thread with 5 messages (below batch threshold of 10)\n2188:        let thread = Thread(id: \"small-thread\", subject: \"Small Thread Test\")\n2189-        try database.upsertThread(thread)\n2190-\n2191-        for i in 1...5 {\n2192-            let message = MailMessage(\n2193:                id: \"small-msg-\\(i)\",\n2194:                subject: \"Message \\(i)\",\n2195:                dateReceived: Date(timeIntervalSince1970: Double(1700000000 + i * 100)),\n2196:                threadId: \"small-thread\"\n2197-            )\n2198-            try database.upsertMessage(message)\n2199:            try database.addMessageToThread(messageId: \"small-msg-\\(i)\", threadId: \"small-thread\")\n2200-        }\n2201-\n2202-        // Update thread positions\n2203:        try database.updateThreadPositions(threadId: \"small-thread\")\n2204-\n2205-        // Verify positions were updated correctly\n2206:        let messages = try database.getMessagesInThreadViaJunction(threadId: \"small-thread\", limit: 100, offset: 0)\n2207-        XCTAssertEqual(messages.count, 5)\n2208-\n2209-        for (index, message) in messages.enumerated() {\n--\n2215-    func testEmptyThreadPositionUpdateDoesNothing() throws {\n2216-        try database.initialize()\n2217-\n2218:        let thread = Thread(id: \"empty-thread\", subject: \"Empty Thread\")\n2219-        try database.upsertThread(thread)\n2220-\n2221-        // Should not throw for empty thread\n2222:        XCTAssertNoThrow(try database.updateThreadPositions(threadId: \"empty-thread\"))\n2223-    }\n2224-\n2225-    func testThreadQueryWithPaginationBoundsMemory() throws {\n--\n2228-        // Create 100 threads\n2229-        for i in 1...100 {\n2230-            let thread = Thread(\n2231:                id: \"page-thread-\\(i)\",\n2232:                subject: \"Thread \\(i)\",\n2233:                lastDate: Date(timeIntervalSince1970: Double(1700000000 + i * 100))\n2234-            )\n2235-            try database.upsertThread(thread)\n2236-        }\n2237-\n2238-        // Get first page of 10\n2239:        let page1 = try database.getThreads(limit: 10, offset: 0)\n2240-        XCTAssertEqual(page1.count, 10, \"First page should have 10 threads\")\n2241-\n2242-        // Get second page of 10\n2243:        let page2 = try database.getThreads(limit: 10, offset: 10)\n2244-        XCTAssertEqual(page2.count, 10, \"Second page should have 10 threads\")\n2245-\n2246-        // Verify pages don't overlap\n2247-        let page1Ids = Set(page1.map { $0.id })\n2248-        let page2Ids = Set(page2.map { $0.id })\n2249:        XCTAssertTrue(page1Ids.isDisjoint(with: page2Ids), \"Pages should not overlap\")\n2250-    }\n2251-\n2252-    func testThreadDetailViewUsesIndexes() throws {\n2253-        try database.initialize()\n2254-\n2255-        // Create thread with messages\n2256:        let thread = Thread(id: \"detail-thread\", subject: \"Detail Test\")\n2257-        try database.upsertThread(thread)\n2258-\n2259:        let message = MailMessage(id: \"detail-msg\", subject: \"Detail Message\", threadId: \"detail-thread\")\n2260-        try database.upsertMessage(message)\n2261:        try database.addMessageToThread(messageId: \"detail-msg\", threadId: \"detail-thread\")\n2262-\n2263-        // Query plan for thread detail (get messages in thread)\n2264-        let plan = try database.explainQueryPlan(\n2265-            \"SELECT m.* FROM messages m JOIN thread_messages tm ON m.id = tm.message_id WHERE tm.thread_id = 'detail-thread' ORDER BY m.date_received ASC\"\n2266-        )\n2267-\n2268:        let planString = plan.joined(separator: \" \")\n2269-        XCTAssertTrue(\n2270-            planString.contains(\"idx_thread_messages_thread_id\") ||\n2271-            planString.contains(\"USING INDEX\") ||\n2272-            planString.contains(\"USING COVERING INDEX\") ||\n2273-            planString.contains(\"sqlite_autoindex\"),\n2274:            \"Thread detail query should use an index. Plan: \\(planString)\"\n2275-        )\n2276-    }\n2277-\n2278:    // MARK: - US-005: Database Migration Script Tests\n2279-\n2280-    func testGetSchemaVersionReturnsCurrentVersion() throws {\n2281-        try database.initialize()\n--\n2289-        // Database not initialized\n2290-        XCTAssertThrowsError(try database.getSchemaVersion()) { error in\n2291-            guard case MailDatabaseError.notInitialized = error else {\n2292:                XCTFail(\"Expected notInitialized error, got: \\(error)\")\n2293-                return\n2294-            }\n2295-        }\n--\n2394-\n2395-        // Create new database instance pointing to same file\n2396-        let dbPath = (testDir as NSString).appendingPathComponent(\"mail.db\")\n2397:        let database2 = MailDatabase(databasePath: dbPath)\n2398-\n2399-        // Run migrations again - should be safe\n2400-        try database2.initialize()\n--\n2410-    func testMigrationHandlesEmptyDatabase() throws {\n2411-        // Start with no database file\n2412-        let dbPath = (testDir as NSString).appendingPathComponent(\"fresh.db\")\n2413:        let freshDatabase = MailDatabase(databasePath: dbPath)\n2414-\n2415-        // Initialize should create all tables\n2416-        try freshDatabase.initialize()\n--\n2443-\n2444-        // Insert test data\n2445-        let message = MailMessage(\n2446:            id: \"migration-test-msg\",\n2447:            appleRowId: 54321,\n2448:            messageId: \"<migration-test@example.com>\",\n2449:            mailboxId: 1,\n2450:            mailboxName: \"INBOX\",\n2451:            subject: \"Migration Test Message\",\n2452:            senderName: \"Test Sender\",\n2453:            senderEmail: \"test@example.com\"\n2454-        )\n2455-        try database.upsertMessage(message)\n2456-\n2457-        let thread = Thread(\n2458:            id: \"migration-test-thread\",\n2459:            subject: \"Migration Test Thread\",\n2460:            participantCount: 2,\n2461:            messageCount: 1\n2462-        )\n2463-        try database.upsertThread(thread)\n2464-\n--\n2466-        database.close()\n2467-\n2468-        let dbPath = (testDir as NSString).appendingPathComponent(\"mail.db\")\n2469:        let database2 = MailDatabase(databasePath: dbPath)\n2470-        try database2.initialize()\n2471-\n2472-        // Verify data is preserved\n2473:        let retrievedMessage = try database2.getMessage(id: \"migration-test-msg\")\n2474-        XCTAssertNotNil(retrievedMessage, \"Message should be preserved after migration\")\n2475-        XCTAssertEqual(retrievedMessage?.subject, \"Migration Test Message\")\n2476-\n2477:        let retrievedThread = try database2.getThread(id: \"migration-test-thread\")\n2478-        XCTAssertNotNil(retrievedThread, \"Thread should be preserved after migration\")\n2479-        XCTAssertEqual(retrievedThread?.subject, \"Migration Test Thread\")\n2480-","numLines":2060}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018gjKoZjVmMmdLWSwpY5XZv","type":"message","role":"assistant","content":[{"type":"text","text":"Let me look for tests that use colon in a query string that isn't a valid filter:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1172,"cache_read_input_tokens":39653,"cache_creation":{"ephemeral_5m_input_tokens":1172,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"2930f9a3-c270-4b5d-8975-6a7848228a32"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018gjKoZjVmMmdLWSwpY5XZv","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NjUMBUmdpnN7saTEpmWNAy","name":"Grep","input":{"pattern":"searchMessages.*:.*\\\"|searchMessagesWithFilters.*:.*\\\"","path":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests","output_mode":"content","-n":true}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1172,"cache_read_input_tokens":39653,"cache_creation":{"ephemeral_5m_input_tokens":1172,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"1e4da91a-937c-429d-a047-2f5d2fae303b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NjUMBUmdpnN7saTEpmWNAy","type":"tool_result","content":"Tests/SwiftEAKitTests/MailDatabaseTests.swift:187:        let results = try database.searchMessages(query: \"alpha\")\nTests/SwiftEAKitTests/MailDatabaseTests.swift:200:        let results = try database.searchMessages(query: \"nonexistent\")\nTests/SwiftEAKitTests/MailDatabaseTests.swift:214:        let results = try database.searchMessages(query: \"keyword\", limit: 5)\nTests/SwiftEAKitTests/MailDatabaseTests.swift:229:        let results = try database.searchMessages(query: \"'\")\nTests/SwiftEAKitTests/MailDatabaseTests.swift:242:        let results = try database.searchMessages(query: \"\\\"\")\nTests/SwiftEAKitTests/MailDatabaseTests.swift:253:        let results = try database.searchMessages(query: \"OR 1=1 --\")\nTests/SwiftEAKitTests/MailDatabaseTests.swift:266:        XCTAssertNoThrow(try database.searchMessages(query: \"AND\"))\nTests/SwiftEAKitTests/MailDatabaseTests.swift:267:        XCTAssertNoThrow(try database.searchMessages(query: \"OR\"))\nTests/SwiftEAKitTests/MailDatabaseTests.swift:268:        XCTAssertNoThrow(try database.searchMessages(query: \"NOT\"))\nTests/SwiftEAKitTests/MailDatabaseTests.swift:269:        XCTAssertNoThrow(try database.searchMessages(query: \"NEAR\"))\nTests/SwiftEAKitTests/MailDatabaseTests.swift:281:            XCTAssertNoThrow(try database.searchMessages(query: char), \"Search should not crash for character: \\(char)\")\nTests/SwiftEAKitTests/MailDatabaseTests.swift:292:        let results = try database.searchMessages(query: \"Can't say \\\"hello\\\"\")\nTests/SwiftEAKitTests/MailDatabaseTests.swift:303:        let results = try database.searchMessages(query: \"\")\nTests/SwiftEAKitTests/MailDatabaseTests.swift:307:        let results2 = try database.searchMessages(query: \"   \")\nTests/SwiftEAKitTests/MailSyncTests.swift:410:        let searchResults = try mailDatabase.searchMessages(query: \"simple test\")"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"af5610a4-0236-4b88-a538-f799b54c725c","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"Tests/SwiftEAKitTests/MailDatabaseTests.swift:187:        let results = try database.searchMessages(query: \"alpha\")\nTests/SwiftEAKitTests/MailDatabaseTests.swift:200:        let results = try database.searchMessages(query: \"nonexistent\")\nTests/SwiftEAKitTests/MailDatabaseTests.swift:214:        let results = try database.searchMessages(query: \"keyword\", limit: 5)\nTests/SwiftEAKitTests/MailDatabaseTests.swift:229:        let results = try database.searchMessages(query: \"'\")\nTests/SwiftEAKitTests/MailDatabaseTests.swift:242:        let results = try database.searchMessages(query: \"\\\"\")\nTests/SwiftEAKitTests/MailDatabaseTests.swift:253:        let results = try database.searchMessages(query: \"OR 1=1 --\")\nTests/SwiftEAKitTests/MailDatabaseTests.swift:266:        XCTAssertNoThrow(try database.searchMessages(query: \"AND\"))\nTests/SwiftEAKitTests/MailDatabaseTests.swift:267:        XCTAssertNoThrow(try database.searchMessages(query: \"OR\"))\nTests/SwiftEAKitTests/MailDatabaseTests.swift:268:        XCTAssertNoThrow(try database.searchMessages(query: \"NOT\"))\nTests/SwiftEAKitTests/MailDatabaseTests.swift:269:        XCTAssertNoThrow(try database.searchMessages(query: \"NEAR\"))\nTests/SwiftEAKitTests/MailDatabaseTests.swift:281:            XCTAssertNoThrow(try database.searchMessages(query: char), \"Search should not crash for character: \\(char)\")\nTests/SwiftEAKitTests/MailDatabaseTests.swift:292:        let results = try database.searchMessages(query: \"Can't say \\\"hello\\\"\")\nTests/SwiftEAKitTests/MailDatabaseTests.swift:303:        let results = try database.searchMessages(query: \"\")\nTests/SwiftEAKitTests/MailDatabaseTests.swift:307:        let results2 = try database.searchMessages(query: \"   \")\nTests/SwiftEAKitTests/MailSyncTests.swift:410:        let searchResults = try mailDatabase.searchMessages(query: \"simple test\")","numLines":15}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_013Nx96PRRfV9E5JSn32fyTE","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me understand the actual issue. The error message says `no such column: badfilter`. This happens in FTS5 when a query tries to search a non-existent column. In FTS5, `column:term` syntax is used to search only within a specific column.\n\nThe escape function wraps everything in double quotes, which should make it a literal phrase search. Let me trace through the exact flow to understand where the crash happens.\n\nNow, the key issue is that `parseQuery` treats `badfilter:value` as freeText since `badfilter:` doesn't match any known filter pattern. Then it goes to FTS5 search where `escapeFts5Query` wraps it in quotes.\n\nLet me look at this more carefully. The issue might be that the escape is not being applied correctly, OR there's a code path that doesn't use the escape. Let me check `searchMessages` vs `searchMessagesWithFilters`."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":781,"cache_read_input_tokens":40825,"cache_creation":{"ephemeral_5m_input_tokens":781,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"0b7aa767-2289-471b-8a8f-a2290f2a3f28"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_013Nx96PRRfV9E5JSn32fyTE","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GuBRcQGYP8yKyRNrrJjvck","name":"Read","input":{"file_path":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift","offset":643,"limit":30}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":781,"cache_read_input_tokens":40825,"cache_creation":{"ephemeral_5m_input_tokens":781,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"c2e3d14d-7a3f-4f09-9d6c-4411608f4eb2"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GuBRcQGYP8yKyRNrrJjvck","type":"tool_result","content":"   643â†’    /// Search messages using FTS\n   644â†’    public func searchMessages(query: String, limit: Int = 50, offset: Int = 0) throws -> [MailMessage] {\n   645â†’        guard let conn = connection else {\n   646â†’            throw MailDatabaseError.notInitialized\n   647â†’        }\n   648â†’\n   649â†’        let result = try conn.query(\"\"\"\n   650â†’            SELECT m.* FROM messages m\n   651â†’            JOIN messages_fts fts ON m.rowid = fts.rowid\n   652â†’            WHERE messages_fts MATCH '\\(escapeSql(escapeFts5Query(query)))'\n   653â†’            ORDER BY bm25(messages_fts)\n   654â†’            LIMIT \\(limit) OFFSET \\(offset)\n   655â†’            \"\"\")\n   656â†’\n   657â†’        var messages: [MailMessage] = []\n   658â†’        for row in result {\n   659â†’            if let message = try? rowToMessage(row) {\n   660â†’                messages.append(message)\n   661â†’            }\n   662â†’        }\n   663â†’        return messages\n   664â†’    }\n   665â†’\n   666â†’    // MARK: - Structured Query Search\n   667â†’\n   668â†’    /// Parsed filter from a structured query\n   669â†’    public struct SearchFilter {\n   670â†’        public var from: String?\n   671â†’        public var to: String?\n   672â†’        public var subject: String?\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"3b8823d7-4ec1-4b52-b9b7-8787216b2551","tool_use_result":{"type":"text","file":{"filePath":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift","content":"    /// Search messages using FTS\n    public func searchMessages(query: String, limit: Int = 50, offset: Int = 0) throws -> [MailMessage] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"\"\"\n            SELECT m.* FROM messages m\n            JOIN messages_fts fts ON m.rowid = fts.rowid\n            WHERE messages_fts MATCH '\\(escapeSql(escapeFts5Query(query)))'\n            ORDER BY bm25(messages_fts)\n            LIMIT \\(limit) OFFSET \\(offset)\n            \"\"\")\n\n        var messages: [MailMessage] = []\n        for row in result {\n            if let message = try? rowToMessage(row) {\n                messages.append(message)\n            }\n        }\n        return messages\n    }\n\n    // MARK: - Structured Query Search\n\n    /// Parsed filter from a structured query\n    public struct SearchFilter {\n        public var from: String?\n        public var to: String?\n        public var subject: String?","numLines":30,"startLine":643,"totalLines":2634}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018646TnosUnndyqwtfnQ8ag","type":"message","role":"assistant","content":[{"type":"text","text":"Both `searchMessages` and `searchMessagesWithFilters` use `escapeFts5Query`. The issue is that the user's request is for **validation of filter names** to give a helpful error message, not just crash prevention. Even if FTS5 doesn't crash (due to the quote escaping), the user experience is still poor because \"badfilter:value\" gets searched as literal text in the full-text index.\n\nActually, wait - re-reading the bug description:\n> Running `swea mail search \"badfilter:value\"` causes a fatal crash\n\nLet me write a test to verify whether the current code actually crashes or not with `badfilter:test`:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":793,"cache_read_input_tokens":41606,"cache_creation":{"ephemeral_5m_input_tokens":793,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"1ef07e72-5497-49dd-a529-d94455378c8b"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018646TnosUnndyqwtfnQ8ag","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BUhXyZztQQst3SRv1pxQgq","name":"Bash","input":{"command":"cd /Users/I852000/Library/Mobile\\ Documents/com~apple~CloudDocs/swiftea && swift test --filter \"testSearchWithSpecialCharacters\" 2>&1 | head -30","description":"Run the special characters test","timeout":120000}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":793,"cache_read_input_tokens":41606,"cache_creation":{"ephemeral_5m_input_tokens":793,"ephemeral_1h_input_tokens":0},"output_tokens":288,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"62aa16f9-ab16-4d13-8116-0366cd1900f0"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BUhXyZztQQst3SRv1pxQgq","type":"tool_result","content":"warning: 'swiftea': found 1 file(s) which are unhandled; explicitly declare them as resources or exclude from the target\n    /Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/CalendarModule/README.md\n[0/1] Planning build\n[1/1] Compiling plugin GenerateManual\n[2/2] Compiling plugin GenerateDoccReference\nBuilding for debugging...\n[2/6] Write swift-version--58304C5D6DBC2206.txt\nBuild complete! (0.45s)\nTest Suite 'Selected tests' started at 2026-01-15 19:16:03.058.\nTest Suite 'SwiftEAPackageTests.xctest' started at 2026-01-15 19:16:03.059.\nTest Suite 'MailDatabaseTests' started at 2026-01-15 19:16:03.059.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testSearchWithSpecialCharacters]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testSearchWithSpecialCharacters]' passed (0.027 seconds).\nTest Suite 'MailDatabaseTests' passed at 2026-01-15 19:16:03.086.\n\t Executed 1 test, with 0 failures (0 unexpected) in 0.027 (0.027) seconds\nTest Suite 'SwiftEAPackageTests.xctest' passed at 2026-01-15 19:16:03.086.\n\t Executed 1 test, with 0 failures (0 unexpected) in 0.027 (0.027) seconds\nTest Suite 'Selected tests' passed at 2026-01-15 19:16:03.086.\n\t Executed 1 test, with 0 failures (0 unexpected) in 0.027 (0.029) seconds\nâ—‡ Test run started.\nâ†³ Testing Library Version: 1501\nâ†³ Target Platform: arm64e-apple-macos14.0\nâœ” Test run with 0 tests in 0 suites passed after 0.001 seconds.","is_error":false}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"09d4600e-b0ae-4439-9755-95c4cd97e030","tool_use_result":{"stdout":"warning: 'swiftea': found 1 file(s) which are unhandled; explicitly declare them as resources or exclude from the target\n    /Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/CalendarModule/README.md\n[0/1] Planning build\n[1/1] Compiling plugin GenerateManual\n[2/2] Compiling plugin GenerateDoccReference\nBuilding for debugging...\n[2/6] Write swift-version--58304C5D6DBC2206.txt\nBuild complete! (0.45s)\nTest Suite 'Selected tests' started at 2026-01-15 19:16:03.058.\nTest Suite 'SwiftEAPackageTests.xctest' started at 2026-01-15 19:16:03.059.\nTest Suite 'MailDatabaseTests' started at 2026-01-15 19:16:03.059.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testSearchWithSpecialCharacters]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testSearchWithSpecialCharacters]' passed (0.027 seconds).\nTest Suite 'MailDatabaseTests' passed at 2026-01-15 19:16:03.086.\n\t Executed 1 test, with 0 failures (0 unexpected) in 0.027 (0.027) seconds\nTest Suite 'SwiftEAPackageTests.xctest' passed at 2026-01-15 19:16:03.086.\n\t Executed 1 test, with 0 failures (0 unexpected) in 0.027 (0.027) seconds\nTest Suite 'Selected tests' passed at 2026-01-15 19:16:03.086.\n\t Executed 1 test, with 0 failures (0 unexpected) in 0.027 (0.029) seconds\nâ—‡ Test run started.\nâ†³ Testing Library Version: 1501\nâ†³ Target Platform: arm64e-apple-macos14.0\nâœ” Test run with 0 tests in 0 suites passed after 0.001 seconds.","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01CndVzABmif5aGmraPz1feM","type":"message","role":"assistant","content":[{"type":"text","text":"Let me add a test specifically for `badfilter:` style queries and see if it crashes:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":851,"cache_read_input_tokens":42399,"cache_creation":{"ephemeral_5m_input_tokens":851,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"137a2f28-94bf-4db3-bdad-4af4760fd300"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01CndVzABmif5aGmraPz1feM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XKQXPtLtQv8YUpZ2S9ny5W","name":"Read","input":{"file_path":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift","offset":270,"limit":50}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":851,"cache_read_input_tokens":42399,"cache_creation":{"ephemeral_5m_input_tokens":851,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"6131d976-2945-4739-82ce-0615e77ef87f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XKQXPtLtQv8YUpZ2S9ny5W","type":"tool_result","content":"   270â†’    }\n   271â†’\n   272â†’    func testSearchWithSpecialCharacters() throws {\n   273â†’        try database.initialize()\n   274â†’\n   275â†’        let message = MailMessage(id: \"special-test\", subject: \"Special chars: * ( ) { } [ ]\")\n   276â†’        try database.upsertMessage(message)\n   277â†’\n   278â†’        // Various special characters should not crash\n   279â†’        let specialChars = [\"*\", \"(\", \")\", \"{\", \"}\", \"[\", \"]\", \"+\", \"-\", \"^\", \"~\"]\n   280â†’        for char in specialChars {\n   281â†’            XCTAssertNoThrow(try database.searchMessages(query: char), \"Search should not crash for character: \\(char)\")\n   282â†’        }\n   283â†’    }\n   284â†’\n   285â†’    func testSearchWithMixedSpecialCharacters() throws {\n   286â†’        try database.initialize()\n   287â†’\n   288â†’        let message = MailMessage(id: \"mixed-test\", subject: \"Can't say \\\"hello (world)\\\"\")\n   289â†’        try database.upsertMessage(message)\n   290â†’\n   291â†’        // Complex query with multiple special characters\n   292â†’        let results = try database.searchMessages(query: \"Can't say \\\"hello\\\"\")\n   293â†’        XCTAssertNotNil(results)\n   294â†’    }\n   295â†’\n   296â†’    func testSearchWithEmptyQuery() throws {\n   297â†’        try database.initialize()\n   298â†’\n   299â†’        let message = MailMessage(id: \"empty-test\", subject: \"Test message\")\n   300â†’        try database.upsertMessage(message)\n   301â†’\n   302â†’        // Empty query should not crash\n   303â†’        let results = try database.searchMessages(query: \"\")\n   304â†’        XCTAssertNotNil(results)\n   305â†’\n   306â†’        // Whitespace-only query should not crash\n   307â†’        let results2 = try database.searchMessages(query: \"   \")\n   308â†’        XCTAssertNotNil(results2)\n   309â†’    }\n   310â†’\n   311â†’    // MARK: - Export Path\n   312â†’\n   313â†’    func testUpdateExportPath() throws {\n   314â†’        try database.initialize()\n   315â†’\n   316â†’        let message = MailMessage(id: \"export-test\", subject: \"Export Test\")\n   317â†’        try database.upsertMessage(message)\n   318â†’\n   319â†’        try database.updateExportPath(id: \"export-test\", path: \"/exports/email.md\")\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"3fa1f37d-6075-455c-a942-d218d70de35c","tool_use_result":{"type":"text","file":{"filePath":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift","content":"    }\n\n    func testSearchWithSpecialCharacters() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"special-test\", subject: \"Special chars: * ( ) { } [ ]\")\n        try database.upsertMessage(message)\n\n        // Various special characters should not crash\n        let specialChars = [\"*\", \"(\", \")\", \"{\", \"}\", \"[\", \"]\", \"+\", \"-\", \"^\", \"~\"]\n        for char in specialChars {\n            XCTAssertNoThrow(try database.searchMessages(query: char), \"Search should not crash for character: \\(char)\")\n        }\n    }\n\n    func testSearchWithMixedSpecialCharacters() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"mixed-test\", subject: \"Can't say \\\"hello (world)\\\"\")\n        try database.upsertMessage(message)\n\n        // Complex query with multiple special characters\n        let results = try database.searchMessages(query: \"Can't say \\\"hello\\\"\")\n        XCTAssertNotNil(results)\n    }\n\n    func testSearchWithEmptyQuery() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"empty-test\", subject: \"Test message\")\n        try database.upsertMessage(message)\n\n        // Empty query should not crash\n        let results = try database.searchMessages(query: \"\")\n        XCTAssertNotNil(results)\n\n        // Whitespace-only query should not crash\n        let results2 = try database.searchMessages(query: \"   \")\n        XCTAssertNotNil(results2)\n    }\n\n    // MARK: - Export Path\n\n    func testUpdateExportPath() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"export-test\", subject: \"Export Test\")\n        try database.upsertMessage(message)\n\n        try database.updateExportPath(id: \"export-test\", path: \"/exports/email.md\")","numLines":50,"startLine":270,"totalLines":2484}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KeiqCxNC4ahRGzGi7XkZpB","type":"message","role":"assistant","content":[{"type":"text","text":"Let me write a quick test to see if \"badfilter:value\" crashes. I'll add a temporary test:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1077,"cache_read_input_tokens":43250,"cache_creation":{"ephemeral_5m_input_tokens":1077,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"6371a16c-0cba-4212-9ae7-d72313ab5ee8"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01KeiqCxNC4ahRGzGi7XkZpB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MLkNFPKg5nVNu2p7j9hT3B","name":"Bash","input":{"command":"cd /Users/I852000/Library/Mobile\\ Documents/com~apple~CloudDocs/swiftea && cat > /tmp/test_badfilter.swift << 'EOF'\nimport SwiftEAKit\nimport Foundation\n\nlet testDir = NSTemporaryDirectory() + \"swiftea-maildb-test-\\(UUID().uuidString)\"\ntry FileManager.default.createDirectory(atPath: testDir, withIntermediateDirectories: true)\n\nlet dbPath = (testDir as NSString).appendingPathComponent(\"mail.db\")\nlet database = MailDatabase(databasePath: dbPath)\ntry database.initialize()\n\n// Add a test message\nlet message = MailMessage(id: \"test-msg\", subject: \"Test message content\")\ntry database.upsertMessage(message)\n\n// Test with badfilter:value using searchMessages (direct FTS)\nprint(\"Testing searchMessages with badfilter:test...\")\ndo {\n    let results1 = try database.searchMessages(query: \"badfilter:test\")\n    print(\"searchMessages result count: \\(results1.count)\")\n} catch {\n    print(\"searchMessages threw: \\(error)\")\n}\n\n// Test with badfilter:value using parseQuery + searchMessagesWithFilters\nprint(\"\\nTesting parseQuery + searchMessagesWithFilters with badfilter:test...\")\nlet filter = database.parseQuery(\"badfilter:test\")\nprint(\"freeText: \\(filter.freeText ?? \"nil\")\")\ndo {\n    let results2 = try database.searchMessagesWithFilters(filter)\n    print(\"searchMessagesWithFilters result count: \\(results2.count)\")\n} catch {\n    print(\"searchMessagesWithFilters threw: \\(error)\")\n}\n\n// Clean up\ndatabase.close()\ntry FileManager.default.removeItem(atPath: testDir)\n\nprint(\"\\nDone - no crash!\")\nEOF\n\nswift -I .build/debug -L .build/debug -lSwiftEAKit /tmp/test_badfilter.swift 2>&1","description":"Test if badfilter:value crashes","timeout":120000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1077,"cache_read_input_tokens":43250,"cache_creation":{"ephemeral_5m_input_tokens":1077,"ephemeral_1h_input_tokens":0},"output_tokens":609,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"e904d67a-106b-4d17-b44d-87d14cb5ec67"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"Exit code 1\n/tmp/test_badfilter.swift:1:8: error: no such module 'SwiftEAKit'\n 1 | import SwiftEAKit\n   |        `- error: no such module 'SwiftEAKit'\n 2 | import Foundation\n 3 |","is_error":true,"tool_use_id":"toolu_01MLkNFPKg5nVNu2p7j9hT3B"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"2dac3e17-0b2e-4e66-bd57-7e5d508ae67a","tool_use_result":"Error: Exit code 1\n/tmp/test_badfilter.swift:1:8: error: no such module 'SwiftEAKit'\n 1 | import SwiftEAKit\n   |        `- error: no such module 'SwiftEAKit'\n 2 | import Foundation\n 3 |"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01FMQE2tiNK7ebEA9NFoLG67","type":"message","role":"assistant","content":[{"type":"text","text":"Let me run this as a proper test instead:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":704,"cache_read_input_tokens":44327,"cache_creation":{"ephemeral_5m_input_tokens":704,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"9a30abea-4bac-440d-8f61-7cebadb1555f"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01FMQE2tiNK7ebEA9NFoLG67","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RUjmukpYe5B4LrsJj1odKt","name":"Read","input":{"file_path":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift","offset":272,"limit":15}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":704,"cache_read_input_tokens":44327,"cache_creation":{"ephemeral_5m_input_tokens":704,"ephemeral_1h_input_tokens":0},"output_tokens":138,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"1ec60693-87ba-4535-bcb4-9ee0930523a1"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RUjmukpYe5B4LrsJj1odKt","type":"tool_result","content":"   272â†’    func testSearchWithSpecialCharacters() throws {\n   273â†’        try database.initialize()\n   274â†’\n   275â†’        let message = MailMessage(id: \"special-test\", subject: \"Special chars: * ( ) { } [ ]\")\n   276â†’        try database.upsertMessage(message)\n   277â†’\n   278â†’        // Various special characters should not crash\n   279â†’        let specialChars = [\"*\", \"(\", \")\", \"{\", \"}\", \"[\", \"]\", \"+\", \"-\", \"^\", \"~\"]\n   280â†’        for char in specialChars {\n   281â†’            XCTAssertNoThrow(try database.searchMessages(query: char), \"Search should not crash for character: \\(char)\")\n   282â†’        }\n   283â†’    }\n   284â†’\n   285â†’    func testSearchWithMixedSpecialCharacters() throws {\n   286â†’        try database.initialize()\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"2c598c6f-18ec-4e0d-9b01-17a459f4b0b8","tool_use_result":{"type":"text","file":{"filePath":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift","content":"    func testSearchWithSpecialCharacters() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"special-test\", subject: \"Special chars: * ( ) { } [ ]\")\n        try database.upsertMessage(message)\n\n        // Various special characters should not crash\n        let specialChars = [\"*\", \"(\", \")\", \"{\", \"}\", \"[\", \"]\", \"+\", \"-\", \"^\", \"~\"]\n        for char in specialChars {\n            XCTAssertNoThrow(try database.searchMessages(query: char), \"Search should not crash for character: \\(char)\")\n        }\n    }\n\n    func testSearchWithMixedSpecialCharacters() throws {\n        try database.initialize()","numLines":15,"startLine":272,"totalLines":2484}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01PymVM1qrCFLPMkTpstggTB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KqNUhcN65kdPqtQx71UiGE","name":"TodoWrite","input":{"todos":[{"content":"Find and analyze the mail search code","status":"completed","activeForm":"Finding and analyzing the mail search code"},{"content":"Add test for unknown filter names to verify current behavior","status":"in_progress","activeForm":"Adding test for unknown filter names"},{"content":"Implement graceful error handling for unknown filters","status":"pending","activeForm":"Implementing graceful error handling for unknown filters"},{"content":"Add user-friendly error message with valid filter list","status":"pending","activeForm":"Adding user-friendly error message with valid filter list"},{"content":"Run swift build and swift test","status":"pending","activeForm":"Running swift build and swift test"},{"content":"Commit and close the bead","status":"pending","activeForm":"Committing and closing the bead"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":452,"cache_read_input_tokens":45031,"cache_creation":{"ephemeral_5m_input_tokens":452,"ephemeral_1h_input_tokens":0},"output_tokens":257,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"646b2596-83d1-44c9-9985-ef903135a291"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KqNUhcN65kdPqtQx71UiGE","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"3da4c541-abba-449a-a203-ffaf4dc57084","tool_use_result":{"oldTodos":[{"content":"Find and analyze the mail search code","status":"in_progress","activeForm":"Finding and analyzing the mail search code"},{"content":"Implement graceful error handling for unknown filters","status":"pending","activeForm":"Implementing graceful error handling for unknown filters"},{"content":"Add user-friendly error message with valid filter list","status":"pending","activeForm":"Adding user-friendly error message with valid filter list"},{"content":"Run swift build and swift test","status":"pending","activeForm":"Running swift build and swift test"},{"content":"Commit and close the bead","status":"pending","activeForm":"Committing and closing the bead"}],"newTodos":[{"content":"Find and analyze the mail search code","status":"completed","activeForm":"Finding and analyzing the mail search code"},{"content":"Add test for unknown filter names to verify current behavior","status":"in_progress","activeForm":"Adding test for unknown filter names"},{"content":"Implement graceful error handling for unknown filters","status":"pending","activeForm":"Implementing graceful error handling for unknown filters"},{"content":"Add user-friendly error message with valid filter list","status":"pending","activeForm":"Adding user-friendly error message with valid filter list"},{"content":"Run swift build and swift test","status":"pending","activeForm":"Running swift build and swift test"},{"content":"Commit and close the bead","status":"pending","activeForm":"Committing and closing the bead"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_014Nyun2g5xMF3WrErWQFnGU","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0187BcgrACjkHbJLVBUBsa1s","name":"Edit","input":{"replace_all":false,"file_path":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift","old_string":"    func testSearchWithSpecialCharacters() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"special-test\", subject: \"Special chars: * ( ) { } [ ]\")\n        try database.upsertMessage(message)\n\n        // Various special characters should not crash\n        let specialChars = [\"*\", \"(\", \")\", \"{\", \"}\", \"[\", \"]\", \"+\", \"-\", \"^\", \"~\"]\n        for char in specialChars {\n            XCTAssertNoThrow(try database.searchMessages(query: char), \"Search should not crash for character: \\(char)\")\n        }\n    }","new_string":"    func testSearchWithSpecialCharacters() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"special-test\", subject: \"Special chars: * ( ) { } [ ]\")\n        try database.upsertMessage(message)\n\n        // Various special characters should not crash\n        let specialChars = [\"*\", \"(\", \")\", \"{\", \"}\", \"[\", \"]\", \"+\", \"-\", \"^\", \"~\"]\n        for char in specialChars {\n            XCTAssertNoThrow(try database.searchMessages(query: char), \"Search should not crash for character: \\(char)\")\n        }\n    }\n\n    func testSearchWithUnknownFilterName() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"filter-test\", subject: \"Test message for filter\")\n        try database.upsertMessage(message)\n\n        // Unknown filter names (badfilter:value format) should not crash\n        // This tests the FTS5 column prefix syntax handling\n        XCTAssertNoThrow(try database.searchMessages(query: \"badfilter:test\"), \"Search should not crash for unknown filter syntax\")\n        XCTAssertNoThrow(try database.searchMessages(query: \"unknown:value\"), \"Search should not crash for unknown filter syntax\")\n        XCTAssertNoThrow(try database.searchMessages(query: \"foo:bar baz:qux\"), \"Search should not crash for multiple unknown filters\")\n    }"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":299,"cache_read_input_tokens":45483,"cache_creation":{"ephemeral_5m_input_tokens":299,"ephemeral_1h_input_tokens":0},"output_tokens":631,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"473ee7b0-2f17-4cde-9e07-c47047a14a1f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0187BcgrACjkHbJLVBUBsa1s","type":"tool_result","content":"The file /Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   268â†’        XCTAssertNoThrow(try database.searchMessages(query: \"NOT\"))\n   269â†’        XCTAssertNoThrow(try database.searchMessages(query: \"NEAR\"))\n   270â†’    }\n   271â†’\n   272â†’    func testSearchWithSpecialCharacters() throws {\n   273â†’        try database.initialize()\n   274â†’\n   275â†’        let message = MailMessage(id: \"special-test\", subject: \"Special chars: * ( ) { } [ ]\")\n   276â†’        try database.upsertMessage(message)\n   277â†’\n   278â†’        // Various special characters should not crash\n   279â†’        let specialChars = [\"*\", \"(\", \")\", \"{\", \"}\", \"[\", \"]\", \"+\", \"-\", \"^\", \"~\"]\n   280â†’        for char in specialChars {\n   281â†’            XCTAssertNoThrow(try database.searchMessages(query: char), \"Search should not crash for character: \\(char)\")\n   282â†’        }\n   283â†’    }\n   284â†’\n   285â†’    func testSearchWithUnknownFilterName() throws {\n   286â†’        try database.initialize()\n   287â†’\n   288â†’        let message = MailMessage(id: \"filter-test\", subject: \"Test message for filter\")\n   289â†’        try database.upsertMessage(message)\n   290â†’\n   291â†’        // Unknown filter names (badfilter:value format) should not crash\n   292â†’        // This tests the FTS5 column prefix syntax handling\n   293â†’        XCTAssertNoThrow(try database.searchMessages(query: \"badfilter:test\"), \"Search should not crash for unknown filter syntax\")\n   294â†’        XCTAssertNoThrow(try database.searchMessages(query: \"unknown:value\"), \"Search should not crash for unknown filter syntax\")\n   295â†’        XCTAssertNoThrow(try database.searchMessages(query: \"foo:bar baz:qux\"), \"Search should not crash for multiple unknown filters\")\n   296â†’    }\n   297â†’\n   298â†’    func testSearchWithMixedSpecialCharacters() throws {\n   299â†’        try database.initialize()\n   300â†’"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"ba952eb7-63ba-4f3f-9004-00e413f5c190","tool_use_result":{"filePath":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift","oldString":"    func testSearchWithSpecialCharacters() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"special-test\", subject: \"Special chars: * ( ) { } [ ]\")\n        try database.upsertMessage(message)\n\n        // Various special characters should not crash\n        let specialChars = [\"*\", \"(\", \")\", \"{\", \"}\", \"[\", \"]\", \"+\", \"-\", \"^\", \"~\"]\n        for char in specialChars {\n            XCTAssertNoThrow(try database.searchMessages(query: char), \"Search should not crash for character: \\(char)\")\n        }\n    }","newString":"    func testSearchWithSpecialCharacters() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"special-test\", subject: \"Special chars: * ( ) { } [ ]\")\n        try database.upsertMessage(message)\n\n        // Various special characters should not crash\n        let specialChars = [\"*\", \"(\", \")\", \"{\", \"}\", \"[\", \"]\", \"+\", \"-\", \"^\", \"~\"]\n        for char in specialChars {\n            XCTAssertNoThrow(try database.searchMessages(query: char), \"Search should not crash for character: \\(char)\")\n        }\n    }\n\n    func testSearchWithUnknownFilterName() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"filter-test\", subject: \"Test message for filter\")\n        try database.upsertMessage(message)\n\n        // Unknown filter names (badfilter:value format) should not crash\n        // This tests the FTS5 column prefix syntax handling\n        XCTAssertNoThrow(try database.searchMessages(query: \"badfilter:test\"), \"Search should not crash for unknown filter syntax\")\n        XCTAssertNoThrow(try database.searchMessages(query: \"unknown:value\"), \"Search should not crash for unknown filter syntax\")\n        XCTAssertNoThrow(try database.searchMessages(query: \"foo:bar baz:qux\"), \"Search should not crash for multiple unknown filters\")\n    }","originalFile":"import XCTest\n@testable import SwiftEAKit\n\nfinal class MailDatabaseTests: XCTestCase {\n    var testDir: String!\n    var database: MailDatabase!\n\n    override func setUp() {\n        super.setUp()\n        testDir = NSTemporaryDirectory() + \"swiftea-maildb-test-\\(UUID().uuidString)\"\n        try? FileManager.default.createDirectory(atPath: testDir, withIntermediateDirectories: true)\n\n        let dbPath = (testDir as NSString).appendingPathComponent(\"mail.db\")\n        database = MailDatabase(databasePath: dbPath)\n    }\n\n    override func tearDown() {\n        database.close()\n        try? FileManager.default.removeItem(atPath: testDir)\n        database = nil\n        super.tearDown()\n    }\n\n    // MARK: - Initialization\n\n    func testInitializeCreatesDatabase() throws {\n        try database.initialize()\n\n        let dbPath = (testDir as NSString).appendingPathComponent(\"mail.db\")\n        XCTAssertTrue(FileManager.default.fileExists(atPath: dbPath))\n    }\n\n    func testInitializeTwiceSucceeds() throws {\n        try database.initialize()\n        try database.initialize() // Should not throw\n    }\n\n    // MARK: - Message CRUD\n\n    func testUpsertAndGetMessage() throws {\n        try database.initialize()\n\n        let message = MailMessage(\n            id: \"test-id-123\",\n            appleRowId: 12345,\n            messageId: \"<test@example.com>\",\n            mailboxId: 1,\n            mailboxName: \"INBOX\",\n            accountId: \"account-1\",\n            subject: \"Test Subject\",\n            senderName: \"John Doe\",\n            senderEmail: \"john@example.com\",\n            dateSent: Date(timeIntervalSince1970: 1736177400),\n            dateReceived: Date(timeIntervalSince1970: 1736177500),\n            isRead: true,\n            isFlagged: false,\n            isDeleted: false,\n            hasAttachments: true,\n            emlxPath: \"/path/to/12345.emlx\",\n            bodyText: \"This is the body text.\",\n            bodyHtml: nil\n        )\n\n        try database.upsertMessage(message)\n\n        let retrieved = try database.getMessage(id: \"test-id-123\")\n\n        XCTAssertNotNil(retrieved)\n        XCTAssertEqual(retrieved?.id, \"test-id-123\")\n        XCTAssertEqual(retrieved?.appleRowId, 12345)\n        XCTAssertEqual(retrieved?.messageId, \"<test@example.com>\")\n        XCTAssertEqual(retrieved?.mailboxId, 1)\n        XCTAssertEqual(retrieved?.mailboxName, \"INBOX\")\n        XCTAssertEqual(retrieved?.subject, \"Test Subject\")\n        XCTAssertEqual(retrieved?.senderName, \"John Doe\")\n        XCTAssertEqual(retrieved?.senderEmail, \"john@example.com\")\n        XCTAssertEqual(retrieved?.isRead, true)\n        XCTAssertEqual(retrieved?.isFlagged, false)\n        XCTAssertEqual(retrieved?.hasAttachments, true)\n        XCTAssertEqual(retrieved?.bodyText, \"This is the body text.\")\n    }\n\n    func testGetMessageByAppleRowId() throws {\n        try database.initialize()\n\n        let message = MailMessage(\n            id: \"row-test-id\",\n            appleRowId: 99999,\n            subject: \"Row Test\"\n        )\n\n        try database.upsertMessage(message)\n\n        let retrieved = try database.getMessage(appleRowId: 99999)\n\n        XCTAssertNotNil(retrieved)\n        XCTAssertEqual(retrieved?.id, \"row-test-id\")\n        XCTAssertEqual(retrieved?.appleRowId, 99999)\n    }\n\n    func testGetNonexistentMessageReturnsNil() throws {\n        try database.initialize()\n\n        let retrieved = try database.getMessage(id: \"nonexistent-id\")\n        XCTAssertNil(retrieved)\n    }\n\n    func testUpsertUpdatesExistingMessage() throws {\n        try database.initialize()\n\n        // Insert initial message\n        let message1 = MailMessage(\n            id: \"update-test\",\n            subject: \"Original Subject\",\n            isRead: false\n        )\n        try database.upsertMessage(message1)\n\n        // Update the message\n        let message2 = MailMessage(\n            id: \"update-test\",\n            subject: \"Updated Subject\",\n            isRead: true\n        )\n        try database.upsertMessage(message2)\n\n        let retrieved = try database.getMessage(id: \"update-test\")\n\n        XCTAssertEqual(retrieved?.subject, \"Updated Subject\")\n        XCTAssertEqual(retrieved?.isRead, true)\n    }\n\n    // MARK: - Special Characters\n\n    func testMessageWithSpecialCharactersInSubject() throws {\n        try database.initialize()\n\n        let message = MailMessage(\n            id: \"special-chars\",\n            subject: \"Test with 'quotes' and \\\"double\\\" and emoji ðŸŽ‰\"\n        )\n\n        try database.upsertMessage(message)\n\n        let retrieved = try database.getMessage(id: \"special-chars\")\n        XCTAssertEqual(retrieved?.subject, \"Test with 'quotes' and \\\"double\\\" and emoji ðŸŽ‰\")\n    }\n\n    func testMessageWithSqlInjectionAttempt() throws {\n        try database.initialize()\n\n        let message = MailMessage(\n            id: \"sql-inject\",\n            subject: \"Test'; DROP TABLE messages; --\"\n        )\n\n        try database.upsertMessage(message)\n\n        let retrieved = try database.getMessage(id: \"sql-inject\")\n        XCTAssertNotNil(retrieved)\n        XCTAssertEqual(retrieved?.subject, \"Test'; DROP TABLE messages; --\")\n\n        // Verify table still exists by inserting another message\n        let message2 = MailMessage(id: \"after-inject\", subject: \"After\")\n        try database.upsertMessage(message2)\n        let retrieved2 = try database.getMessage(id: \"after-inject\")\n        XCTAssertNotNil(retrieved2)\n    }\n\n    // MARK: - FTS Search\n\n    func testSearchMessages() throws {\n        try database.initialize()\n\n        // Insert multiple messages\n        let messages = [\n            MailMessage(id: \"search-1\", subject: \"Meeting about project Alpha\", senderEmail: \"alice@example.com\", bodyText: \"Let's discuss the alpha project timeline.\"),\n            MailMessage(id: \"search-2\", subject: \"Quarterly report\", senderEmail: \"bob@example.com\", bodyText: \"Q4 financial results attached.\"),\n            MailMessage(id: \"search-3\", subject: \"Re: Project Alpha update\", senderEmail: \"charlie@example.com\", bodyText: \"Great progress on alpha milestone.\")\n        ]\n\n        for msg in messages {\n            try database.upsertMessage(msg)\n        }\n\n        // Search for \"alpha\"\n        let results = try database.searchMessages(query: \"alpha\")\n\n        XCTAssertEqual(results.count, 2)\n        XCTAssertTrue(results.contains { $0.id == \"search-1\" })\n        XCTAssertTrue(results.contains { $0.id == \"search-3\" })\n    }\n\n    func testSearchWithNoResults() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"no-match\", subject: \"Hello world\")\n        try database.upsertMessage(message)\n\n        let results = try database.searchMessages(query: \"nonexistent\")\n\n        XCTAssertTrue(results.isEmpty)\n    }\n\n    func testSearchWithLimit() throws {\n        try database.initialize()\n\n        // Insert many messages\n        for i in 1...10 {\n            let msg = MailMessage(id: \"limit-\\(i)\", subject: \"Test subject \\(i)\", bodyText: \"Common keyword\")\n            try database.upsertMessage(msg)\n        }\n\n        let results = try database.searchMessages(query: \"keyword\", limit: 5)\n\n        XCTAssertEqual(results.count, 5)\n    }\n\n    // MARK: - FTS5 Special Character Handling\n\n    func testSearchWithSingleQuote() throws {\n        try database.initialize()\n\n        // Insert message containing a single quote\n        let message = MailMessage(id: \"quote-test\", subject: \"It's a test\", bodyText: \"Don't forget to check this.\")\n        try database.upsertMessage(message)\n\n        // Search for single quote - should not crash, should return empty or matching results\n        let results = try database.searchMessages(query: \"'\")\n        // The query should execute without throwing\n        XCTAssertNotNil(results)\n    }\n\n    func testSearchWithDoubleQuote() throws {\n        try database.initialize()\n\n        // Insert message containing double quotes\n        let message = MailMessage(id: \"dquote-test\", subject: \"He said \\\"hello\\\"\", bodyText: \"Test with quotes\")\n        try database.upsertMessage(message)\n\n        // Search for double quote - should not crash\n        let results = try database.searchMessages(query: \"\\\"\")\n        XCTAssertNotNil(results)\n    }\n\n    func testSearchWithSqlInjectionAttempt() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"sql-test\", subject: \"Normal email\")\n        try database.upsertMessage(message)\n\n        // SQL injection-like syntax should not crash or cause errors\n        let results = try database.searchMessages(query: \"OR 1=1 --\")\n        XCTAssertNotNil(results)\n        // Should return empty since this is treated as literal text, not SQL\n        XCTAssertTrue(results.isEmpty)\n    }\n\n    func testSearchWithFts5Operators() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"fts-test\", subject: \"Test AND or OR words\", bodyText: \"NOT near NEAR\")\n        try database.upsertMessage(message)\n\n        // FTS5 operators (AND, OR, NOT, NEAR) should be treated as literal text\n        XCTAssertNoThrow(try database.searchMessages(query: \"AND\"))\n        XCTAssertNoThrow(try database.searchMessages(query: \"OR\"))\n        XCTAssertNoThrow(try database.searchMessages(query: \"NOT\"))\n        XCTAssertNoThrow(try database.searchMessages(query: \"NEAR\"))\n    }\n\n    func testSearchWithSpecialCharacters() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"special-test\", subject: \"Special chars: * ( ) { } [ ]\")\n        try database.upsertMessage(message)\n\n        // Various special characters should not crash\n        let specialChars = [\"*\", \"(\", \")\", \"{\", \"}\", \"[\", \"]\", \"+\", \"-\", \"^\", \"~\"]\n        for char in specialChars {\n            XCTAssertNoThrow(try database.searchMessages(query: char), \"Search should not crash for character: \\(char)\")\n        }\n    }\n\n    func testSearchWithMixedSpecialCharacters() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"mixed-test\", subject: \"Can't say \\\"hello (world)\\\"\")\n        try database.upsertMessage(message)\n\n        // Complex query with multiple special characters\n        let results = try database.searchMessages(query: \"Can't say \\\"hello\\\"\")\n        XCTAssertNotNil(results)\n    }\n\n    func testSearchWithEmptyQuery() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"empty-test\", subject: \"Test message\")\n        try database.upsertMessage(message)\n\n        // Empty query should not crash\n        let results = try database.searchMessages(query: \"\")\n        XCTAssertNotNil(results)\n\n        // Whitespace-only query should not crash\n        let results2 = try database.searchMessages(query: \"   \")\n        XCTAssertNotNil(results2)\n    }\n\n    // MARK: - Export Path\n\n    func testUpdateExportPath() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"export-test\", subject: \"Export Test\")\n        try database.upsertMessage(message)\n\n        try database.updateExportPath(id: \"export-test\", path: \"/exports/email.md\")\n\n        let retrieved = try database.getMessage(id: \"export-test\")\n        XCTAssertEqual(retrieved?.exportPath, \"/exports/email.md\")\n    }\n\n    // MARK: - Update Message Body (On-Demand Fetching)\n\n    func testUpdateMessageBodyWithBothTextAndHtml() throws {\n        try database.initialize()\n\n        // Insert message without body\n        let message = MailMessage(\n            id: \"body-update-test\",\n            subject: \"Body Update Test\",\n            bodyText: nil,\n            bodyHtml: nil\n        )\n        try database.upsertMessage(message)\n\n        // Verify body is initially nil\n        let initialRetrieved = try database.getMessage(id: \"body-update-test\")\n        XCTAssertNil(initialRetrieved?.bodyText)\n        XCTAssertNil(initialRetrieved?.bodyHtml)\n\n        // Update body\n        try database.updateMessageBody(\n            id: \"body-update-test\",\n            bodyText: \"Plain text body\",\n            bodyHtml: \"<p>HTML body</p>\"\n        )\n\n        // Verify body was updated\n        let retrieved = try database.getMessage(id: \"body-update-test\")\n        XCTAssertEqual(retrieved?.bodyText, \"Plain text body\")\n        XCTAssertEqual(retrieved?.bodyHtml, \"<p>HTML body</p>\")\n    }\n\n    func testUpdateMessageBodyTextOnly() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"text-only-test\", subject: \"Text Only Test\")\n        try database.upsertMessage(message)\n\n        try database.updateMessageBody(\n            id: \"text-only-test\",\n            bodyText: \"Only plain text\",\n            bodyHtml: nil\n        )\n\n        let retrieved = try database.getMessage(id: \"text-only-test\")\n        XCTAssertEqual(retrieved?.bodyText, \"Only plain text\")\n        XCTAssertNil(retrieved?.bodyHtml)\n    }\n\n    func testUpdateMessageBodyHtmlOnly() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"html-only-test\", subject: \"HTML Only Test\")\n        try database.upsertMessage(message)\n\n        try database.updateMessageBody(\n            id: \"html-only-test\",\n            bodyText: nil,\n            bodyHtml: \"<html><body>HTML content</body></html>\"\n        )\n\n        let retrieved = try database.getMessage(id: \"html-only-test\")\n        XCTAssertNil(retrieved?.bodyText)\n        XCTAssertEqual(retrieved?.bodyHtml, \"<html><body>HTML content</body></html>\")\n    }\n\n    func testUpdateMessageBodyWithSpecialCharacters() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"special-body-test\", subject: \"Special Body Test\")\n        try database.upsertMessage(message)\n\n        // Body with SQL-injection-like content and special characters\n        let bodyText = \"Test with 'quotes' and \\\"double quotes\\\" and emoji ðŸŽ‰ and O'Brien's code\"\n        let bodyHtml = \"<p>Test's \\\"content\\\" with <script>alert('xss')</script></p>\"\n\n        try database.updateMessageBody(\n            id: \"special-body-test\",\n            bodyText: bodyText,\n            bodyHtml: bodyHtml\n        )\n\n        let retrieved = try database.getMessage(id: \"special-body-test\")\n        XCTAssertEqual(retrieved?.bodyText, bodyText)\n        XCTAssertEqual(retrieved?.bodyHtml, bodyHtml)\n    }\n\n    func testUpdateMessageBodyOverwritesExistingBody() throws {\n        try database.initialize()\n\n        // Insert message with initial body\n        let message = MailMessage(\n            id: \"overwrite-body-test\",\n            subject: \"Overwrite Body Test\",\n            bodyText: \"Original text\",\n            bodyHtml: \"<p>Original HTML</p>\"\n        )\n        try database.upsertMessage(message)\n\n        // Update body\n        try database.updateMessageBody(\n            id: \"overwrite-body-test\",\n            bodyText: \"New text\",\n            bodyHtml: \"<p>New HTML</p>\"\n        )\n\n        let retrieved = try database.getMessage(id: \"overwrite-body-test\")\n        XCTAssertEqual(retrieved?.bodyText, \"New text\")\n        XCTAssertEqual(retrieved?.bodyHtml, \"<p>New HTML</p>\")\n    }\n\n    func testUpdateMessageBodyBeforeInitializeThrows() throws {\n        // Don't call initialize()\n        XCTAssertThrowsError(try database.updateMessageBody(id: \"test\", bodyText: \"text\", bodyHtml: nil)) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected MailDatabaseError.notInitialized, got \\(error)\")\n                return\n            }\n        }\n    }\n\n    // MARK: - Sync Status\n\n    func testSetAndGetSyncStatus() throws {\n        try database.initialize()\n\n        try database.setSyncStatus(key: \"test_key\", value: \"test_value\")\n\n        let value = try database.getSyncStatus(key: \"test_key\")\n        XCTAssertEqual(value, \"test_value\")\n    }\n\n    func testGetNonexistentSyncStatus() throws {\n        try database.initialize()\n\n        let value = try database.getSyncStatus(key: \"nonexistent_key\")\n        XCTAssertNil(value)\n    }\n\n    func testUpdateSyncStatus() throws {\n        try database.initialize()\n\n        try database.setSyncStatus(key: \"update_key\", value: \"original\")\n        try database.setSyncStatus(key: \"update_key\", value: \"updated\")\n\n        let value = try database.getSyncStatus(key: \"update_key\")\n        XCTAssertEqual(value, \"updated\")\n    }\n\n    func testSetAndGetLastSyncTime() throws {\n        try database.initialize()\n\n        let syncTime = Date(timeIntervalSince1970: 1736177400)\n        try database.setLastSyncTime(syncTime)\n\n        let retrieved = try database.getLastSyncTime()\n        XCTAssertNotNil(retrieved)\n        XCTAssertEqual(retrieved!.timeIntervalSince1970, 1736177400, accuracy: 1.0)\n    }\n\n    func testGetLastSyncTimeWhenNotSet() throws {\n        try database.initialize()\n\n        let retrieved = try database.getLastSyncTime()\n        XCTAssertNil(retrieved)\n    }\n\n    // MARK: - Sync Status Tracking\n\n    func testRecordSyncStart() throws {\n        try database.initialize()\n\n        try database.recordSyncStart(isIncremental: true)\n\n        let summary = try database.getSyncStatusSummary()\n        XCTAssertEqual(summary.state, .running)\n        XCTAssertNotNil(summary.lastSyncStartTime)\n        XCTAssertEqual(summary.isIncremental, true)\n        XCTAssertNil(summary.lastSyncError)\n    }\n\n    func testRecordSyncSuccess() throws {\n        try database.initialize()\n\n        try database.recordSyncStart(isIncremental: false)\n\n        let result = SyncResult(\n            messagesProcessed: 100,\n            messagesAdded: 50,\n            messagesUpdated: 30,\n            messagesDeleted: 5,\n            messagesUnchanged: 15,\n            mailboxesProcessed: 10,\n            errors: [],\n            duration: 5.5,\n            isIncremental: false\n        )\n\n        try database.recordSyncSuccess(result: result)\n\n        let summary = try database.getSyncStatusSummary()\n        XCTAssertEqual(summary.state, .success)\n        XCTAssertNotNil(summary.lastSyncTime)\n        XCTAssertNotNil(summary.lastSyncEndTime)\n        XCTAssertEqual(summary.messagesAdded, 50)\n        XCTAssertEqual(summary.messagesUpdated, 30)\n        XCTAssertEqual(summary.messagesDeleted, 5)\n        XCTAssertNotNil(summary.duration)\n        XCTAssertEqual(summary.duration!, 5.5, accuracy: 0.01)\n        XCTAssertNil(summary.lastSyncError)\n    }\n\n    func testRecordSyncFailure() throws {\n        try database.initialize()\n\n        try database.recordSyncStart(isIncremental: true)\n\n        let error = NSError(domain: \"MailSync\", code: 1, userInfo: [\n            NSLocalizedDescriptionKey: \"Test sync failure\"\n        ])\n        try database.recordSyncFailure(error: error)\n\n        let summary = try database.getSyncStatusSummary()\n        XCTAssertEqual(summary.state, .failed)\n        XCTAssertNotNil(summary.lastSyncEndTime)\n        XCTAssertNotNil(summary.lastSyncError)\n        XCTAssertTrue(summary.lastSyncError?.contains(\"Test sync failure\") ?? false)\n    }\n\n    func testGetSyncStatusSummaryWhenNoSync() throws {\n        try database.initialize()\n\n        let summary = try database.getSyncStatusSummary()\n        XCTAssertEqual(summary.state, .idle)\n        XCTAssertNil(summary.lastSyncTime)\n        XCTAssertNil(summary.lastSyncStartTime)\n        XCTAssertNil(summary.lastSyncEndTime)\n        XCTAssertNil(summary.lastSyncError)\n        XCTAssertEqual(summary.messagesAdded, 0)\n        XCTAssertEqual(summary.messagesUpdated, 0)\n        XCTAssertEqual(summary.messagesDeleted, 0)\n    }\n\n    func testSyncStatusClearsErrorOnSuccess() throws {\n        try database.initialize()\n\n        // First, record a failure\n        try database.recordSyncStart(isIncremental: true)\n        let error = NSError(domain: \"MailSync\", code: 1, userInfo: [\n            NSLocalizedDescriptionKey: \"Previous failure\"\n        ])\n        try database.recordSyncFailure(error: error)\n\n        // Then record success\n        try database.recordSyncStart(isIncremental: false)\n        let result = SyncResult(\n            messagesProcessed: 10,\n            messagesAdded: 10,\n            messagesUpdated: 0,\n            mailboxesProcessed: 1,\n            errors: [],\n            duration: 1.0\n        )\n        try database.recordSyncSuccess(result: result)\n\n        let summary = try database.getSyncStatusSummary()\n        XCTAssertEqual(summary.state, .success)\n        XCTAssertNil(summary.lastSyncError)\n    }\n\n    // MARK: - Mailbox Operations\n\n    func testUpsertAndGetMailboxes() throws {\n        try database.initialize()\n\n        let mailboxes = [\n            Mailbox(id: 1, accountId: \"account-1\", name: \"INBOX\", fullPath: \"INBOX\", messageCount: 100, unreadCount: 10),\n            Mailbox(id: 2, accountId: \"account-1\", name: \"Sent\", fullPath: \"Sent\", messageCount: 50, unreadCount: 0),\n            Mailbox(id: 3, accountId: \"account-1\", name: \"Archive\", fullPath: \"Archive\", parentId: nil, messageCount: 200, unreadCount: 0)\n        ]\n\n        for mailbox in mailboxes {\n            try database.upsertMailbox(mailbox)\n        }\n\n        let retrieved = try database.getMailboxes()\n\n        XCTAssertEqual(retrieved.count, 3)\n        XCTAssertTrue(retrieved.contains { $0.name == \"INBOX\" && $0.messageCount == 100 })\n        XCTAssertTrue(retrieved.contains { $0.name == \"Sent\" && $0.messageCount == 50 })\n    }\n\n    func testUpdateMailbox() throws {\n        try database.initialize()\n\n        let mailbox1 = Mailbox(id: 1, accountId: \"account-1\", name: \"INBOX\", fullPath: \"INBOX\", messageCount: 100, unreadCount: 10)\n        try database.upsertMailbox(mailbox1)\n\n        let mailbox2 = Mailbox(id: 1, accountId: \"account-1\", name: \"INBOX\", fullPath: \"INBOX\", messageCount: 150, unreadCount: 5)\n        try database.upsertMailbox(mailbox2)\n\n        let retrieved = try database.getMailboxes()\n\n        XCTAssertEqual(retrieved.count, 1)\n        XCTAssertEqual(retrieved.first?.messageCount, 150)\n        XCTAssertEqual(retrieved.first?.unreadCount, 5)\n    }\n\n    // MARK: - Error Handling\n\n    func testOperationsBeforeInitializeThrow() throws {\n        // Don't call initialize()\n\n        XCTAssertThrowsError(try database.getMessage(id: \"test\")) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected MailDatabaseError.notInitialized, got \\(error)\")\n                return\n            }\n        }\n    }\n\n    // MARK: - Data Model Tests\n\n    func testMailMessageInitialization() {\n        let message = MailMessage(\n            id: \"msg-1\",\n            appleRowId: 123,\n            messageId: \"<msg@test.com>\",\n            mailboxId: 1,\n            mailboxName: \"INBOX\",\n            accountId: \"acc-1\",\n            subject: \"Test\",\n            senderName: \"Sender\",\n            senderEmail: \"sender@test.com\",\n            dateSent: Date(),\n            dateReceived: Date(),\n            isRead: true,\n            isFlagged: true,\n            isDeleted: false,\n            hasAttachments: true,\n            emlxPath: \"/path/to.emlx\",\n            bodyText: \"Body\",\n            bodyHtml: \"<p>Body</p>\",\n            exportPath: \"/export/path\"\n        )\n\n        XCTAssertEqual(message.id, \"msg-1\")\n        XCTAssertEqual(message.appleRowId, 123)\n        XCTAssertEqual(message.subject, \"Test\")\n        XCTAssertTrue(message.isRead)\n        XCTAssertTrue(message.isFlagged)\n        XCTAssertTrue(message.hasAttachments)\n    }\n\n    func testMailMessageDefaults() {\n        let message = MailMessage(id: \"minimal\", subject: \"Minimal\")\n\n        XCTAssertNil(message.appleRowId)\n        XCTAssertNil(message.messageId)\n        XCTAssertFalse(message.isRead)\n        XCTAssertFalse(message.isFlagged)\n        XCTAssertFalse(message.isDeleted)\n        XCTAssertFalse(message.hasAttachments)\n    }\n\n    func testMailboxInitialization() {\n        let mailbox = Mailbox(\n            id: 1,\n            accountId: \"acc-1\",\n            name: \"INBOX\",\n            fullPath: \"INBOX\",\n            parentId: nil,\n            messageCount: 100,\n            unreadCount: 10\n        )\n\n        XCTAssertEqual(mailbox.id, 1)\n        XCTAssertEqual(mailbox.accountId, \"acc-1\")\n        XCTAssertEqual(mailbox.name, \"INBOX\")\n        XCTAssertEqual(mailbox.messageCount, 100)\n        XCTAssertEqual(mailbox.unreadCount, 10)\n    }\n\n    func testMailAttachmentInitialization() {\n        let attachment = MailAttachment(\n            id: 1,\n            messageId: \"msg-1\",\n            filename: \"doc.pdf\",\n            mimeType: \"application/pdf\",\n            size: 1024,\n            contentId: \"cid123\",\n            isInline: false\n        )\n\n        XCTAssertEqual(attachment.id, 1)\n        XCTAssertEqual(attachment.messageId, \"msg-1\")\n        XCTAssertEqual(attachment.filename, \"doc.pdf\")\n        XCTAssertEqual(attachment.mimeType, \"application/pdf\")\n        XCTAssertEqual(attachment.size, 1024)\n        XCTAssertFalse(attachment.isInline)\n    }\n\n    // MARK: - Error Description Tests\n\n    func testMailDatabaseErrorDescriptions() {\n        let errors: [MailDatabaseError] = [\n            .connectionFailed(underlying: NSError(domain: \"test\", code: 1)),\n            .migrationFailed(underlying: NSError(domain: \"test\", code: 2)),\n            .queryFailed(underlying: NSError(domain: \"test\", code: 3)),\n            .notInitialized\n        ]\n\n        for error in errors {\n            XCTAssertNotNil(error.errorDescription, \"Error should have description\")\n            XCTAssertFalse(error.errorDescription!.isEmpty)\n        }\n    }\n\n    // MARK: - Close and Reopen\n\n    func testCloseAndReopenDatabase() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"persist-test\", subject: \"Persist\")\n        try database.upsertMessage(message)\n\n        database.close()\n\n        // Create new database instance\n        let dbPath = (testDir as NSString).appendingPathComponent(\"mail.db\")\n        let newDatabase = MailDatabase(databasePath: dbPath)\n        try newDatabase.initialize()\n\n        let retrieved = try newDatabase.getMessage(id: \"persist-test\")\n        XCTAssertNotNil(retrieved)\n        XCTAssertEqual(retrieved?.subject, \"Persist\")\n\n        newDatabase.close()\n    }\n\n    // MARK: - Batch Insert Tests\n\n    func testBatchUpsertMessagesInsertsAll() throws {\n        try database.initialize()\n\n        let messages = (1...100).map { i in\n            MailMessage(\n                id: \"batch-\\(i)\",\n                appleRowId: i,\n                subject: \"Batch Test \\(i)\",\n                senderEmail: \"sender\\(i)@example.com\",\n                isRead: i % 2 == 0,\n                isFlagged: i % 3 == 0\n            )\n        }\n\n        let result = try database.batchUpsertMessages(messages)\n\n        XCTAssertEqual(result.inserted, 100)\n        XCTAssertEqual(result.updated, 0)\n        XCTAssertEqual(result.failed, 0)\n        XCTAssertTrue(result.errors.isEmpty)\n        XCTAssertGreaterThan(result.duration, 0)\n\n        // Verify messages were inserted\n        let retrieved1 = try database.getMessage(id: \"batch-1\")\n        XCTAssertNotNil(retrieved1)\n        XCTAssertEqual(retrieved1?.subject, \"Batch Test 1\")\n\n        let retrieved50 = try database.getMessage(id: \"batch-50\")\n        XCTAssertNotNil(retrieved50)\n        XCTAssertEqual(retrieved50?.subject, \"Batch Test 50\")\n\n        let retrieved100 = try database.getMessage(id: \"batch-100\")\n        XCTAssertNotNil(retrieved100)\n        XCTAssertEqual(retrieved100?.subject, \"Batch Test 100\")\n    }\n\n    func testBatchUpsertMessagesUpdatesExisting() throws {\n        try database.initialize()\n\n        // Insert initial messages\n        let initialMessages = (1...50).map { i in\n            MailMessage(id: \"batch-\\(i)\", subject: \"Initial \\(i)\")\n        }\n        _ = try database.batchUpsertMessages(initialMessages)\n\n        // Update with new messages (some new, some updates)\n        let updateMessages = (25...75).map { i in\n            MailMessage(id: \"batch-\\(i)\", subject: \"Updated \\(i)\")\n        }\n\n        let result = try database.batchUpsertMessages(updateMessages)\n\n        // 25-50 are updates (26 messages), 51-75 are inserts (25 messages)\n        XCTAssertEqual(result.inserted, 25)\n        XCTAssertEqual(result.updated, 26)\n        XCTAssertEqual(result.failed, 0)\n\n        // Verify updates\n        let retrieved25 = try database.getMessage(id: \"batch-25\")\n        XCTAssertEqual(retrieved25?.subject, \"Updated 25\")\n\n        let retrieved50 = try database.getMessage(id: \"batch-50\")\n        XCTAssertEqual(retrieved50?.subject, \"Updated 50\")\n\n        // Verify original unchanged\n        let retrieved1 = try database.getMessage(id: \"batch-1\")\n        XCTAssertEqual(retrieved1?.subject, \"Initial 1\")\n    }\n\n    func testBatchUpsertMessagesWithCustomBatchSize() throws {\n        try database.initialize()\n\n        let messages = (1...500).map { i in\n            MailMessage(id: \"custom-batch-\\(i)\", subject: \"Custom Batch \\(i)\")\n        }\n\n        // Use small batch size\n        let config = MailDatabase.BatchInsertConfig(batchSize: 50)\n        let result = try database.batchUpsertMessages(messages, config: config)\n\n        XCTAssertEqual(result.inserted, 500)\n        XCTAssertEqual(result.updated, 0)\n        XCTAssertEqual(result.failed, 0)\n\n        // Verify all were inserted\n        let retrieved = try database.getMessage(id: \"custom-batch-250\")\n        XCTAssertNotNil(retrieved)\n        XCTAssertEqual(retrieved?.subject, \"Custom Batch 250\")\n    }\n\n    func testBatchUpsertMessagesDefaultConfig() {\n        let config = MailDatabase.BatchInsertConfig.default\n        XCTAssertEqual(config.batchSize, 1000)\n    }\n\n    func testBatchUpsertMessagesConfigMinimumBatchSize() {\n        let config = MailDatabase.BatchInsertConfig(batchSize: 0)\n        XCTAssertEqual(config.batchSize, 1)\n\n        let negativeConfig = MailDatabase.BatchInsertConfig(batchSize: -10)\n        XCTAssertEqual(negativeConfig.batchSize, 1)\n    }\n\n    func testBatchUpsertMessagesEmptyArray() throws {\n        try database.initialize()\n\n        let result = try database.batchUpsertMessages([])\n\n        XCTAssertEqual(result.inserted, 0)\n        XCTAssertEqual(result.updated, 0)\n        XCTAssertEqual(result.failed, 0)\n        XCTAssertTrue(result.errors.isEmpty)\n    }\n\n    func testBatchUpsertMessagesWithSpecialCharacters() throws {\n        try database.initialize()\n\n        let messages = [\n            MailMessage(id: \"special-1\", subject: \"Test with 'single quotes'\"),\n            MailMessage(id: \"special-2\", subject: \"Test with \\\"double quotes\\\"\"),\n            MailMessage(id: \"special-3\", subject: \"Test with emoji ðŸŽ‰\"),\n            MailMessage(id: \"special-4\", subject: \"Test'; DROP TABLE messages; --\")\n        ]\n\n        let result = try database.batchUpsertMessages(messages)\n\n        XCTAssertEqual(result.inserted, 4)\n        XCTAssertEqual(result.failed, 0)\n\n        let retrieved1 = try database.getMessage(id: \"special-1\")\n        XCTAssertEqual(retrieved1?.subject, \"Test with 'single quotes'\")\n\n        let retrieved4 = try database.getMessage(id: \"special-4\")\n        XCTAssertEqual(retrieved4?.subject, \"Test'; DROP TABLE messages; --\")\n    }\n\n    func testBatchUpsertMessagesPerformance() throws {\n        try database.initialize()\n\n        // Create a large batch of messages\n        let messageCount = 1000\n        let messages = (1...messageCount).map { i in\n            MailMessage(\n                id: \"perf-\\(i)\",\n                appleRowId: i,\n                messageId: \"<perf\\(i)@test.com>\",\n                mailboxId: 1,\n                mailboxName: \"INBOX\",\n                accountId: \"acc-1\",\n                subject: \"Performance Test \\(i)\",\n                senderName: \"Sender \\(i)\",\n                senderEmail: \"sender\\(i)@test.com\",\n                dateSent: Date(),\n                dateReceived: Date(),\n                isRead: i % 2 == 0,\n                isFlagged: i % 5 == 0,\n                bodyText: \"This is the body text for message \\(i)\"\n            )\n        }\n\n        // Measure batch insert time\n        let startTime = Date()\n        let result = try database.batchUpsertMessages(messages)\n        let batchDuration = Date().timeIntervalSince(startTime)\n\n        XCTAssertEqual(result.inserted, messageCount)\n        XCTAssertEqual(result.failed, 0)\n\n        // Batch inserts should be fast (less than 5 seconds for 1000 messages)\n        XCTAssertLessThan(batchDuration, 5.0, \"Batch insert should complete in less than 5 seconds\")\n\n        // Log performance for reference\n        print(\"Batch insert of \\(messageCount) messages took \\(batchDuration) seconds\")\n        print(\"Rate: \\(Double(messageCount) / batchDuration) messages/second\")\n    }\n\n    func testBatchUpsertMailboxes() throws {\n        try database.initialize()\n\n        let mailboxes = [\n            Mailbox(id: 1, accountId: \"acc-1\", name: \"INBOX\", fullPath: \"INBOX\", messageCount: 100, unreadCount: 10),\n            Mailbox(id: 2, accountId: \"acc-1\", name: \"Sent\", fullPath: \"Sent\", messageCount: 50, unreadCount: 0),\n            Mailbox(id: 3, accountId: \"acc-1\", name: \"Archive\", fullPath: \"Archive\", messageCount: 200, unreadCount: 0)\n        ]\n\n        try database.batchUpsertMailboxes(mailboxes)\n\n        let retrieved = try database.getMailboxes()\n        XCTAssertEqual(retrieved.count, 3)\n        XCTAssertTrue(retrieved.contains { $0.name == \"INBOX\" && $0.messageCount == 100 })\n        XCTAssertTrue(retrieved.contains { $0.name == \"Sent\" && $0.messageCount == 50 })\n        XCTAssertTrue(retrieved.contains { $0.name == \"Archive\" && $0.messageCount == 200 })\n    }\n\n    func testBatchUpsertMailboxesUpdatesExisting() throws {\n        try database.initialize()\n\n        // Insert initial mailboxes\n        let initial = [\n            Mailbox(id: 1, accountId: \"acc-1\", name: \"INBOX\", fullPath: \"INBOX\", messageCount: 100, unreadCount: 10)\n        ]\n        try database.batchUpsertMailboxes(initial)\n\n        // Update mailbox\n        let updated = [\n            Mailbox(id: 1, accountId: \"acc-1\", name: \"INBOX\", fullPath: \"INBOX\", messageCount: 150, unreadCount: 5)\n        ]\n        try database.batchUpsertMailboxes(updated)\n\n        let retrieved = try database.getMailboxes()\n        XCTAssertEqual(retrieved.count, 1)\n        XCTAssertEqual(retrieved.first?.messageCount, 150)\n        XCTAssertEqual(retrieved.first?.unreadCount, 5)\n    }\n\n    func testBatchInsertResultInitialization() {\n        let result = MailDatabase.BatchInsertResult(\n            inserted: 10,\n            updated: 5,\n            failed: 2,\n            errors: [\"Error 1\", \"Error 2\"],\n            duration: 1.5\n        )\n\n        XCTAssertEqual(result.inserted, 10)\n        XCTAssertEqual(result.updated, 5)\n        XCTAssertEqual(result.failed, 2)\n        XCTAssertEqual(result.errors.count, 2)\n        XCTAssertEqual(result.duration, 1.5)\n    }\n\n    // MARK: - Migration V2 Tests (Mailbox Status Tracking)\n\n    func testMigrationV2CreatesMailboxStatusColumn() throws {\n        try database.initialize()\n\n        // Insert a message with default mailbox status\n        let message = MailMessage(id: \"v2-test-1\", subject: \"V2 Test\")\n        try database.upsertMessage(message)\n\n        // Retrieve and verify default mailbox_status is 'inbox'\n        let retrieved = try database.getMessage(id: \"v2-test-1\")\n        XCTAssertNotNil(retrieved)\n        XCTAssertEqual(retrieved?.mailboxStatus, .inbox)\n    }\n\n    func testMigrationV2CreatesPendingSyncActionColumn() throws {\n        try database.initialize()\n\n        // Insert a message without pending sync action\n        let message1 = MailMessage(id: \"v2-sync-1\", subject: \"No Action\")\n        try database.upsertMessage(message1)\n\n        let retrieved1 = try database.getMessage(id: \"v2-sync-1\")\n        XCTAssertNil(retrieved1?.pendingSyncAction)\n\n        // Insert a message with pending archive action\n        let message2 = MailMessage(\n            id: \"v2-sync-2\",\n            subject: \"With Archive Action\",\n            pendingSyncAction: .archive\n        )\n        try database.upsertMessage(message2)\n\n        let retrieved2 = try database.getMessage(id: \"v2-sync-2\")\n        XCTAssertEqual(retrieved2?.pendingSyncAction, .archive)\n\n        // Insert a message with pending delete action\n        let message3 = MailMessage(\n            id: \"v2-sync-3\",\n            subject: \"With Delete Action\",\n            pendingSyncAction: .delete\n        )\n        try database.upsertMessage(message3)\n\n        let retrieved3 = try database.getMessage(id: \"v2-sync-3\")\n        XCTAssertEqual(retrieved3?.pendingSyncAction, .delete)\n    }\n\n    func testMigrationV2CreatesLastKnownMailboxIdColumn() throws {\n        try database.initialize()\n\n        // Insert a message without last known mailbox id\n        let message1 = MailMessage(id: \"v2-mailbox-1\", subject: \"No Mailbox\")\n        try database.upsertMessage(message1)\n\n        let retrieved1 = try database.getMessage(id: \"v2-mailbox-1\")\n        XCTAssertNil(retrieved1?.lastKnownMailboxId)\n\n        // Insert a message with last known mailbox id\n        let message2 = MailMessage(\n            id: \"v2-mailbox-2\",\n            subject: \"With Mailbox\",\n            lastKnownMailboxId: 42\n        )\n        try database.upsertMessage(message2)\n\n        let retrieved2 = try database.getMessage(id: \"v2-mailbox-2\")\n        XCTAssertEqual(retrieved2?.lastKnownMailboxId, 42)\n    }\n\n    func testMailboxStatusEnumValues() {\n        XCTAssertEqual(MailboxStatus.inbox.rawValue, \"inbox\")\n        XCTAssertEqual(MailboxStatus.archived.rawValue, \"archived\")\n        XCTAssertEqual(MailboxStatus.deleted.rawValue, \"deleted\")\n\n        // Test parsing from raw value\n        XCTAssertEqual(MailboxStatus(rawValue: \"inbox\"), .inbox)\n        XCTAssertEqual(MailboxStatus(rawValue: \"archived\"), .archived)\n        XCTAssertEqual(MailboxStatus(rawValue: \"deleted\"), .deleted)\n        XCTAssertNil(MailboxStatus(rawValue: \"unknown\"))\n    }\n\n    func testSyncActionEnumValues() {\n        XCTAssertEqual(SyncAction.archive.rawValue, \"archive\")\n        XCTAssertEqual(SyncAction.delete.rawValue, \"delete\")\n\n        // Test parsing from raw value\n        XCTAssertEqual(SyncAction(rawValue: \"archive\"), .archive)\n        XCTAssertEqual(SyncAction(rawValue: \"delete\"), .delete)\n        XCTAssertNil(SyncAction(rawValue: \"unknown\"))\n    }\n\n    func testMessageWithAllV2Fields() throws {\n        try database.initialize()\n\n        let message = MailMessage(\n            id: \"v2-full-test\",\n            appleRowId: 12345,\n            mailboxId: 1,\n            mailboxName: \"INBOX\",\n            subject: \"Full V2 Test\",\n            mailboxStatus: .archived,\n            pendingSyncAction: .delete,\n            lastKnownMailboxId: 99\n        )\n\n        try database.upsertMessage(message)\n\n        let retrieved = try database.getMessage(id: \"v2-full-test\")\n        XCTAssertNotNil(retrieved)\n        XCTAssertEqual(retrieved?.mailboxStatus, .archived)\n        XCTAssertEqual(retrieved?.pendingSyncAction, .delete)\n        XCTAssertEqual(retrieved?.lastKnownMailboxId, 99)\n    }\n\n    func testExistingMessagesGetDefaultMailboxStatus() throws {\n        // This tests that existing messages (after migration) have mailbox_status = 'inbox'\n        try database.initialize()\n\n        // Insert a message using minimal fields (simulating pre-V2 message)\n        let message = MailMessage(id: \"pre-v2-msg\", subject: \"Pre-V2 Message\")\n        try database.upsertMessage(message)\n\n        let retrieved = try database.getMessage(id: \"pre-v2-msg\")\n        XCTAssertEqual(retrieved?.mailboxStatus, .inbox, \"Existing messages should default to inbox status\")\n    }\n\n    func testMailboxStatusUpdateOnUpsert() throws {\n        try database.initialize()\n\n        // Insert initial message\n        let message1 = MailMessage(\n            id: \"status-update-test\",\n            subject: \"Initial\",\n            mailboxStatus: .inbox\n        )\n        try database.upsertMessage(message1)\n\n        // Update to archived\n        let message2 = MailMessage(\n            id: \"status-update-test\",\n            subject: \"Initial\",\n            mailboxStatus: .archived\n        )\n        try database.upsertMessage(message2)\n\n        let retrieved = try database.getMessage(id: \"status-update-test\")\n        XCTAssertEqual(retrieved?.mailboxStatus, .archived)\n    }\n\n    func testBatchUpsertWithV2Fields() throws {\n        try database.initialize()\n\n        let messages = [\n            MailMessage(id: \"batch-v2-1\", subject: \"Batch 1\", mailboxStatus: .inbox),\n            MailMessage(id: \"batch-v2-2\", subject: \"Batch 2\", mailboxStatus: .archived, pendingSyncAction: .archive),\n            MailMessage(id: \"batch-v2-3\", subject: \"Batch 3\", mailboxStatus: .deleted, pendingSyncAction: .delete, lastKnownMailboxId: 5)\n        ]\n\n        let result = try database.batchUpsertMessages(messages)\n        XCTAssertEqual(result.inserted, 3)\n        XCTAssertEqual(result.failed, 0)\n\n        let retrieved1 = try database.getMessage(id: \"batch-v2-1\")\n        XCTAssertEqual(retrieved1?.mailboxStatus, .inbox)\n        XCTAssertNil(retrieved1?.pendingSyncAction)\n\n        let retrieved2 = try database.getMessage(id: \"batch-v2-2\")\n        XCTAssertEqual(retrieved2?.mailboxStatus, .archived)\n        XCTAssertEqual(retrieved2?.pendingSyncAction, .archive)\n\n        let retrieved3 = try database.getMessage(id: \"batch-v2-3\")\n        XCTAssertEqual(retrieved3?.mailboxStatus, .deleted)\n        XCTAssertEqual(retrieved3?.pendingSyncAction, .delete)\n        XCTAssertEqual(retrieved3?.lastKnownMailboxId, 5)\n    }\n\n    func testMailMessageV2DefaultsInInit() {\n        let message = MailMessage(id: \"defaults-test\", subject: \"Defaults\")\n\n        XCTAssertEqual(message.mailboxStatus, .inbox, \"Default mailboxStatus should be inbox\")\n        XCTAssertNil(message.pendingSyncAction, \"Default pendingSyncAction should be nil\")\n        XCTAssertNil(message.lastKnownMailboxId, \"Default lastKnownMailboxId should be nil\")\n    }\n\n    // MARK: - US-002: Mailbox Status Query and Update Methods\n\n    func testUpdateMailboxStatus() throws {\n        try database.initialize()\n\n        // Insert a message\n        let message = MailMessage(id: \"status-test\", subject: \"Status Test\", mailboxStatus: .inbox)\n        try database.upsertMessage(message)\n\n        // Update status to archived\n        try database.updateMailboxStatus(id: \"status-test\", status: .archived)\n\n        let retrieved = try database.getMessage(id: \"status-test\")\n        XCTAssertEqual(retrieved?.mailboxStatus, .archived)\n\n        // Update status to deleted\n        try database.updateMailboxStatus(id: \"status-test\", status: .deleted)\n\n        let retrieved2 = try database.getMessage(id: \"status-test\")\n        XCTAssertEqual(retrieved2?.mailboxStatus, .deleted)\n\n        // Update back to inbox\n        try database.updateMailboxStatus(id: \"status-test\", status: .inbox)\n\n        let retrieved3 = try database.getMessage(id: \"status-test\")\n        XCTAssertEqual(retrieved3?.mailboxStatus, .inbox)\n    }\n\n    func testUpdateMailboxStatusNonexistentMessage() throws {\n        try database.initialize()\n\n        // This should not throw, it just won't update anything\n        try database.updateMailboxStatus(id: \"nonexistent\", status: .archived)\n\n        // Verify nothing was created\n        let retrieved = try database.getMessage(id: \"nonexistent\")\n        XCTAssertNil(retrieved)\n    }\n\n    func testSetPendingSyncAction() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"action-test\", subject: \"Action Test\")\n        try database.upsertMessage(message)\n\n        // Set archive action\n        try database.setPendingSyncAction(id: \"action-test\", action: .archive)\n\n        let retrieved = try database.getMessage(id: \"action-test\")\n        XCTAssertEqual(retrieved?.pendingSyncAction, .archive)\n\n        // Change to delete action\n        try database.setPendingSyncAction(id: \"action-test\", action: .delete)\n\n        let retrieved2 = try database.getMessage(id: \"action-test\")\n        XCTAssertEqual(retrieved2?.pendingSyncAction, .delete)\n    }\n\n    func testSetPendingSyncActionNonexistentMessage() throws {\n        try database.initialize()\n\n        // This should not throw, it just won't update anything\n        try database.setPendingSyncAction(id: \"nonexistent\", action: .archive)\n\n        // Verify nothing was created\n        let retrieved = try database.getMessage(id: \"nonexistent\")\n        XCTAssertNil(retrieved)\n    }\n\n    func testClearPendingSyncAction() throws {\n        try database.initialize()\n\n        // Insert a message with pending action\n        let message = MailMessage(\n            id: \"clear-action-test\",\n            subject: \"Clear Action Test\",\n            pendingSyncAction: .archive\n        )\n        try database.upsertMessage(message)\n\n        // Verify action is set\n        let retrieved1 = try database.getMessage(id: \"clear-action-test\")\n        XCTAssertEqual(retrieved1?.pendingSyncAction, .archive)\n\n        // Clear the action\n        try database.clearPendingSyncAction(id: \"clear-action-test\")\n\n        // Verify action is cleared\n        let retrieved2 = try database.getMessage(id: \"clear-action-test\")\n        XCTAssertNil(retrieved2?.pendingSyncAction)\n    }\n\n    func testClearPendingSyncActionNonexistentMessage() throws {\n        try database.initialize()\n\n        // This should not throw, it just won't update anything\n        try database.clearPendingSyncAction(id: \"nonexistent\")\n\n        // Verify nothing was created\n        let retrieved = try database.getMessage(id: \"nonexistent\")\n        XCTAssertNil(retrieved)\n    }\n\n    func testGetMessagesWithPendingActions() throws {\n        try database.initialize()\n\n        // Insert messages with and without pending actions\n        let messages = [\n            MailMessage(id: \"pending-1\", subject: \"Pending Archive\", pendingSyncAction: .archive),\n            MailMessage(id: \"pending-2\", subject: \"Pending Delete\", pendingSyncAction: .delete),\n            MailMessage(id: \"no-action\", subject: \"No Action\"),\n            MailMessage(id: \"pending-3\", subject: \"Another Archive\", pendingSyncAction: .archive)\n        ]\n\n        for msg in messages {\n            try database.upsertMessage(msg)\n        }\n\n        // Get messages with pending actions\n        let pending = try database.getMessagesWithPendingActions()\n\n        XCTAssertEqual(pending.count, 3)\n        XCTAssertTrue(pending.contains { $0.id == \"pending-1\" })\n        XCTAssertTrue(pending.contains { $0.id == \"pending-2\" })\n        XCTAssertTrue(pending.contains { $0.id == \"pending-3\" })\n        XCTAssertFalse(pending.contains { $0.id == \"no-action\" })\n    }\n\n    func testGetMessagesWithPendingActionsEmpty() throws {\n        try database.initialize()\n\n        // Insert messages without pending actions\n        let message = MailMessage(id: \"no-action\", subject: \"No Action\")\n        try database.upsertMessage(message)\n\n        let pending = try database.getMessagesWithPendingActions()\n\n        XCTAssertTrue(pending.isEmpty)\n    }\n\n    func testGetMessagesWithPendingActionsExcludesDeleted() throws {\n        try database.initialize()\n\n        // Insert a message with pending action but marked as deleted\n        let message = MailMessage(\n            id: \"deleted-pending\",\n            subject: \"Deleted with Action\",\n            isDeleted: true,\n            pendingSyncAction: .archive\n        )\n        try database.upsertMessage(message)\n\n        let pending = try database.getMessagesWithPendingActions()\n\n        XCTAssertTrue(pending.isEmpty, \"Deleted messages should not be returned\")\n    }\n\n    func testGetMessagesByStatus() throws {\n        try database.initialize()\n\n        // Insert messages with different statuses\n        let messages = [\n            MailMessage(id: \"inbox-1\", subject: \"Inbox 1\", mailboxStatus: .inbox),\n            MailMessage(id: \"inbox-2\", subject: \"Inbox 2\", mailboxStatus: .inbox),\n            MailMessage(id: \"archived-1\", subject: \"Archived 1\", mailboxStatus: .archived),\n            MailMessage(id: \"deleted-1\", subject: \"Deleted 1\", mailboxStatus: .deleted)\n        ]\n\n        for msg in messages {\n            try database.upsertMessage(msg)\n        }\n\n        // Get inbox messages\n        let inboxMessages = try database.getMessagesByStatus(.inbox)\n        XCTAssertEqual(inboxMessages.count, 2)\n        XCTAssertTrue(inboxMessages.allSatisfy { $0.mailboxStatus == .inbox })\n\n        // Get archived messages\n        let archivedMessages = try database.getMessagesByStatus(.archived)\n        XCTAssertEqual(archivedMessages.count, 1)\n        XCTAssertEqual(archivedMessages.first?.id, \"archived-1\")\n\n        // Get deleted messages\n        let deletedMessages = try database.getMessagesByStatus(.deleted)\n        XCTAssertEqual(deletedMessages.count, 1)\n        XCTAssertEqual(deletedMessages.first?.id, \"deleted-1\")\n    }\n\n    func testGetMessagesByStatusWithLimitAndOffset() throws {\n        try database.initialize()\n\n        // Insert many inbox messages\n        for i in 1...10 {\n            let message = MailMessage(\n                id: \"inbox-\\(i)\",\n                subject: \"Inbox \\(i)\",\n                dateReceived: Date(timeIntervalSince1970: Double(1000000 + i)),\n                mailboxStatus: .inbox\n            )\n            try database.upsertMessage(message)\n        }\n\n        // Get with limit\n        let limited = try database.getMessagesByStatus(.inbox, limit: 5)\n        XCTAssertEqual(limited.count, 5)\n\n        // Get with offset\n        let offset = try database.getMessagesByStatus(.inbox, limit: 5, offset: 5)\n        XCTAssertEqual(offset.count, 5)\n\n        // Verify no overlap\n        let limitedIds = Set(limited.map { $0.id })\n        let offsetIds = Set(offset.map { $0.id })\n        XCTAssertTrue(limitedIds.isDisjoint(with: offsetIds))\n    }\n\n    func testGetMessagesByStatusEmpty() throws {\n        try database.initialize()\n\n        // Insert inbox messages only\n        let message = MailMessage(id: \"inbox-only\", subject: \"Inbox\", mailboxStatus: .inbox)\n        try database.upsertMessage(message)\n\n        // Query for archived (should be empty)\n        let archived = try database.getMessagesByStatus(.archived)\n        XCTAssertTrue(archived.isEmpty)\n    }\n\n    func testGetMessagesByStatusExcludesDeleted() throws {\n        try database.initialize()\n\n        // Insert a message that's in inbox but soft-deleted\n        let message = MailMessage(\n            id: \"soft-deleted\",\n            subject: \"Soft Deleted\",\n            isDeleted: true,\n            mailboxStatus: .inbox\n        )\n        try database.upsertMessage(message)\n\n        let inboxMessages = try database.getMessagesByStatus(.inbox)\n\n        XCTAssertTrue(inboxMessages.isEmpty, \"Soft-deleted messages should not be returned\")\n    }\n\n    func testGetMessageCountByStatus() throws {\n        try database.initialize()\n\n        // Insert messages with different statuses\n        let messages = [\n            MailMessage(id: \"inbox-1\", subject: \"Inbox 1\", mailboxStatus: .inbox),\n            MailMessage(id: \"inbox-2\", subject: \"Inbox 2\", mailboxStatus: .inbox),\n            MailMessage(id: \"inbox-3\", subject: \"Inbox 3\", mailboxStatus: .inbox),\n            MailMessage(id: \"archived-1\", subject: \"Archived 1\", mailboxStatus: .archived),\n            MailMessage(id: \"archived-2\", subject: \"Archived 2\", mailboxStatus: .archived),\n            MailMessage(id: \"deleted-1\", subject: \"Deleted 1\", mailboxStatus: .deleted)\n        ]\n\n        for msg in messages {\n            try database.upsertMessage(msg)\n        }\n\n        let counts = try database.getMessageCountByStatus()\n\n        XCTAssertEqual(counts[.inbox], 3)\n        XCTAssertEqual(counts[.archived], 2)\n        XCTAssertEqual(counts[.deleted], 1)\n    }\n\n    func testGetMessageCountByStatusEmpty() throws {\n        try database.initialize()\n\n        let counts = try database.getMessageCountByStatus()\n\n        // All counts should be 0\n        XCTAssertEqual(counts[.inbox], 0)\n        XCTAssertEqual(counts[.archived], 0)\n        XCTAssertEqual(counts[.deleted], 0)\n    }\n\n    func testGetMessageCountByStatusExcludesSoftDeleted() throws {\n        try database.initialize()\n\n        // Insert a soft-deleted message\n        let message = MailMessage(\n            id: \"soft-deleted\",\n            subject: \"Soft Deleted\",\n            isDeleted: true,\n            mailboxStatus: .inbox\n        )\n        try database.upsertMessage(message)\n\n        let counts = try database.getMessageCountByStatus()\n\n        XCTAssertEqual(counts[.inbox], 0, \"Soft-deleted messages should not be counted\")\n    }\n\n    func testStatusMethodsBeforeInitializeThrow() throws {\n        // Don't call initialize()\n\n        XCTAssertThrowsError(try database.updateMailboxStatus(id: \"test\", status: .archived)) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n                return\n            }\n        }\n\n        XCTAssertThrowsError(try database.setPendingSyncAction(id: \"test\", action: .archive)) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n                return\n            }\n        }\n\n        XCTAssertThrowsError(try database.clearPendingSyncAction(id: \"test\")) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n                return\n            }\n        }\n\n        XCTAssertThrowsError(try database.getMessagesWithPendingActions()) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n                return\n            }\n        }\n\n        XCTAssertThrowsError(try database.getMessagesByStatus(.inbox)) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n                return\n            }\n        }\n\n        XCTAssertThrowsError(try database.getMessageCountByStatus()) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n                return\n            }\n        }\n    }\n\n    // MARK: - Migration V5: Thread-Messages Junction Table Tests\n\n    func testAddMessageToThread() throws {\n        try database.initialize()\n\n        // Create a thread and a message\n        let thread = Thread(id: \"thread-1\", subject: \"Test Thread\")\n        try database.upsertThread(thread)\n\n        let message = MailMessage(id: \"msg-1\", subject: \"Test Message\")\n        try database.upsertMessage(message)\n\n        // Add message to thread\n        try database.addMessageToThread(messageId: \"msg-1\", threadId: \"thread-1\")\n\n        // Verify the relationship exists\n        let messageIds = try database.getMessageIdsInThread(threadId: \"thread-1\")\n        XCTAssertEqual(messageIds.count, 1)\n        XCTAssertEqual(messageIds.first, \"msg-1\")\n    }\n\n    func testAddMessageToThreadDuplicateIgnored() throws {\n        try database.initialize()\n\n        // Create thread and message\n        let thread = Thread(id: \"thread-dup\", subject: \"Duplicate Test\")\n        try database.upsertThread(thread)\n\n        let message = MailMessage(id: \"msg-dup\", subject: \"Duplicate Message\")\n        try database.upsertMessage(message)\n\n        // Add same message twice - should not throw\n        try database.addMessageToThread(messageId: \"msg-dup\", threadId: \"thread-dup\")\n        try database.addMessageToThread(messageId: \"msg-dup\", threadId: \"thread-dup\")\n\n        // Should still only have one entry\n        let messageIds = try database.getMessageIdsInThread(threadId: \"thread-dup\")\n        XCTAssertEqual(messageIds.count, 1)\n    }\n\n    func testRemoveMessageFromThread() throws {\n        try database.initialize()\n\n        // Setup thread and message\n        let thread = Thread(id: \"thread-remove\", subject: \"Remove Test\")\n        try database.upsertThread(thread)\n\n        let message = MailMessage(id: \"msg-remove\", subject: \"To Be Removed\")\n        try database.upsertMessage(message)\n\n        try database.addMessageToThread(messageId: \"msg-remove\", threadId: \"thread-remove\")\n\n        // Verify it exists\n        var messageIds = try database.getMessageIdsInThread(threadId: \"thread-remove\")\n        XCTAssertEqual(messageIds.count, 1)\n\n        // Remove it\n        try database.removeMessageFromThread(messageId: \"msg-remove\", threadId: \"thread-remove\")\n\n        // Verify it's gone\n        messageIds = try database.getMessageIdsInThread(threadId: \"thread-remove\")\n        XCTAssertEqual(messageIds.count, 0)\n    }\n\n    func testRemoveNonexistentMessageFromThread() throws {\n        try database.initialize()\n\n        // Should not throw even if relationship doesn't exist\n        try database.removeMessageFromThread(messageId: \"nonexistent\", threadId: \"nonexistent\")\n    }\n\n    func testGetMessageIdsInThread() throws {\n        try database.initialize()\n\n        // Create thread and multiple messages\n        let thread = Thread(id: \"thread-multi\", subject: \"Multi Message Thread\")\n        try database.upsertThread(thread)\n\n        for i in 1...5 {\n            let message = MailMessage(id: \"multi-msg-\\(i)\", subject: \"Message \\(i)\")\n            try database.upsertMessage(message)\n            try database.addMessageToThread(messageId: \"multi-msg-\\(i)\", threadId: \"thread-multi\")\n        }\n\n        let messageIds = try database.getMessageIdsInThread(threadId: \"thread-multi\")\n        XCTAssertEqual(messageIds.count, 5)\n        for i in 1...5 {\n            XCTAssertTrue(messageIds.contains(\"multi-msg-\\(i)\"))\n        }\n    }\n\n    func testGetMessageIdsInThreadEmpty() throws {\n        try database.initialize()\n\n        let messageIds = try database.getMessageIdsInThread(threadId: \"nonexistent-thread\")\n        XCTAssertTrue(messageIds.isEmpty)\n    }\n\n    func testGetThreadIdsForMessage() throws {\n        try database.initialize()\n\n        // Create multiple threads and one message\n        for i in 1...3 {\n            let thread = Thread(id: \"multi-thread-\\(i)\", subject: \"Thread \\(i)\")\n            try database.upsertThread(thread)\n        }\n\n        let message = MailMessage(id: \"shared-msg\", subject: \"Shared Message\")\n        try database.upsertMessage(message)\n\n        // Add message to all threads\n        for i in 1...3 {\n            try database.addMessageToThread(messageId: \"shared-msg\", threadId: \"multi-thread-\\(i)\")\n        }\n\n        let threadIds = try database.getThreadIdsForMessage(messageId: \"shared-msg\")\n        XCTAssertEqual(threadIds.count, 3)\n        for i in 1...3 {\n            XCTAssertTrue(threadIds.contains(\"multi-thread-\\(i)\"))\n        }\n    }\n\n    func testGetThreadIdsForMessageEmpty() throws {\n        try database.initialize()\n\n        let threadIds = try database.getThreadIdsForMessage(messageId: \"nonexistent-message\")\n        XCTAssertTrue(threadIds.isEmpty)\n    }\n\n    func testGetMessagesInThreadViaJunction() throws {\n        try database.initialize()\n\n        // Create thread\n        let thread = Thread(id: \"full-thread\", subject: \"Full Thread Test\")\n        try database.upsertThread(thread)\n\n        // Create messages with different dates\n        let baseDate = Date(timeIntervalSince1970: 1000000)\n        for i in 1...3 {\n            let message = MailMessage(\n                id: \"full-msg-\\(i)\",\n                subject: \"Full Message \\(i)\",\n                dateReceived: Date(timeIntervalSince1970: baseDate.timeIntervalSince1970 + Double(i * 100))\n            )\n            try database.upsertMessage(message)\n            try database.addMessageToThread(messageId: \"full-msg-\\(i)\", threadId: \"full-thread\")\n        }\n\n        let messages = try database.getMessagesInThreadViaJunction(threadId: \"full-thread\")\n        XCTAssertEqual(messages.count, 3)\n\n        // Verify ordering by date_received ASC\n        XCTAssertEqual(messages[0].id, \"full-msg-1\")\n        XCTAssertEqual(messages[1].id, \"full-msg-2\")\n        XCTAssertEqual(messages[2].id, \"full-msg-3\")\n    }\n\n    func testGetMessagesInThreadViaJunctionExcludesDeleted() throws {\n        try database.initialize()\n\n        // Create thread\n        let thread = Thread(id: \"deleted-test-thread\", subject: \"Deleted Test\")\n        try database.upsertThread(thread)\n\n        // Create one normal message and one deleted message\n        let normalMsg = MailMessage(id: \"normal-msg\", subject: \"Normal\")\n        let deletedMsg = MailMessage(id: \"deleted-msg\", subject: \"Deleted\", isDeleted: true)\n\n        try database.upsertMessage(normalMsg)\n        try database.upsertMessage(deletedMsg)\n\n        try database.addMessageToThread(messageId: \"normal-msg\", threadId: \"deleted-test-thread\")\n        try database.addMessageToThread(messageId: \"deleted-msg\", threadId: \"deleted-test-thread\")\n\n        let messages = try database.getMessagesInThreadViaJunction(threadId: \"deleted-test-thread\")\n        XCTAssertEqual(messages.count, 1)\n        XCTAssertEqual(messages.first?.id, \"normal-msg\")\n    }\n\n    func testGetMessagesInThreadViaJunctionWithLimitAndOffset() throws {\n        try database.initialize()\n\n        let thread = Thread(id: \"paginated-thread\", subject: \"Paginated Thread\")\n        try database.upsertThread(thread)\n\n        // Create 10 messages\n        for i in 1...10 {\n            let message = MailMessage(\n                id: \"paginated-msg-\\(i)\",\n                subject: \"Message \\(i)\",\n                dateReceived: Date(timeIntervalSince1970: Double(1000000 + i))\n            )\n            try database.upsertMessage(message)\n            try database.addMessageToThread(messageId: \"paginated-msg-\\(i)\", threadId: \"paginated-thread\")\n        }\n\n        // Get first 5\n        let first5 = try database.getMessagesInThreadViaJunction(threadId: \"paginated-thread\", limit: 5)\n        XCTAssertEqual(first5.count, 5)\n\n        // Get next 5\n        let next5 = try database.getMessagesInThreadViaJunction(threadId: \"paginated-thread\", limit: 5, offset: 5)\n        XCTAssertEqual(next5.count, 5)\n\n        // Verify no overlap\n        let first5Ids = Set(first5.map { $0.id })\n        let next5Ids = Set(next5.map { $0.id })\n        XCTAssertTrue(first5Ids.isDisjoint(with: next5Ids))\n    }\n\n    func testGetThreadsForMessage() throws {\n        try database.initialize()\n\n        // Create threads with different dates\n        let baseDate = Date(timeIntervalSince1970: 1000000)\n        for i in 1...3 {\n            let thread = Thread(\n                id: \"msg-threads-\\(i)\",\n                subject: \"Thread \\(i)\",\n                lastDate: Date(timeIntervalSince1970: baseDate.timeIntervalSince1970 + Double(i * 100))\n            )\n            try database.upsertThread(thread)\n        }\n\n        let message = MailMessage(id: \"thread-query-msg\", subject: \"Query Message\")\n        try database.upsertMessage(message)\n\n        // Add message to all threads\n        for i in 1...3 {\n            try database.addMessageToThread(messageId: \"thread-query-msg\", threadId: \"msg-threads-\\(i)\")\n        }\n\n        let threads = try database.getThreadsForMessage(messageId: \"thread-query-msg\")\n        XCTAssertEqual(threads.count, 3)\n\n        // Verify ordering by last_date DESC\n        XCTAssertEqual(threads[0].id, \"msg-threads-3\")\n        XCTAssertEqual(threads[1].id, \"msg-threads-2\")\n        XCTAssertEqual(threads[2].id, \"msg-threads-1\")\n    }\n\n    func testGetThreadsForMessageEmpty() throws {\n        try database.initialize()\n\n        let threads = try database.getThreadsForMessage(messageId: \"nonexistent\")\n        XCTAssertTrue(threads.isEmpty)\n    }\n\n    func testGetMessageCountInThread() throws {\n        try database.initialize()\n\n        let thread = Thread(id: \"count-thread\", subject: \"Count Thread\")\n        try database.upsertThread(thread)\n\n        // Initially empty\n        var count = try database.getMessageCountInThread(threadId: \"count-thread\")\n        XCTAssertEqual(count, 0)\n\n        // Add messages\n        for i in 1...5 {\n            let message = MailMessage(id: \"count-msg-\\(i)\", subject: \"Count Message \\(i)\")\n            try database.upsertMessage(message)\n            try database.addMessageToThread(messageId: \"count-msg-\\(i)\", threadId: \"count-thread\")\n        }\n\n        count = try database.getMessageCountInThread(threadId: \"count-thread\")\n        XCTAssertEqual(count, 5)\n    }\n\n    func testGetMessageCountInThreadNonexistent() throws {\n        try database.initialize()\n\n        let count = try database.getMessageCountInThread(threadId: \"nonexistent\")\n        XCTAssertEqual(count, 0)\n    }\n\n    func testIsMessageInThread() throws {\n        try database.initialize()\n\n        let thread = Thread(id: \"check-thread\", subject: \"Check Thread\")\n        try database.upsertThread(thread)\n\n        let message = MailMessage(id: \"check-msg\", subject: \"Check Message\")\n        try database.upsertMessage(message)\n\n        // Initially not in thread\n        var inThread = try database.isMessageInThread(messageId: \"check-msg\", threadId: \"check-thread\")\n        XCTAssertFalse(inThread)\n\n        // Add to thread\n        try database.addMessageToThread(messageId: \"check-msg\", threadId: \"check-thread\")\n\n        // Now in thread\n        inThread = try database.isMessageInThread(messageId: \"check-msg\", threadId: \"check-thread\")\n        XCTAssertTrue(inThread)\n\n        // Remove from thread\n        try database.removeMessageFromThread(messageId: \"check-msg\", threadId: \"check-thread\")\n\n        // Not in thread anymore\n        inThread = try database.isMessageInThread(messageId: \"check-msg\", threadId: \"check-thread\")\n        XCTAssertFalse(inThread)\n    }\n\n    func testIsMessageInThreadNonexistent() throws {\n        try database.initialize()\n\n        let inThread = try database.isMessageInThread(messageId: \"nonexistent\", threadId: \"nonexistent\")\n        XCTAssertFalse(inThread)\n    }\n\n    func testThreadMessageForeignKeyConstraintOnThreadDelete() throws {\n        try database.initialize()\n\n        // Create thread and message\n        let thread = Thread(id: \"fk-thread\", subject: \"FK Thread\")\n        try database.upsertThread(thread)\n\n        let message = MailMessage(id: \"fk-msg\", subject: \"FK Message\")\n        try database.upsertMessage(message)\n\n        try database.addMessageToThread(messageId: \"fk-msg\", threadId: \"fk-thread\")\n\n        // Verify relationship exists\n        var messageIds = try database.getMessageIdsInThread(threadId: \"fk-thread\")\n        XCTAssertEqual(messageIds.count, 1)\n\n        // Note: SQLite's foreign key CASCADE delete would clean up thread_messages\n        // when the thread is deleted. However, we don't have a deleteThread method yet.\n        // This test verifies the junction table is working correctly.\n    }\n\n    func testManyToManyRelationship() throws {\n        try database.initialize()\n\n        // Create multiple threads\n        let threads = [\"thread-a\", \"thread-b\", \"thread-c\"]\n        for threadId in threads {\n            try database.upsertThread(Thread(id: threadId, subject: \"Thread \\(threadId)\"))\n        }\n\n        // Create multiple messages\n        let messages = [\"msg-1\", \"msg-2\", \"msg-3\"]\n        for msgId in messages {\n            try database.upsertMessage(MailMessage(id: msgId, subject: \"Message \\(msgId)\"))\n        }\n\n        // Create many-to-many relationships:\n        // msg-1 -> thread-a, thread-b\n        // msg-2 -> thread-b, thread-c\n        // msg-3 -> thread-a, thread-c\n        try database.addMessageToThread(messageId: \"msg-1\", threadId: \"thread-a\")\n        try database.addMessageToThread(messageId: \"msg-1\", threadId: \"thread-b\")\n        try database.addMessageToThread(messageId: \"msg-2\", threadId: \"thread-b\")\n        try database.addMessageToThread(messageId: \"msg-2\", threadId: \"thread-c\")\n        try database.addMessageToThread(messageId: \"msg-3\", threadId: \"thread-a\")\n        try database.addMessageToThread(messageId: \"msg-3\", threadId: \"thread-c\")\n\n        // Verify thread-a has msg-1 and msg-3\n        let threadAMessages = try database.getMessageIdsInThread(threadId: \"thread-a\")\n        XCTAssertEqual(threadAMessages.count, 2)\n        XCTAssertTrue(threadAMessages.contains(\"msg-1\"))\n        XCTAssertTrue(threadAMessages.contains(\"msg-3\"))\n\n        // Verify thread-b has msg-1 and msg-2\n        let threadBMessages = try database.getMessageIdsInThread(threadId: \"thread-b\")\n        XCTAssertEqual(threadBMessages.count, 2)\n        XCTAssertTrue(threadBMessages.contains(\"msg-1\"))\n        XCTAssertTrue(threadBMessages.contains(\"msg-2\"))\n\n        // Verify thread-c has msg-2 and msg-3\n        let threadCMessages = try database.getMessageIdsInThread(threadId: \"thread-c\")\n        XCTAssertEqual(threadCMessages.count, 2)\n        XCTAssertTrue(threadCMessages.contains(\"msg-2\"))\n        XCTAssertTrue(threadCMessages.contains(\"msg-3\"))\n\n        // Verify msg-1 is in thread-a and thread-b\n        let msg1Threads = try database.getThreadIdsForMessage(messageId: \"msg-1\")\n        XCTAssertEqual(msg1Threads.count, 2)\n        XCTAssertTrue(msg1Threads.contains(\"thread-a\"))\n        XCTAssertTrue(msg1Threads.contains(\"thread-b\"))\n    }\n\n    func testThreadMessageJunctionMethodsBeforeInitializeThrow() throws {\n        // Don't call initialize()\n\n        XCTAssertThrowsError(try database.addMessageToThread(messageId: \"test\", threadId: \"test\")) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n                return\n            }\n        }\n\n        XCTAssertThrowsError(try database.removeMessageFromThread(messageId: \"test\", threadId: \"test\")) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n                return\n            }\n        }\n\n        XCTAssertThrowsError(try database.getMessageIdsInThread(threadId: \"test\")) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n                return\n            }\n        }\n\n        XCTAssertThrowsError(try database.getThreadIdsForMessage(messageId: \"test\")) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n                return\n            }\n        }\n\n        XCTAssertThrowsError(try database.getMessagesInThreadViaJunction(threadId: \"test\")) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n                return\n            }\n        }\n\n        XCTAssertThrowsError(try database.getThreadsForMessage(messageId: \"test\")) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n                return\n            }\n        }\n\n        XCTAssertThrowsError(try database.getMessageCountInThread(threadId: \"test\")) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n                return\n            }\n        }\n\n        XCTAssertThrowsError(try database.isMessageInThread(messageId: \"test\", threadId: \"test\")) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n                return\n            }\n        }\n    }\n\n    // MARK: - US-004: Thread Index Tests\n\n    func testThreadIdIndexExistsOnMessagesTable() throws {\n        try database.initialize()\n\n        let indexes = try database.getIndexes(on: \"messages\")\n\n        XCTAssertTrue(indexes.contains(\"idx_messages_thread_id\"),\n                      \"Index idx_messages_thread_id should exist on messages table. Found: \\(indexes)\")\n    }\n\n    func testThreadsTableHasPrimaryKeyIndex() throws {\n        try database.initialize()\n\n        // SQLite automatically creates an index for the PRIMARY KEY\n        // We can verify this by checking the table info\n        let indexes = try database.getIndexes(on: \"threads\")\n\n        // The threads table should have an index on last_date\n        XCTAssertTrue(indexes.contains(\"idx_threads_last_date\"),\n                      \"Index idx_threads_last_date should exist on threads table. Found: \\(indexes)\")\n    }\n\n    func testThreadMessagesIndexesExist() throws {\n        try database.initialize()\n\n        let indexes = try database.getIndexes(on: \"thread_messages\")\n\n        XCTAssertTrue(indexes.contains(\"idx_thread_messages_thread_id\"),\n                      \"Index idx_thread_messages_thread_id should exist on thread_messages table. Found: \\(indexes)\")\n        XCTAssertTrue(indexes.contains(\"idx_thread_messages_message_id\"),\n                      \"Index idx_thread_messages_message_id should exist on thread_messages table. Found: \\(indexes)\")\n    }\n\n    func testExplainQueryPlanUsesThreadIdIndex() throws {\n        try database.initialize()\n\n        // Create thread first (required for foreign key constraint)\n        let thread = Thread(id: \"test-thread-id\", subject: \"Test Thread\")\n        try database.upsertThread(thread)\n\n        // Insert some test data to ensure table has data\n        let message = MailMessage(id: \"plan-test-msg\", subject: \"Plan Test\", threadId: \"test-thread-id\")\n        try database.upsertMessage(message)\n\n        // Query plan for looking up messages by thread_id\n        let plan = try database.explainQueryPlan(\n            \"SELECT * FROM messages WHERE thread_id = 'test-thread-id'\"\n        )\n\n        // The plan should show usage of the index\n        // SQLite's EXPLAIN QUERY PLAN typically shows \"SEARCH\" with index usage\n        let planString = plan.joined(separator: \" \")\n        XCTAssertTrue(\n            planString.contains(\"idx_messages_thread_id\") || planString.contains(\"USING INDEX\"),\n            \"Query should use idx_messages_thread_id index. Plan: \\(planString)\"\n        )\n    }\n\n    func testExplainQueryPlanUsesThreadMessagesIndex() throws {\n        try database.initialize()\n\n        // Insert test data\n        let thread = Thread(id: \"plan-thread\", subject: \"Plan Thread\")\n        try database.upsertThread(thread)\n        let message = MailMessage(id: \"plan-msg\", subject: \"Plan Message\")\n        try database.upsertMessage(message)\n        try database.addMessageToThread(messageId: \"plan-msg\", threadId: \"plan-thread\")\n\n        // Query plan for looking up messages in a thread via junction table\n        let plan = try database.explainQueryPlan(\n            \"SELECT message_id FROM thread_messages WHERE thread_id = 'plan-thread'\"\n        )\n\n        // The plan should show usage of an index (could be explicit index or autoindex for primary key)\n        // SQLite may use sqlite_autoindex_thread_messages_1 which is the covering index for the composite primary key\n        let planString = plan.joined(separator: \" \")\n        XCTAssertTrue(\n            planString.contains(\"idx_thread_messages_thread_id\") ||\n            planString.contains(\"USING INDEX\") ||\n            planString.contains(\"USING COVERING INDEX\") ||\n            planString.contains(\"sqlite_autoindex\"),\n            \"Query should use an index. Plan: \\(planString)\"\n        )\n    }\n\n    func testIndexVerificationMethodsBeforeInitializeThrow() throws {\n        // Don't call initialize()\n\n        XCTAssertThrowsError(try database.getIndexes(on: \"messages\")) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n                return\n            }\n        }\n\n        XCTAssertThrowsError(try database.explainQueryPlan(\"SELECT 1\")) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n                return\n            }\n        }\n    }\n\n    // MARK: - US-023: Large Inbox Query Optimization Tests\n\n    func testMigrationV7IndexesExist() throws {\n        try database.initialize()\n\n        // Verify indexes added in migration V7 for large inbox optimization\n        let threadIndexes = try database.getIndexes(on: \"threads\")\n        XCTAssertTrue(threadIndexes.contains(\"idx_threads_subject\"),\n                      \"Index idx_threads_subject should exist on threads table. Found: \\(threadIndexes)\")\n        XCTAssertTrue(threadIndexes.contains(\"idx_threads_message_count\"),\n                      \"Index idx_threads_message_count should exist on threads table. Found: \\(threadIndexes)\")\n\n        let messageIndexes = try database.getIndexes(on: \"messages\")\n        XCTAssertTrue(messageIndexes.contains(\"idx_messages_sender_email\"),\n                      \"Index idx_messages_sender_email should exist on messages table. Found: \\(messageIndexes)\")\n        XCTAssertTrue(messageIndexes.contains(\"idx_messages_thread_position\"),\n                      \"Index idx_messages_thread_position should exist on messages table. Found: \\(messageIndexes)\")\n\n        let recipientIndexes = try database.getIndexes(on: \"recipients\")\n        XCTAssertTrue(recipientIndexes.contains(\"idx_recipients_email\"),\n                      \"Index idx_recipients_email should exist on recipients table. Found: \\(recipientIndexes)\")\n    }\n\n    func testThreadListingUsesLastDateIndex() throws {\n        try database.initialize()\n\n        // Insert test data\n        let thread = Thread(id: \"perf-thread\", subject: \"Performance Test\")\n        try database.upsertThread(thread)\n\n        // Query plan for basic thread listing by date\n        let plan = try database.explainQueryPlan(\n            \"SELECT * FROM threads ORDER BY last_date DESC LIMIT 50\"\n        )\n\n        let planString = plan.joined(separator: \" \")\n        XCTAssertTrue(\n            planString.contains(\"idx_threads_last_date\") || planString.contains(\"USING INDEX\"),\n            \"Thread listing by date should use idx_threads_last_date. Plan: \\(planString)\"\n        )\n    }\n\n    func testThreadListingBySubjectUsesIndex() throws {\n        try database.initialize()\n\n        let thread = Thread(id: \"subj-thread\", subject: \"Subject Test\")\n        try database.upsertThread(thread)\n\n        // Query plan for thread listing by subject\n        let plan = try database.explainQueryPlan(\n            \"SELECT * FROM threads ORDER BY subject LIMIT 50\"\n        )\n\n        let planString = plan.joined(separator: \" \")\n        XCTAssertTrue(\n            planString.contains(\"idx_threads_subject\") || planString.contains(\"USING INDEX\") || planString.contains(\"SCAN\"),\n            \"Query should use idx_threads_subject or scan. Plan: \\(planString)\"\n        )\n    }\n\n    func testThreadListingByMessageCountUsesIndex() throws {\n        try database.initialize()\n\n        let thread = Thread(id: \"count-thread\", subject: \"Count Test\", messageCount: 5)\n        try database.upsertThread(thread)\n\n        // Query plan for thread listing by message count\n        let plan = try database.explainQueryPlan(\n            \"SELECT * FROM threads ORDER BY message_count DESC LIMIT 50\"\n        )\n\n        let planString = plan.joined(separator: \" \")\n        XCTAssertTrue(\n            planString.contains(\"idx_threads_message_count\") || planString.contains(\"USING INDEX\") || planString.contains(\"SCAN\"),\n            \"Query should use idx_threads_message_count or scan. Plan: \\(planString)\"\n        )\n    }\n\n    func testBatchThreadPositionUpdate() throws {\n        try database.initialize()\n\n        // Create a thread with 15 messages to trigger batch update\n        let thread = Thread(id: \"batch-thread\", subject: \"Batch Update Test\")\n        try database.upsertThread(thread)\n\n        for i in 1...15 {\n            let message = MailMessage(\n                id: \"batch-msg-\\(i)\",\n                subject: \"Message \\(i)\",\n                dateReceived: Date(timeIntervalSince1970: Double(1700000000 + i * 100)),\n                threadId: \"batch-thread\"\n            )\n            try database.upsertMessage(message)\n            try database.addMessageToThread(messageId: \"batch-msg-\\(i)\", threadId: \"batch-thread\")\n        }\n\n        // Update thread positions using batch update\n        try database.updateThreadPositions(threadId: \"batch-thread\")\n\n        // Verify positions were updated correctly\n        let messages = try database.getMessagesInThreadViaJunction(threadId: \"batch-thread\", limit: 100, offset: 0)\n        XCTAssertEqual(messages.count, 15)\n\n        for (index, message) in messages.enumerated() {\n            XCTAssertEqual(message.threadPosition, index + 1,\n                          \"Message \\(message.id) should have position \\(index + 1)\")\n            XCTAssertEqual(message.threadTotal, 15,\n                          \"Message \\(message.id) should have total 15\")\n        }\n    }\n\n    func testSmallThreadPositionUpdateUsesIndividualQueries() throws {\n        try database.initialize()\n\n        // Create a thread with 5 messages (below batch threshold of 10)\n        let thread = Thread(id: \"small-thread\", subject: \"Small Thread Test\")\n        try database.upsertThread(thread)\n\n        for i in 1...5 {\n            let message = MailMessage(\n                id: \"small-msg-\\(i)\",\n                subject: \"Message \\(i)\",\n                dateReceived: Date(timeIntervalSince1970: Double(1700000000 + i * 100)),\n                threadId: \"small-thread\"\n            )\n            try database.upsertMessage(message)\n            try database.addMessageToThread(messageId: \"small-msg-\\(i)\", threadId: \"small-thread\")\n        }\n\n        // Update thread positions\n        try database.updateThreadPositions(threadId: \"small-thread\")\n\n        // Verify positions were updated correctly\n        let messages = try database.getMessagesInThreadViaJunction(threadId: \"small-thread\", limit: 100, offset: 0)\n        XCTAssertEqual(messages.count, 5)\n\n        for (index, message) in messages.enumerated() {\n            XCTAssertEqual(message.threadPosition, index + 1)\n            XCTAssertEqual(message.threadTotal, 5)\n        }\n    }\n\n    func testEmptyThreadPositionUpdateDoesNothing() throws {\n        try database.initialize()\n\n        let thread = Thread(id: \"empty-thread\", subject: \"Empty Thread\")\n        try database.upsertThread(thread)\n\n        // Should not throw for empty thread\n        XCTAssertNoThrow(try database.updateThreadPositions(threadId: \"empty-thread\"))\n    }\n\n    func testThreadQueryWithPaginationBoundsMemory() throws {\n        try database.initialize()\n\n        // Create 100 threads\n        for i in 1...100 {\n            let thread = Thread(\n                id: \"page-thread-\\(i)\",\n                subject: \"Thread \\(i)\",\n                lastDate: Date(timeIntervalSince1970: Double(1700000000 + i * 100))\n            )\n            try database.upsertThread(thread)\n        }\n\n        // Get first page of 10\n        let page1 = try database.getThreads(limit: 10, offset: 0)\n        XCTAssertEqual(page1.count, 10, \"First page should have 10 threads\")\n\n        // Get second page of 10\n        let page2 = try database.getThreads(limit: 10, offset: 10)\n        XCTAssertEqual(page2.count, 10, \"Second page should have 10 threads\")\n\n        // Verify pages don't overlap\n        let page1Ids = Set(page1.map { $0.id })\n        let page2Ids = Set(page2.map { $0.id })\n        XCTAssertTrue(page1Ids.isDisjoint(with: page2Ids), \"Pages should not overlap\")\n    }\n\n    func testThreadDetailViewUsesIndexes() throws {\n        try database.initialize()\n\n        // Create thread with messages\n        let thread = Thread(id: \"detail-thread\", subject: \"Detail Test\")\n        try database.upsertThread(thread)\n\n        let message = MailMessage(id: \"detail-msg\", subject: \"Detail Message\", threadId: \"detail-thread\")\n        try database.upsertMessage(message)\n        try database.addMessageToThread(messageId: \"detail-msg\", threadId: \"detail-thread\")\n\n        // Query plan for thread detail (get messages in thread)\n        let plan = try database.explainQueryPlan(\n            \"SELECT m.* FROM messages m JOIN thread_messages tm ON m.id = tm.message_id WHERE tm.thread_id = 'detail-thread' ORDER BY m.date_received ASC\"\n        )\n\n        let planString = plan.joined(separator: \" \")\n        XCTAssertTrue(\n            planString.contains(\"idx_thread_messages_thread_id\") ||\n            planString.contains(\"USING INDEX\") ||\n            planString.contains(\"USING COVERING INDEX\") ||\n            planString.contains(\"sqlite_autoindex\"),\n            \"Thread detail query should use an index. Plan: \\(planString)\"\n        )\n    }\n\n    // MARK: - US-005: Database Migration Script Tests\n\n    func testGetSchemaVersionReturnsCurrentVersion() throws {\n        try database.initialize()\n\n        let version = try database.getSchemaVersion()\n        XCTAssertEqual(version, MailDatabase.currentSchemaVersion,\n                       \"Schema version should be \\(MailDatabase.currentSchemaVersion) after initialization\")\n    }\n\n    func testGetSchemaVersionBeforeInitializationThrows() {\n        // Database not initialized\n        XCTAssertThrowsError(try database.getSchemaVersion()) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected notInitialized error, got: \\(error)\")\n                return\n            }\n        }\n    }\n\n    func testMigrationHistoryContainsAllVersions() throws {\n        try database.initialize()\n\n        let history = try database.getMigrationHistory()\n\n        // Should have all migrations from V1 to current\n        XCTAssertEqual(history.count, MailDatabase.currentSchemaVersion,\n                       \"Migration history should have \\(MailDatabase.currentSchemaVersion) entries\")\n\n        // Verify each version is present\n        for version in 1...MailDatabase.currentSchemaVersion {\n            XCTAssertTrue(history.contains { $0.version == version },\n                          \"Migration history should contain version \\(version)\")\n        }\n\n        // Verify timestamps are present\n        for (_, appliedAt) in history {\n            XCTAssertFalse(appliedAt.isEmpty, \"Applied timestamp should not be empty\")\n        }\n    }\n\n    func testTableExistsForCoreThreadingTables() throws {\n        try database.initialize()\n\n        // Core tables that should exist after migration\n        XCTAssertTrue(try database.tableExists(\"messages\"), \"messages table should exist\")\n        XCTAssertTrue(try database.tableExists(\"threads\"), \"threads table should exist\")\n        XCTAssertTrue(try database.tableExists(\"thread_messages\"), \"thread_messages table should exist\")\n        XCTAssertTrue(try database.tableExists(\"recipients\"), \"recipients table should exist\")\n        XCTAssertTrue(try database.tableExists(\"attachments\"), \"attachments table should exist\")\n        XCTAssertTrue(try database.tableExists(\"mailboxes\"), \"mailboxes table should exist\")\n        XCTAssertTrue(try database.tableExists(\"schema_version\"), \"schema_version table should exist\")\n    }\n\n    func testTableExistsReturnsFalseForNonExistentTable() throws {\n        try database.initialize()\n\n        XCTAssertFalse(try database.tableExists(\"nonexistent_table\"),\n                       \"tableExists should return false for non-existent table\")\n    }\n\n    func testGetTableColumnsForMessages() throws {\n        try database.initialize()\n\n        let columns = try database.getTableColumns(\"messages\")\n\n        // Check core columns from V1\n        XCTAssertTrue(columns.contains(\"id\"), \"messages should have id column\")\n        XCTAssertTrue(columns.contains(\"apple_rowid\"), \"messages should have apple_rowid column\")\n        XCTAssertTrue(columns.contains(\"message_id\"), \"messages should have message_id column\")\n        XCTAssertTrue(columns.contains(\"subject\"), \"messages should have subject column\")\n\n        // Check V3 threading columns\n        XCTAssertTrue(columns.contains(\"in_reply_to\"), \"messages should have in_reply_to column (V3)\")\n        XCTAssertTrue(columns.contains(\"threading_references\"), \"messages should have threading_references column (V3)\")\n\n        // Check V4 thread_id column\n        XCTAssertTrue(columns.contains(\"thread_id\"), \"messages should have thread_id column (V4)\")\n\n        // Check V6 thread position columns\n        XCTAssertTrue(columns.contains(\"thread_position\"), \"messages should have thread_position column (V6)\")\n        XCTAssertTrue(columns.contains(\"thread_total\"), \"messages should have thread_total column (V6)\")\n    }\n\n    func testGetTableColumnsForThreads() throws {\n        try database.initialize()\n\n        let columns = try database.getTableColumns(\"threads\")\n\n        // Check all expected columns in threads table (V4)\n        XCTAssertTrue(columns.contains(\"id\"), \"threads should have id column\")\n        XCTAssertTrue(columns.contains(\"subject\"), \"threads should have subject column\")\n        XCTAssertTrue(columns.contains(\"participant_count\"), \"threads should have participant_count column\")\n        XCTAssertTrue(columns.contains(\"message_count\"), \"threads should have message_count column\")\n        XCTAssertTrue(columns.contains(\"first_date\"), \"threads should have first_date column\")\n        XCTAssertTrue(columns.contains(\"last_date\"), \"threads should have last_date column\")\n        XCTAssertTrue(columns.contains(\"created_at\"), \"threads should have created_at column\")\n        XCTAssertTrue(columns.contains(\"updated_at\"), \"threads should have updated_at column\")\n    }\n\n    func testGetTableColumnsForThreadMessages() throws {\n        try database.initialize()\n\n        let columns = try database.getTableColumns(\"thread_messages\")\n\n        // Check all expected columns in thread_messages junction table (V5)\n        XCTAssertTrue(columns.contains(\"thread_id\"), \"thread_messages should have thread_id column\")\n        XCTAssertTrue(columns.contains(\"message_id\"), \"thread_messages should have message_id column\")\n        XCTAssertTrue(columns.contains(\"added_at\"), \"thread_messages should have added_at column\")\n    }\n\n    func testMigrationIsIdempotent() throws {\n        // Run migrations once\n        try database.initialize()\n        let firstVersion = try database.getSchemaVersion()\n        database.close()\n\n        // Create new database instance pointing to same file\n        let dbPath = (testDir as NSString).appendingPathComponent(\"mail.db\")\n        let database2 = MailDatabase(databasePath: dbPath)\n\n        // Run migrations again - should be safe\n        try database2.initialize()\n        let secondVersion = try database2.getSchemaVersion()\n        database2.close()\n\n        XCTAssertEqual(firstVersion, secondVersion,\n                       \"Schema version should be the same after re-running migrations\")\n        XCTAssertEqual(secondVersion, MailDatabase.currentSchemaVersion,\n                       \"Schema version should be at latest after initialization\")\n    }\n\n    func testMigrationHandlesEmptyDatabase() throws {\n        // Start with no database file\n        let dbPath = (testDir as NSString).appendingPathComponent(\"fresh.db\")\n        let freshDatabase = MailDatabase(databasePath: dbPath)\n\n        // Initialize should create all tables\n        try freshDatabase.initialize()\n\n        // Verify all migrations were applied\n        let version = try freshDatabase.getSchemaVersion()\n        XCTAssertEqual(version, MailDatabase.currentSchemaVersion,\n                       \"Fresh database should be at latest schema version\")\n\n        // Verify core tables exist\n        XCTAssertTrue(try freshDatabase.tableExists(\"messages\"))\n        XCTAssertTrue(try freshDatabase.tableExists(\"threads\"))\n        XCTAssertTrue(try freshDatabase.tableExists(\"thread_messages\"))\n\n        freshDatabase.close()\n    }\n\n    func testMigrationDescriptionsExistForAllVersions() {\n        // Verify all migrations have descriptions\n        for version in 1...MailDatabase.currentSchemaVersion {\n            XCTAssertNotNil(MailDatabase.migrationDescriptions[version],\n                           \"Migration V\\(version) should have a description\")\n            XCTAssertFalse(MailDatabase.migrationDescriptions[version]!.isEmpty,\n                          \"Migration V\\(version) description should not be empty\")\n        }\n    }\n\n    func testMigrationPreservesExistingData() throws {\n        try database.initialize()\n\n        // Insert test data\n        let message = MailMessage(\n            id: \"migration-test-msg\",\n            appleRowId: 54321,\n            messageId: \"<migration-test@example.com>\",\n            mailboxId: 1,\n            mailboxName: \"INBOX\",\n            subject: \"Migration Test Message\",\n            senderName: \"Test Sender\",\n            senderEmail: \"test@example.com\"\n        )\n        try database.upsertMessage(message)\n\n        let thread = Thread(\n            id: \"migration-test-thread\",\n            subject: \"Migration Test Thread\",\n            participantCount: 2,\n            messageCount: 1\n        )\n        try database.upsertThread(thread)\n\n        // Close and reopen database (triggers migration check)\n        database.close()\n\n        let dbPath = (testDir as NSString).appendingPathComponent(\"mail.db\")\n        let database2 = MailDatabase(databasePath: dbPath)\n        try database2.initialize()\n\n        // Verify data is preserved\n        let retrievedMessage = try database2.getMessage(id: \"migration-test-msg\")\n        XCTAssertNotNil(retrievedMessage, \"Message should be preserved after migration\")\n        XCTAssertEqual(retrievedMessage?.subject, \"Migration Test Message\")\n\n        let retrievedThread = try database2.getThread(id: \"migration-test-thread\")\n        XCTAssertNotNil(retrievedThread, \"Thread should be preserved after migration\")\n        XCTAssertEqual(retrievedThread?.subject, \"Migration Test Thread\")\n\n        database2.close()\n    }\n}\n","structuredPatch":[{"oldStart":282,"oldLines":6,"newStart":282,"newLines":19,"lines":["         }","     }"," ","+    func testSearchWithUnknownFilterName() throws {","+        try database.initialize()","+","+        let message = MailMessage(id: \"filter-test\", subject: \"Test message for filter\")","+        try database.upsertMessage(message)","+","+        // Unknown filter names (badfilter:value format) should not crash","+        // This tests the FTS5 column prefix syntax handling","+        XCTAssertNoThrow(try database.searchMessages(query: \"badfilter:test\"), \"Search should not crash for unknown filter syntax\")","+        XCTAssertNoThrow(try database.searchMessages(query: \"unknown:value\"), \"Search should not crash for unknown filter syntax\")","+        XCTAssertNoThrow(try database.searchMessages(query: \"foo:bar baz:qux\"), \"Search should not crash for multiple unknown filters\")","+    }","+","     func testSearchWithMixedSpecialCharacters() throws {","         try database.initialize()"," "]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_011ZXxf5iKWAyNDMC6JivaS9","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FswLpEQrUezAYqz18nZCSi","name":"Bash","input":{"command":"cd /Users/I852000/Library/Mobile\\ Documents/com~apple~CloudDocs/swiftea && swift test --filter \"testSearchWithUnknownFilterName\" 2>&1","description":"Test if unknown filter names crash","timeout":120000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1258,"cache_read_input_tokens":45782,"cache_creation":{"ephemeral_5m_input_tokens":1258,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"e364633f-357a-4bcc-968f-9756e9c66eee"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FswLpEQrUezAYqz18nZCSi","type":"tool_result","content":"[1/1] Compiling plugin GenerateManual\n[2/2] Compiling plugin GenerateDoccReference\nBuilding for debugging...\n[2/7] Write sources\n[3/7] Write swift-version--58304C5D6DBC2206.txt\n[5/7] Compiling SwiftEAKitTests MailDatabaseTests.swift\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift:1863:13: warning: variable 'messageIds' was never mutated; consider changing to 'let' constant\n1861 | \n1862 |         // Verify relationship exists\n1863 |         var messageIds = try database.getMessageIdsInThread(threadId: \"fk-thread\")\n     |             `- warning: variable 'messageIds' was never mutated; consider changing to 'let' constant\n1864 |         XCTAssertEqual(messageIds.count, 1)\n1865 | \n[6/7] Emitting module SwiftEAKitTests\n[6/8] Write Objects.LinkFileList\n[7/8] Linking SwiftEAPackageTests\nBuild complete! (5.04s)\nTest Suite 'Selected tests' started at 2026-01-15 19:16:43.050.\nTest Suite 'SwiftEAPackageTests.xctest' started at 2026-01-15 19:16:43.051.\nTest Suite 'MailDatabaseTests' started at 2026-01-15 19:16:43.051.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testSearchWithUnknownFilterName]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testSearchWithUnknownFilterName]' passed (0.014 seconds).\nTest Suite 'MailDatabaseTests' passed at 2026-01-15 19:16:43.065.\n\t Executed 1 test, with 0 failures (0 unexpected) in 0.014 (0.014) seconds\nTest Suite 'SwiftEAPackageTests.xctest' passed at 2026-01-15 19:16:43.065.\n\t Executed 1 test, with 0 failures (0 unexpected) in 0.014 (0.014) seconds\nTest Suite 'Selected tests' passed at 2026-01-15 19:16:43.065.\n\t Executed 1 test, with 0 failures (0 unexpected) in 0.014 (0.015) seconds\nâ—‡ Test run started.\nâ†³ Testing Library Version: 1501\nâ†³ Target Platform: arm64e-apple-macos14.0\nâœ” Test run with 0 tests in 0 suites passed after 0.001 seconds.","is_error":false}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"db902293-c352-4e44-b178-2fa2d2e9702d","tool_use_result":{"stdout":"[1/1] Compiling plugin GenerateManual\n[2/2] Compiling plugin GenerateDoccReference\nBuilding for debugging...\n[2/7] Write sources\n[3/7] Write swift-version--58304C5D6DBC2206.txt\n[5/7] Compiling SwiftEAKitTests MailDatabaseTests.swift\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift:1863:13: warning: variable 'messageIds' was never mutated; consider changing to 'let' constant\n1861 | \n1862 |         // Verify relationship exists\n1863 |         var messageIds = try database.getMessageIdsInThread(threadId: \"fk-thread\")\n     |             `- warning: variable 'messageIds' was never mutated; consider changing to 'let' constant\n1864 |         XCTAssertEqual(messageIds.count, 1)\n1865 | \n[6/7] Emitting module SwiftEAKitTests\n[6/8] Write Objects.LinkFileList\n[7/8] Linking SwiftEAPackageTests\nBuild complete! (5.04s)\nTest Suite 'Selected tests' started at 2026-01-15 19:16:43.050.\nTest Suite 'SwiftEAPackageTests.xctest' started at 2026-01-15 19:16:43.051.\nTest Suite 'MailDatabaseTests' started at 2026-01-15 19:16:43.051.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testSearchWithUnknownFilterName]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testSearchWithUnknownFilterName]' passed (0.014 seconds).\nTest Suite 'MailDatabaseTests' passed at 2026-01-15 19:16:43.065.\n\t Executed 1 test, with 0 failures (0 unexpected) in 0.014 (0.014) seconds\nTest Suite 'SwiftEAPackageTests.xctest' passed at 2026-01-15 19:16:43.065.\n\t Executed 1 test, with 0 failures (0 unexpected) in 0.014 (0.014) seconds\nTest Suite 'Selected tests' passed at 2026-01-15 19:16:43.065.\n\t Executed 1 test, with 0 failures (0 unexpected) in 0.014 (0.015) seconds\nâ—‡ Test run started.\nâ†³ Testing Library Version: 1501\nâ†³ Target Platform: arm64e-apple-macos14.0\nâœ” Test run with 0 tests in 0 suites passed after 0.001 seconds.","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01XUsZR7aJHbcy5hfcVfo6bq","type":"message","role":"assistant","content":[{"type":"text","text":"The test passes - so the `escapeFts5Query` function is already handling the `badfilter:value` case by wrapping it in double quotes. The crash mentioned in the bug report was from before the fix in swiftea-2hz.3.\n\nHowever, the acceptance criteria still requires:\n1. Unknown filter names produce user-friendly error message\n2. Error message lists valid filter names\n3. `swea mail search \"badfilter:test\"` shows: \"Unknown filter 'badfilter'. Valid filters: from, to, subject, mailbox, is, has, after, before, date\"\n\nSo even though it doesn't crash anymore, we need to **proactively validate filter names** and warn the user when they use an unknown filter name instead of silently treating it as freeText search.\n\nLet me update my approach. The fix needs to be in the `parseQuery` function or the command handler to detect and report unknown filter names."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":858,"cache_read_input_tokens":47040,"cache_creation":{"ephemeral_5m_input_tokens":858,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"6cfb6f5e-06d0-4264-ba6c-74ad7fa26fcc"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01XUsZR7aJHbcy5hfcVfo6bq","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DXEYfqUmYNkQM3q59eiUTv","name":"TodoWrite","input":{"todos":[{"content":"Find and analyze the mail search code","status":"completed","activeForm":"Finding and analyzing the mail search code"},{"content":"Add test for unknown filter names to verify current behavior","status":"completed","activeForm":"Adding test for unknown filter names"},{"content":"Implement validation of filter names in parseQuery","status":"in_progress","activeForm":"Implementing validation of filter names in parseQuery"},{"content":"Add user-friendly error message with valid filter list","status":"pending","activeForm":"Adding user-friendly error message with valid filter list"},{"content":"Run swift build and swift test","status":"pending","activeForm":"Running swift build and swift test"},{"content":"Commit and close the bead","status":"pending","activeForm":"Committing and closing the bead"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":858,"cache_read_input_tokens":47040,"cache_creation":{"ephemeral_5m_input_tokens":858,"ephemeral_1h_input_tokens":0},"output_tokens":468,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"fd738c56-1e1d-48e3-af64-76d93a723667"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DXEYfqUmYNkQM3q59eiUTv","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"c16ccd74-4c4e-4bad-88a4-c7973bb4c153","tool_use_result":{"oldTodos":[{"content":"Find and analyze the mail search code","status":"completed","activeForm":"Finding and analyzing the mail search code"},{"content":"Add test for unknown filter names to verify current behavior","status":"in_progress","activeForm":"Adding test for unknown filter names"},{"content":"Implement graceful error handling for unknown filters","status":"pending","activeForm":"Implementing graceful error handling for unknown filters"},{"content":"Add user-friendly error message with valid filter list","status":"pending","activeForm":"Adding user-friendly error message with valid filter list"},{"content":"Run swift build and swift test","status":"pending","activeForm":"Running swift build and swift test"},{"content":"Commit and close the bead","status":"pending","activeForm":"Committing and closing the bead"}],"newTodos":[{"content":"Find and analyze the mail search code","status":"completed","activeForm":"Finding and analyzing the mail search code"},{"content":"Add test for unknown filter names to verify current behavior","status":"completed","activeForm":"Adding test for unknown filter names"},{"content":"Implement validation of filter names in parseQuery","status":"in_progress","activeForm":"Implementing validation of filter names in parseQuery"},{"content":"Add user-friendly error message with valid filter list","status":"pending","activeForm":"Adding user-friendly error message with valid filter list"},{"content":"Run swift build and swift test","status":"pending","activeForm":"Running swift build and swift test"},{"content":"Commit and close the bead","status":"pending","activeForm":"Committing and closing the bead"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_0122kbBP3JmEA5vQxfT6gSxG","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to:\n1. Modify `parseQuery` to detect unknown filter names (patterns like `word:value` that don't match known filters)\n2. Add a way to report these unknown filters\n3. Handle this in the command to show a user-friendly error\n\nLet me look at how the SearchFilter struct is defined and modify it to include unknown filters:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":510,"cache_read_input_tokens":47898,"cache_creation":{"ephemeral_5m_input_tokens":510,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"f03e3799-9346-4501-9acf-c69a3887da2c"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_0122kbBP3JmEA5vQxfT6gSxG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FW4TmTTk2rPgREvLWy74Km","name":"Read","input":{"file_path":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift","offset":666,"limit":40}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":510,"cache_read_input_tokens":47898,"cache_creation":{"ephemeral_5m_input_tokens":510,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"2400e333-6cc6-47b0-9bd9-2bd958a4101f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FW4TmTTk2rPgREvLWy74Km","type":"tool_result","content":"   666â†’    // MARK: - Structured Query Search\n   667â†’\n   668â†’    /// Parsed filter from a structured query\n   669â†’    public struct SearchFilter {\n   670â†’        public var from: String?\n   671â†’        public var to: String?\n   672â†’        public var subject: String?\n   673â†’        public var mailbox: String?\n   674â†’        public var isRead: Bool?\n   675â†’        public var isFlagged: Bool?\n   676â†’        public var dateAfter: Date?\n   677â†’        public var dateBefore: Date?\n   678â†’        public var hasAttachments: Bool?\n   679â†’        public var freeText: String?\n   680â†’        public var mailboxStatus: MailboxStatus?\n   681â†’\n   682â†’        public init() {}\n   683â†’\n   684â†’        /// Check if any filters are set\n   685â†’        public var hasFilters: Bool {\n   686â†’            from != nil || to != nil || subject != nil || mailbox != nil ||\n   687â†’            isRead != nil || isFlagged != nil || dateAfter != nil ||\n   688â†’            dateBefore != nil || hasAttachments != nil || mailboxStatus != nil\n   689â†’        }\n   690â†’\n   691â†’        /// Check if there's free text for FTS\n   692â†’        public var hasFreeText: Bool {\n   693â†’            freeText != nil && !freeText!.isEmpty\n   694â†’        }\n   695â†’    }\n   696â†’\n   697â†’    /// Parse a structured query string into filters\n   698â†’    /// Supports: from:, to:, subject:, mailbox:, is:read, is:unread, is:flagged, is:unflagged,\n   699â†’    /// after:, before:, date:, has:attachments\n   700â†’    public func parseQuery(_ query: String) -> SearchFilter {\n   701â†’        var filter = SearchFilter()\n   702â†’\n   703â†’        // Regex patterns for structured filters\n   704â†’        let filterPatterns: [(pattern: String, handler: (String, inout SearchFilter) -> Void)] = [\n   705â†’            // from: filter (email or name)\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"decc2896-6af6-426d-9807-8170ec7d66c7","tool_use_result":{"type":"text","file":{"filePath":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift","content":"    // MARK: - Structured Query Search\n\n    /// Parsed filter from a structured query\n    public struct SearchFilter {\n        public var from: String?\n        public var to: String?\n        public var subject: String?\n        public var mailbox: String?\n        public var isRead: Bool?\n        public var isFlagged: Bool?\n        public var dateAfter: Date?\n        public var dateBefore: Date?\n        public var hasAttachments: Bool?\n        public var freeText: String?\n        public var mailboxStatus: MailboxStatus?\n\n        public init() {}\n\n        /// Check if any filters are set\n        public var hasFilters: Bool {\n            from != nil || to != nil || subject != nil || mailbox != nil ||\n            isRead != nil || isFlagged != nil || dateAfter != nil ||\n            dateBefore != nil || hasAttachments != nil || mailboxStatus != nil\n        }\n\n        /// Check if there's free text for FTS\n        public var hasFreeText: Bool {\n            freeText != nil && !freeText!.isEmpty\n        }\n    }\n\n    /// Parse a structured query string into filters\n    /// Supports: from:, to:, subject:, mailbox:, is:read, is:unread, is:flagged, is:unflagged,\n    /// after:, before:, date:, has:attachments\n    public func parseQuery(_ query: String) -> SearchFilter {\n        var filter = SearchFilter()\n\n        // Regex patterns for structured filters\n        let filterPatterns: [(pattern: String, handler: (String, inout SearchFilter) -> Void)] = [\n            // from: filter (email or name)","numLines":40,"startLine":666,"totalLines":2634}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Fu5SsyXYzBC41qBkMQcJEG","type":"message","role":"assistant","content":[{"type":"text","text":"Now I understand. I need to:\n1. Add an `unknownFilters` property to `SearchFilter` to capture unknown filter names\n2. Modify `parseQuery` to detect `word:value` patterns that aren't known filters\n3. Update the command to check for unknown filters and display a helpful error\n\nLet me implement this:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":830,"cache_read_input_tokens":48408,"cache_creation":{"ephemeral_5m_input_tokens":830,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"e42112df-0bd5-4be2-8fc4-59878d321aef"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Fu5SsyXYzBC41qBkMQcJEG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014ywBo9acg9qtDd8ur5Ls2u","name":"Edit","input":{"replace_all":false,"file_path":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift","old_string":"    /// Parsed filter from a structured query\n    public struct SearchFilter {\n        public var from: String?\n        public var to: String?\n        public var subject: String?\n        public var mailbox: String?\n        public var isRead: Bool?\n        public var isFlagged: Bool?\n        public var dateAfter: Date?\n        public var dateBefore: Date?\n        public var hasAttachments: Bool?\n        public var freeText: String?\n        public var mailboxStatus: MailboxStatus?\n\n        public init() {}\n\n        /// Check if any filters are set\n        public var hasFilters: Bool {\n            from != nil || to != nil || subject != nil || mailbox != nil ||\n            isRead != nil || isFlagged != nil || dateAfter != nil ||\n            dateBefore != nil || hasAttachments != nil || mailboxStatus != nil\n        }\n\n        /// Check if there's free text for FTS\n        public var hasFreeText: Bool {\n            freeText != nil && !freeText!.isEmpty\n        }\n    }","new_string":"    /// Parsed filter from a structured query\n    public struct SearchFilter {\n        public var from: String?\n        public var to: String?\n        public var subject: String?\n        public var mailbox: String?\n        public var isRead: Bool?\n        public var isFlagged: Bool?\n        public var dateAfter: Date?\n        public var dateBefore: Date?\n        public var hasAttachments: Bool?\n        public var freeText: String?\n        public var mailboxStatus: MailboxStatus?\n        /// Unknown filter names found in the query (e.g., \"badfilter\" from \"badfilter:value\")\n        public var unknownFilters: [String] = []\n\n        public init() {}\n\n        /// Check if any filters are set\n        public var hasFilters: Bool {\n            from != nil || to != nil || subject != nil || mailbox != nil ||\n            isRead != nil || isFlagged != nil || dateAfter != nil ||\n            dateBefore != nil || hasAttachments != nil || mailboxStatus != nil\n        }\n\n        /// Check if there's free text for FTS\n        public var hasFreeText: Bool {\n            freeText != nil && !freeText!.isEmpty\n        }\n\n        /// Check if unknown filters were found\n        public var hasUnknownFilters: Bool {\n            !unknownFilters.isEmpty\n        }\n\n        /// List of valid filter names for error messages\n        public static let validFilterNames = [\"from\", \"to\", \"subject\", \"mailbox\", \"is\", \"has\", \"after\", \"before\", \"date\"]\n    }"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":830,"cache_read_input_tokens":48408,"cache_creation":{"ephemeral_5m_input_tokens":830,"ephemeral_1h_input_tokens":0},"output_tokens":839,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"1c74a044-473e-4553-a7c4-2717395e22e6"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014ywBo9acg9qtDd8ur5Ls2u","type":"tool_result","content":"The file /Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   664â†’    }\n   665â†’\n   666â†’    // MARK: - Structured Query Search\n   667â†’\n   668â†’    /// Parsed filter from a structured query\n   669â†’    public struct SearchFilter {\n   670â†’        public var from: String?\n   671â†’        public var to: String?\n   672â†’        public var subject: String?\n   673â†’        public var mailbox: String?\n   674â†’        public var isRead: Bool?\n   675â†’        public var isFlagged: Bool?\n   676â†’        public var dateAfter: Date?\n   677â†’        public var dateBefore: Date?\n   678â†’        public var hasAttachments: Bool?\n   679â†’        public var freeText: String?\n   680â†’        public var mailboxStatus: MailboxStatus?\n   681â†’        /// Unknown filter names found in the query (e.g., \"badfilter\" from \"badfilter:value\")\n   682â†’        public var unknownFilters: [String] = []\n   683â†’\n   684â†’        public init() {}\n   685â†’\n   686â†’        /// Check if any filters are set\n   687â†’        public var hasFilters: Bool {\n   688â†’            from != nil || to != nil || subject != nil || mailbox != nil ||\n   689â†’            isRead != nil || isFlagged != nil || dateAfter != nil ||\n   690â†’            dateBefore != nil || hasAttachments != nil || mailboxStatus != nil\n   691â†’        }\n   692â†’\n   693â†’        /// Check if there's free text for FTS\n   694â†’        public var hasFreeText: Bool {\n   695â†’            freeText != nil && !freeText!.isEmpty\n   696â†’        }\n   697â†’\n   698â†’        /// Check if unknown filters were found\n   699â†’        public var hasUnknownFilters: Bool {\n   700â†’            !unknownFilters.isEmpty\n   701â†’        }\n   702â†’\n   703â†’        /// List of valid filter names for error messages\n   704â†’        public static let validFilterNames = [\"from\", \"to\", \"subject\", \"mailbox\", \"is\", \"has\", \"after\", \"before\", \"date\"]\n   705â†’    }\n   706â†’\n   707â†’    /// Parse a structured query string into filters\n   708â†’    /// Supports: from:, to:, subject:, mailbox:, is:read, is:unread, is:flagged, is:unflagged,\n   709â†’    /// after:, before:, date:, has:attachments"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"aa5f73d1-c44e-4731-b9cc-5d82bdaa0619","tool_use_result":{"filePath":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift","oldString":"    /// Parsed filter from a structured query\n    public struct SearchFilter {\n        public var from: String?\n        public var to: String?\n        public var subject: String?\n        public var mailbox: String?\n        public var isRead: Bool?\n        public var isFlagged: Bool?\n        public var dateAfter: Date?\n        public var dateBefore: Date?\n        public var hasAttachments: Bool?\n        public var freeText: String?\n        public var mailboxStatus: MailboxStatus?\n\n        public init() {}\n\n        /// Check if any filters are set\n        public var hasFilters: Bool {\n            from != nil || to != nil || subject != nil || mailbox != nil ||\n            isRead != nil || isFlagged != nil || dateAfter != nil ||\n            dateBefore != nil || hasAttachments != nil || mailboxStatus != nil\n        }\n\n        /// Check if there's free text for FTS\n        public var hasFreeText: Bool {\n            freeText != nil && !freeText!.isEmpty\n        }\n    }","newString":"    /// Parsed filter from a structured query\n    public struct SearchFilter {\n        public var from: String?\n        public var to: String?\n        public var subject: String?\n        public var mailbox: String?\n        public var isRead: Bool?\n        public var isFlagged: Bool?\n        public var dateAfter: Date?\n        public var dateBefore: Date?\n        public var hasAttachments: Bool?\n        public var freeText: String?\n        public var mailboxStatus: MailboxStatus?\n        /// Unknown filter names found in the query (e.g., \"badfilter\" from \"badfilter:value\")\n        public var unknownFilters: [String] = []\n\n        public init() {}\n\n        /// Check if any filters are set\n        public var hasFilters: Bool {\n            from != nil || to != nil || subject != nil || mailbox != nil ||\n            isRead != nil || isFlagged != nil || dateAfter != nil ||\n            dateBefore != nil || hasAttachments != nil || mailboxStatus != nil\n        }\n\n        /// Check if there's free text for FTS\n        public var hasFreeText: Bool {\n            freeText != nil && !freeText!.isEmpty\n        }\n\n        /// Check if unknown filters were found\n        public var hasUnknownFilters: Bool {\n            !unknownFilters.isEmpty\n        }\n\n        /// List of valid filter names for error messages\n        public static let validFilterNames = [\"from\", \"to\", \"subject\", \"mailbox\", \"is\", \"has\", \"after\", \"before\", \"date\"]\n    }","originalFile":"// MailDatabase - libSQL mirror database for Apple Mail data\n\nimport Foundation\nimport Libsql\n\n/// Errors that can occur during mail database operations\npublic enum MailDatabaseError: Error, LocalizedError {\n    case connectionFailed(underlying: Error)\n    case migrationFailed(underlying: Error)\n    case queryFailed(underlying: Error)\n    case notInitialized\n\n    public var errorDescription: String? {\n        switch self {\n        case .connectionFailed(let error):\n            return \"Failed to connect to mail database: \\(error.localizedDescription)\"\n        case .migrationFailed(let error):\n            return \"Failed to run database migration: \\(error.localizedDescription)\"\n        case .queryFailed(let error):\n            return \"Database query failed: \\(error.localizedDescription)\"\n        case .notInitialized:\n            return \"Mail database not initialized\"\n        }\n    }\n}\n\n/// Sort options for thread listing\npublic enum ThreadSortOrder: String, CaseIterable, Sendable {\n    case date = \"date\"\n    case subject = \"subject\"\n    case messageCount = \"message_count\"\n\n    /// SQL ORDER BY clause for this sort option\n    var sqlOrderBy: String {\n        switch self {\n        case .date:\n            return \"last_date DESC\"\n        case .subject:\n            return \"subject ASC NULLS LAST\"\n        case .messageCount:\n            return \"message_count DESC\"\n        }\n    }\n}\n\n/// Manages the libSQL mirror database for Apple Mail data\npublic final class MailDatabase: @unchecked Sendable {\n    private var database: Database?\n    private var connection: Connection?\n    private let databasePath: String\n\n    public init(databasePath: String) {\n        self.databasePath = databasePath\n    }\n\n    /// Initialize the database connection and run migrations\n    public func initialize() throws {\n        do {\n            database = try Database(databasePath)\n            connection = try database?.connect()\n\n            // Enable WAL mode for concurrent access (allows readers while writing)\n            // This prevents \"database is locked\" errors when daemon and manual sync run concurrently\n            if let conn = connection {\n                _ = try conn.query(\"PRAGMA journal_mode=WAL\")\n                // Set busy timeout to 5 seconds to wait for locks instead of failing immediately\n                _ = try conn.query(\"PRAGMA busy_timeout=5000\")\n            }\n\n            try runMigrations()\n        } catch {\n            throw MailDatabaseError.connectionFailed(underlying: error)\n        }\n    }\n\n    /// Close the database connection\n    public func close() {\n        connection = nil\n        database = nil\n    }\n\n    // MARK: - Schema Definition\n\n    /// Run all pending migrations to bring schema up to date\n    private func runMigrations() throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        // Create schema version tracking table\n        _ = try conn.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS schema_version (\n                version INTEGER PRIMARY KEY,\n                applied_at TEXT NOT NULL DEFAULT (datetime('now'))\n            )\n            \"\"\")\n\n        // Get current version\n        let result = try conn.query(\"SELECT MAX(version) as v FROM schema_version\")\n        var currentVersion = 0\n        for row in result {\n            if let v = try? row.getInt(0) {\n                currentVersion = v\n            }\n        }\n\n        // Apply migrations\n        if currentVersion < 1 {\n            try applyMigrationV1(conn)\n        }\n        if currentVersion < 2 {\n            try applyMigrationV2(conn)\n        }\n        if currentVersion < 3 {\n            try applyMigrationV3(conn)\n        }\n        if currentVersion < 4 {\n            try applyMigrationV4(conn)\n        }\n        if currentVersion < 5 {\n            try applyMigrationV5(conn)\n        }\n        if currentVersion < 6 {\n            try applyMigrationV6(conn)\n        }\n        if currentVersion < 7 {\n            try applyMigrationV7(conn)\n        }\n    }\n\n    /// Migration v1: Initial schema with all mail tables\n    private func applyMigrationV1(_ conn: Connection) throws {\n        do {\n            // Messages table - core email metadata\n            _ = try conn.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS messages (\n                    id TEXT PRIMARY KEY,\n                    apple_rowid INTEGER,\n                    message_id TEXT,\n                    mailbox_id INTEGER,\n                    mailbox_name TEXT,\n                    account_id TEXT,\n                    subject TEXT,\n                    sender_name TEXT,\n                    sender_email TEXT,\n                    date_sent INTEGER,\n                    date_received INTEGER,\n                    is_read INTEGER DEFAULT 0,\n                    is_flagged INTEGER DEFAULT 0,\n                    is_deleted INTEGER DEFAULT 0,\n                    has_attachments INTEGER DEFAULT 0,\n                    emlx_path TEXT,\n                    body_text TEXT,\n                    body_html TEXT,\n                    export_path TEXT,\n                    synced_at INTEGER NOT NULL,\n                    updated_at INTEGER NOT NULL\n                )\n                \"\"\")\n\n            // Recipients table - to/cc/bcc addresses\n            _ = try conn.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS recipients (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    message_id TEXT NOT NULL,\n                    type TEXT NOT NULL,\n                    name TEXT,\n                    email TEXT NOT NULL,\n                    FOREIGN KEY (message_id) REFERENCES messages(id) ON DELETE CASCADE\n                )\n                \"\"\")\n\n            // Attachments table - attachment metadata\n            _ = try conn.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS attachments (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    message_id TEXT NOT NULL,\n                    filename TEXT NOT NULL,\n                    mime_type TEXT,\n                    size INTEGER,\n                    content_id TEXT,\n                    is_inline INTEGER DEFAULT 0,\n                    FOREIGN KEY (message_id) REFERENCES messages(id) ON DELETE CASCADE\n                )\n                \"\"\")\n\n            // Mailboxes table - folder hierarchy\n            _ = try conn.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS mailboxes (\n                    id INTEGER PRIMARY KEY,\n                    account_id TEXT NOT NULL,\n                    name TEXT NOT NULL,\n                    full_path TEXT NOT NULL,\n                    parent_id INTEGER,\n                    message_count INTEGER DEFAULT 0,\n                    unread_count INTEGER DEFAULT 0,\n                    synced_at INTEGER NOT NULL\n                )\n                \"\"\")\n\n            // Sync status table - track sync progress\n            _ = try conn.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS sync_status (\n                    key TEXT PRIMARY KEY,\n                    value TEXT NOT NULL,\n                    updated_at INTEGER NOT NULL\n                )\n                \"\"\")\n\n            // Create indexes for common lookups\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_messages_apple_rowid ON messages(apple_rowid)\")\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_messages_message_id ON messages(message_id)\")\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_messages_mailbox_id ON messages(mailbox_id)\")\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_messages_account_id ON messages(account_id)\")\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_messages_date_received ON messages(date_received)\")\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_messages_is_read ON messages(is_read)\")\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_messages_is_flagged ON messages(is_flagged)\")\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_recipients_message_id ON recipients(message_id)\")\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_attachments_message_id ON attachments(message_id)\")\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_mailboxes_account_id ON mailboxes(account_id)\")\n\n            // Create FTS5 virtual table for full-text search\n            // Note: Using external content table (content='messages') means FTS reads from messages table\n            _ = try conn.execute(\"\"\"\n                CREATE VIRTUAL TABLE IF NOT EXISTS messages_fts USING fts5(\n                    subject,\n                    sender_name,\n                    sender_email,\n                    body_text,\n                    content='messages',\n                    content_rowid='rowid',\n                    tokenize='porter unicode61'\n                )\n                \"\"\")\n\n            // Create triggers to keep FTS index in sync\n            _ = try conn.execute(\"\"\"\n                CREATE TRIGGER IF NOT EXISTS messages_ai AFTER INSERT ON messages BEGIN\n                    INSERT INTO messages_fts(rowid, subject, sender_name, sender_email, body_text)\n                    VALUES (NEW.rowid, NEW.subject, NEW.sender_name, NEW.sender_email, NEW.body_text);\n                END\n                \"\"\")\n\n            _ = try conn.execute(\"\"\"\n                CREATE TRIGGER IF NOT EXISTS messages_ad AFTER DELETE ON messages BEGIN\n                    INSERT INTO messages_fts(messages_fts, rowid, subject, sender_name, sender_email, body_text)\n                    VALUES ('delete', OLD.rowid, OLD.subject, OLD.sender_name, OLD.sender_email, OLD.body_text);\n                END\n                \"\"\")\n\n            _ = try conn.execute(\"\"\"\n                CREATE TRIGGER IF NOT EXISTS messages_au AFTER UPDATE ON messages BEGIN\n                    INSERT INTO messages_fts(messages_fts, rowid, subject, sender_name, sender_email, body_text)\n                    VALUES ('delete', OLD.rowid, OLD.subject, OLD.sender_name, OLD.sender_email, OLD.body_text);\n                    INSERT INTO messages_fts(rowid, subject, sender_name, sender_email, body_text)\n                    VALUES (NEW.rowid, NEW.subject, NEW.sender_name, NEW.sender_email, NEW.body_text);\n                END\n                \"\"\")\n\n            // Record migration version\n            _ = try conn.execute(\"INSERT INTO schema_version (version) VALUES (1)\")\n\n        } catch {\n            throw MailDatabaseError.migrationFailed(underlying: error)\n        }\n    }\n\n    /// Migration v2: Add mailbox status tracking columns for bidirectional sync\n    private func applyMigrationV2(_ conn: Connection) throws {\n        do {\n            // Add mailbox_status column with default 'inbox' for existing messages\n            _ = try conn.execute(\"ALTER TABLE messages ADD COLUMN mailbox_status TEXT DEFAULT 'inbox'\")\n\n            // Add pending_sync_action column (nullable - only set when action is pending)\n            _ = try conn.execute(\"ALTER TABLE messages ADD COLUMN pending_sync_action TEXT\")\n\n            // Add last_known_mailbox_id column (nullable - tracks original mailbox for move detection)\n            _ = try conn.execute(\"ALTER TABLE messages ADD COLUMN last_known_mailbox_id INTEGER\")\n\n            // Create index for querying messages by mailbox status\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_messages_mailbox_status ON messages(mailbox_status)\")\n\n            // Create index for finding messages with pending sync actions\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_messages_pending_sync_action ON messages(pending_sync_action)\")\n\n            // Record migration version\n            _ = try conn.execute(\"INSERT INTO schema_version (version) VALUES (2)\")\n\n        } catch {\n            throw MailDatabaseError.migrationFailed(underlying: error)\n        }\n    }\n\n    /// Migration v3: Add threading header columns (in_reply_to, references)\n    private func applyMigrationV3(_ conn: Connection) throws {\n        do {\n            // Add in_reply_to column (nullable - stores the In-Reply-To header value)\n            _ = try conn.execute(\"ALTER TABLE messages ADD COLUMN in_reply_to TEXT\")\n\n            // Add references column (nullable - stores JSON array of message IDs from References header)\n            _ = try conn.execute(\"ALTER TABLE messages ADD COLUMN threading_references TEXT\")\n\n            // Create index for looking up messages by in_reply_to (for thread detection)\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_messages_in_reply_to ON messages(in_reply_to)\")\n\n            // Record migration version\n            _ = try conn.execute(\"INSERT INTO schema_version (version) VALUES (3)\")\n\n        } catch {\n            throw MailDatabaseError.migrationFailed(underlying: error)\n        }\n    }\n\n    /// Migration v4: Create threads table for conversation-level metadata\n    private func applyMigrationV4(_ conn: Connection) throws {\n        do {\n            // Create threads table for conversation-level metadata\n            // Thread IDs are 32-character hex strings generated by ThreadIDGenerator\n            _ = try conn.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS threads (\n                    id TEXT PRIMARY KEY,\n                    subject TEXT,\n                    participant_count INTEGER DEFAULT 0,\n                    message_count INTEGER DEFAULT 0,\n                    first_date INTEGER,\n                    last_date INTEGER,\n                    created_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now')),\n                    updated_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now'))\n                )\n                \"\"\")\n\n            // Add thread_id column to messages table (foreign key reference to threads)\n            _ = try conn.execute(\"ALTER TABLE messages ADD COLUMN thread_id TEXT REFERENCES threads(id)\")\n\n            // Create index for efficient thread lookups\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_threads_last_date ON threads(last_date DESC)\")\n\n            // Create index for efficient message lookup by thread_id\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_messages_thread_id ON messages(thread_id)\")\n\n            // Record migration version\n            _ = try conn.execute(\"INSERT INTO schema_version (version) VALUES (4)\")\n\n        } catch {\n            throw MailDatabaseError.migrationFailed(underlying: error)\n        }\n    }\n\n    /// Migration v5: Create thread_messages junction table for many-to-many relationships\n    private func applyMigrationV5(_ conn: Connection) throws {\n        do {\n            // Create thread_messages junction table\n            // This allows many-to-many relationships between threads and messages\n            // A message can belong to multiple threads (e.g., cross-posted, forwarded chains)\n            // A thread can contain multiple messages\n            _ = try conn.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS thread_messages (\n                    thread_id TEXT NOT NULL,\n                    message_id TEXT NOT NULL,\n                    added_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now')),\n                    PRIMARY KEY (thread_id, message_id),\n                    FOREIGN KEY (thread_id) REFERENCES threads(id) ON DELETE CASCADE,\n                    FOREIGN KEY (message_id) REFERENCES messages(id) ON DELETE CASCADE\n                )\n                \"\"\")\n\n            // Create index for efficient lookup by thread_id (get all messages in a thread)\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_thread_messages_thread_id ON thread_messages(thread_id)\")\n\n            // Create index for efficient lookup by message_id (get all threads a message belongs to)\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_thread_messages_message_id ON thread_messages(message_id)\")\n\n            // Record migration version\n            _ = try conn.execute(\"INSERT INTO schema_version (version) VALUES (5)\")\n\n        } catch {\n            throw MailDatabaseError.migrationFailed(underlying: error)\n        }\n    }\n\n    /// Migration v6: Add thread_position and thread_total columns to messages table\n    private func applyMigrationV6(_ conn: Connection) throws {\n        do {\n            // Add thread_position column (nullable - position of message within its thread)\n            _ = try conn.execute(\"ALTER TABLE messages ADD COLUMN thread_position INTEGER\")\n\n            // Add thread_total column (nullable - total messages in the thread)\n            _ = try conn.execute(\"ALTER TABLE messages ADD COLUMN thread_total INTEGER\")\n\n            // Record migration version\n            _ = try conn.execute(\"INSERT INTO schema_version (version) VALUES (6)\")\n\n        } catch {\n            throw MailDatabaseError.migrationFailed(underlying: error)\n        }\n    }\n\n    /// Migration v7: Add indexes for large inbox query optimization (>100k emails)\n    /// This migration optimizes thread listing and filtering for large inboxes\n    private func applyMigrationV7(_ conn: Connection) throws {\n        do {\n            // Index on threads(subject) for sorting by subject\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_threads_subject ON threads(subject)\")\n\n            // Index on threads(message_count) for sorting by message count\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_threads_message_count ON threads(message_count DESC)\")\n\n            // Index on messages(sender_email) for participant filtering\n            // Uses LOWER() to support case-insensitive queries\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_messages_sender_email ON messages(sender_email)\")\n\n            // Index on recipients(email) for participant filtering\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_recipients_email ON recipients(email)\")\n\n            // Composite index for efficient thread position batch updates\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_messages_thread_position ON messages(thread_id, thread_position)\")\n\n            // Record migration version\n            _ = try conn.execute(\"INSERT INTO schema_version (version) VALUES (7)\")\n\n        } catch {\n            throw MailDatabaseError.migrationFailed(underlying: error)\n        }\n    }\n\n    // MARK: - Schema Version API\n\n    /// The current schema version number (latest migration version)\n    public static let currentSchemaVersion = 7\n\n    /// Description of each schema migration\n    public static let migrationDescriptions: [Int: String] = [\n        1: \"Initial schema with messages, recipients, attachments, mailboxes, sync_status tables and FTS5\",\n        2: \"Bidirectional sync columns (mailbox_status, pending_sync_action, last_known_mailbox_id)\",\n        3: \"Threading headers (in_reply_to, threading_references)\",\n        4: \"Threads table and thread_id column on messages\",\n        5: \"Thread-messages junction table for many-to-many relationships\",\n        6: \"Thread position metadata (thread_position, thread_total)\",\n        7: \"Large inbox query optimization indexes\"\n    ]\n\n    /// Get the current schema version from the database\n    /// Returns 0 if database has no schema_version table (empty/new database)\n    public func getSchemaVersion() throws -> Int {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        // Check if schema_version table exists\n        let tableCheck = try conn.query(\"\"\"\n            SELECT name FROM sqlite_master\n            WHERE type='table' AND name='schema_version'\n            \"\"\")\n\n        var tableExists = false\n        for _ in tableCheck {\n            tableExists = true\n            break\n        }\n\n        if !tableExists {\n            return 0\n        }\n\n        // Get current version\n        let result = try conn.query(\"SELECT MAX(version) as v FROM schema_version\")\n        for row in result {\n            if let v = try? row.getInt(0) {\n                return v\n            }\n        }\n        return 0\n    }\n\n    /// Get the migration history with timestamps\n    public func getMigrationHistory() throws -> [(version: Int, appliedAt: String)] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        // Check if schema_version table exists\n        let tableCheck = try conn.query(\"\"\"\n            SELECT name FROM sqlite_master\n            WHERE type='table' AND name='schema_version'\n            \"\"\")\n\n        var tableExists = false\n        for _ in tableCheck {\n            tableExists = true\n            break\n        }\n\n        if !tableExists {\n            return []\n        }\n\n        var history: [(version: Int, appliedAt: String)] = []\n        let result = try conn.query(\"SELECT version, applied_at FROM schema_version ORDER BY version ASC\")\n        for row in result {\n            if let version = try? row.getInt(0),\n               let appliedAt = try? row.getString(1) {\n                history.append((version: version, appliedAt: appliedAt))\n            }\n        }\n        return history\n    }\n\n    /// Check if a specific table exists in the database\n    public func tableExists(_ tableName: String) throws -> Bool {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"\"\"\n            SELECT name FROM sqlite_master\n            WHERE type='table' AND name='\\(escapeSql(tableName))'\n            \"\"\")\n\n        for _ in result {\n            return true\n        }\n        return false\n    }\n\n    /// Get the columns for a specific table\n    public func getTableColumns(_ tableName: String) throws -> [String] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        var columns: [String] = []\n        let result = try conn.query(\"PRAGMA table_info('\\(escapeSql(tableName))')\")\n        for row in result {\n            if let name = try? row.getString(1) {\n                columns.append(name)\n            }\n        }\n        return columns\n    }\n\n    // MARK: - Message Operations\n\n    /// Insert or update a message in the mirror database\n    public func upsertMessage(_ message: MailMessage) throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let now = Int(Date().timeIntervalSince1970)\n\n        // Serialize references array to JSON for storage\n        let referencesJson = serializeReferences(message.references)\n\n        _ = try conn.execute(\"\"\"\n            INSERT INTO messages (\n                id, apple_rowid, message_id, mailbox_id, mailbox_name, account_id,\n                subject, sender_name, sender_email, date_sent, date_received,\n                is_read, is_flagged, is_deleted, has_attachments, emlx_path,\n                body_text, body_html, synced_at, updated_at,\n                mailbox_status, pending_sync_action, last_known_mailbox_id,\n                in_reply_to, threading_references, thread_id,\n                thread_position, thread_total\n            ) VALUES (\n                '\\(message.id)', \\(message.appleRowId ?? 0), \\(message.messageId.map { \"'\\($0)'\" } ?? \"NULL\"),\n                \\(message.mailboxId ?? 0), \\(message.mailboxName.map { \"'\\($0)'\" } ?? \"NULL\"),\n                \\(message.accountId.map { \"'\\($0)'\" } ?? \"NULL\"),\n                '\\(escapeSql(message.subject))', \\(message.senderName.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                \\(message.senderEmail.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                \\(message.dateSent.map { Int($0.timeIntervalSince1970) } ?? 0),\n                \\(message.dateReceived.map { Int($0.timeIntervalSince1970) } ?? 0),\n                \\(message.isRead ? 1 : 0), \\(message.isFlagged ? 1 : 0), \\(message.isDeleted ? 1 : 0),\n                \\(message.hasAttachments ? 1 : 0), \\(message.emlxPath.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                \\(message.bodyText.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                \\(message.bodyHtml.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                \\(now), \\(now),\n                '\\(message.mailboxStatus.rawValue)',\n                \\(message.pendingSyncAction.map { \"'\\($0.rawValue)'\" } ?? \"NULL\"),\n                \\(message.lastKnownMailboxId.map { String($0) } ?? \"NULL\"),\n                \\(message.inReplyTo.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                \\(referencesJson.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                \\(message.threadId.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                \\(message.threadPosition.map { String($0) } ?? \"NULL\"),\n                \\(message.threadTotal.map { String($0) } ?? \"NULL\")\n            )\n            ON CONFLICT(id) DO UPDATE SET\n                apple_rowid = excluded.apple_rowid,\n                message_id = excluded.message_id,\n                mailbox_id = excluded.mailbox_id,\n                mailbox_name = excluded.mailbox_name,\n                account_id = excluded.account_id,\n                subject = excluded.subject,\n                sender_name = excluded.sender_name,\n                sender_email = excluded.sender_email,\n                date_sent = excluded.date_sent,\n                date_received = excluded.date_received,\n                is_read = excluded.is_read,\n                is_flagged = excluded.is_flagged,\n                is_deleted = excluded.is_deleted,\n                has_attachments = excluded.has_attachments,\n                emlx_path = excluded.emlx_path,\n                body_text = excluded.body_text,\n                body_html = excluded.body_html,\n                updated_at = \\(now),\n                mailbox_status = excluded.mailbox_status,\n                pending_sync_action = excluded.pending_sync_action,\n                last_known_mailbox_id = excluded.last_known_mailbox_id,\n                in_reply_to = excluded.in_reply_to,\n                threading_references = excluded.threading_references,\n                thread_id = excluded.thread_id,\n                thread_position = excluded.thread_position,\n                thread_total = excluded.thread_total\n            \"\"\")\n    }\n\n    /// Get a message by its stable ID\n    public func getMessage(id: String) throws -> MailMessage? {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"SELECT * FROM messages WHERE id = '\\(escapeSql(id))'\")\n\n        for row in result {\n            return try rowToMessage(row)\n        }\n        return nil\n    }\n\n    /// Get a message by Apple Mail rowid\n    public func getMessage(appleRowId: Int) throws -> MailMessage? {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"SELECT * FROM messages WHERE apple_rowid = \\(appleRowId)\")\n\n        for row in result {\n            return try rowToMessage(row)\n        }\n        return nil\n    }\n\n    /// Search messages using FTS\n    public func searchMessages(query: String, limit: Int = 50, offset: Int = 0) throws -> [MailMessage] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"\"\"\n            SELECT m.* FROM messages m\n            JOIN messages_fts fts ON m.rowid = fts.rowid\n            WHERE messages_fts MATCH '\\(escapeSql(escapeFts5Query(query)))'\n            ORDER BY bm25(messages_fts)\n            LIMIT \\(limit) OFFSET \\(offset)\n            \"\"\")\n\n        var messages: [MailMessage] = []\n        for row in result {\n            if let message = try? rowToMessage(row) {\n                messages.append(message)\n            }\n        }\n        return messages\n    }\n\n    // MARK: - Structured Query Search\n\n    /// Parsed filter from a structured query\n    public struct SearchFilter {\n        public var from: String?\n        public var to: String?\n        public var subject: String?\n        public var mailbox: String?\n        public var isRead: Bool?\n        public var isFlagged: Bool?\n        public var dateAfter: Date?\n        public var dateBefore: Date?\n        public var hasAttachments: Bool?\n        public var freeText: String?\n        public var mailboxStatus: MailboxStatus?\n\n        public init() {}\n\n        /// Check if any filters are set\n        public var hasFilters: Bool {\n            from != nil || to != nil || subject != nil || mailbox != nil ||\n            isRead != nil || isFlagged != nil || dateAfter != nil ||\n            dateBefore != nil || hasAttachments != nil || mailboxStatus != nil\n        }\n\n        /// Check if there's free text for FTS\n        public var hasFreeText: Bool {\n            freeText != nil && !freeText!.isEmpty\n        }\n    }\n\n    /// Parse a structured query string into filters\n    /// Supports: from:, to:, subject:, mailbox:, is:read, is:unread, is:flagged, is:unflagged,\n    /// after:, before:, date:, has:attachments\n    public func parseQuery(_ query: String) -> SearchFilter {\n        var filter = SearchFilter()\n\n        // Regex patterns for structured filters\n        let filterPatterns: [(pattern: String, handler: (String, inout SearchFilter) -> Void)] = [\n            // from: filter (email or name)\n            (\"from:\\\"([^\\\"]+)\\\"\", { value, f in f.from = value }),\n            (\"from:(\\\\S+)\", { value, f in f.from = value }),\n\n            // to: filter\n            (\"to:\\\"([^\\\"]+)\\\"\", { value, f in f.to = value }),\n            (\"to:(\\\\S+)\", { value, f in f.to = value }),\n\n            // subject: filter\n            (\"subject:\\\"([^\\\"]+)\\\"\", { value, f in f.subject = value }),\n            (\"subject:(\\\\S+)\", { value, f in f.subject = value }),\n\n            // mailbox: filter\n            (\"mailbox:\\\"([^\\\"]+)\\\"\", { value, f in f.mailbox = value }),\n            (\"mailbox:(\\\\S+)\", { value, f in f.mailbox = value }),\n\n            // is: status filters\n            (\"is:read\", { _, f in f.isRead = true }),\n            (\"is:unread\", { _, f in f.isRead = false }),\n            (\"is:flagged\", { _, f in f.isFlagged = true }),\n            (\"is:unflagged\", { _, f in f.isFlagged = false }),\n\n            // has: filters\n            (\"has:attachments?\", { _, f in f.hasAttachments = true }),\n\n            // Date filters (YYYY-MM-DD format)\n            (\"after:(\\\\d{4}-\\\\d{2}-\\\\d{2})\", { value, f in f.dateAfter = parseDate(value) }),\n            (\"before:(\\\\d{4}-\\\\d{2}-\\\\d{2})\", { value, f in f.dateBefore = parseDate(value) }),\n            (\"date:(\\\\d{4}-\\\\d{2}-\\\\d{2})\", { value, f in\n                // date: sets both after and before to cover the whole day\n                if let date = parseDate(value) {\n                    f.dateAfter = date\n                    // Set before to end of day\n                    if let endOfDay = Calendar.current.date(byAdding: .day, value: 1, to: date) {\n                        f.dateBefore = endOfDay\n                    }\n                }\n            })\n        ]\n\n        var remainingQuery = query\n\n        // Process each filter pattern\n        for (pattern, handler) in filterPatterns {\n            if let regex = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive) {\n                let range = NSRange(remainingQuery.startIndex..., in: remainingQuery)\n                let matches = regex.matches(in: remainingQuery, options: [], range: range)\n\n                // Process matches in reverse to preserve indices\n                for match in matches.reversed() {\n                    // Extract captured group if present, otherwise use the whole match\n                    let valueRange = match.numberOfRanges > 1 ? match.range(at: 1) : match.range\n                    if let swiftRange = Range(valueRange, in: remainingQuery) {\n                        let value = String(remainingQuery[swiftRange])\n                        handler(value, &filter)\n                    } else {\n                        handler(\"\", &filter)\n                    }\n\n                    // Remove matched text from query\n                    if let swiftRange = Range(match.range, in: remainingQuery) {\n                        remainingQuery.removeSubrange(swiftRange)\n                    }\n                }\n            }\n        }\n\n        // Clean up remaining query (free text for FTS)\n        let cleanedFreeText = remainingQuery\n            .trimmingCharacters(in: .whitespaces)\n            .components(separatedBy: .whitespaces)\n            .filter { !$0.isEmpty }\n            .joined(separator: \" \")\n\n        if !cleanedFreeText.isEmpty {\n            filter.freeText = cleanedFreeText\n        }\n\n        return filter\n    }\n\n    /// Search messages using structured filters and optional FTS\n    public func searchMessagesWithFilters(_ filter: SearchFilter, limit: Int = 50, offset: Int = 0) throws -> [MailMessage] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        var whereClauses: [String] = []\n\n        // Build WHERE clauses from filters\n\n        // from: filter (matches sender_name or sender_email)\n        if let from = filter.from {\n            let escaped = escapeSql(from)\n            whereClauses.append(\"(m.sender_email LIKE '%\\(escaped)%' OR m.sender_name LIKE '%\\(escaped)%')\")\n        }\n\n        // to: filter (requires join with recipients table)\n        // For simplicity, we'll use a subquery\n        if let to = filter.to {\n            let escaped = escapeSql(to)\n            whereClauses.append(\"\"\"\n                EXISTS (SELECT 1 FROM recipients r WHERE r.message_id = m.id\n                        AND (r.email LIKE '%\\(escaped)%' OR r.name LIKE '%\\(escaped)%'))\n                \"\"\")\n        }\n\n        // subject: filter\n        if let subject = filter.subject {\n            let escaped = escapeSql(subject)\n            whereClauses.append(\"m.subject LIKE '%\\(escaped)%'\")\n        }\n\n        // mailbox: filter\n        if let mailbox = filter.mailbox {\n            let escaped = escapeSql(mailbox)\n            whereClauses.append(\"m.mailbox_name LIKE '%\\(escaped)%'\")\n        }\n\n        // is:read / is:unread filter\n        if let isRead = filter.isRead {\n            whereClauses.append(\"m.is_read = \\(isRead ? 1 : 0)\")\n        }\n\n        // is:flagged / is:unflagged filter\n        if let isFlagged = filter.isFlagged {\n            whereClauses.append(\"m.is_flagged = \\(isFlagged ? 1 : 0)\")\n        }\n\n        // has:attachments filter\n        if let hasAttachments = filter.hasAttachments, hasAttachments {\n            whereClauses.append(\"m.has_attachments = 1\")\n        }\n\n        // Date filters\n        if let dateAfter = filter.dateAfter {\n            let timestamp = Int(dateAfter.timeIntervalSince1970)\n            whereClauses.append(\"m.date_received >= \\(timestamp)\")\n        }\n\n        if let dateBefore = filter.dateBefore {\n            let timestamp = Int(dateBefore.timeIntervalSince1970)\n            whereClauses.append(\"m.date_received < \\(timestamp)\")\n        }\n\n        // Mailbox status filter (inbox, archived, deleted)\n        if let mailboxStatus = filter.mailboxStatus {\n            whereClauses.append(\"m.mailbox_status = '\\(mailboxStatus.rawValue)'\")\n        }\n\n        // Always exclude deleted messages\n        whereClauses.append(\"m.is_deleted = 0\")\n\n        // Build the query\n        var sql: String\n\n        if filter.hasFreeText, let freeText = filter.freeText {\n            // Use FTS with additional filters\n            let whereClause = whereClauses.isEmpty ? \"\" : \"AND \" + whereClauses.joined(separator: \" AND \")\n            sql = \"\"\"\n                SELECT m.* FROM messages m\n                JOIN messages_fts fts ON m.rowid = fts.rowid\n                WHERE messages_fts MATCH '\\(escapeSql(escapeFts5Query(freeText)))'\n                \\(whereClause)\n                ORDER BY bm25(messages_fts)\n                LIMIT \\(limit) OFFSET \\(offset)\n                \"\"\"\n        } else if !whereClauses.isEmpty {\n            // Filters only, no FTS\n            let whereClause = whereClauses.joined(separator: \" AND \")\n            sql = \"\"\"\n                SELECT m.* FROM messages m\n                WHERE \\(whereClause)\n                ORDER BY m.date_received DESC\n                LIMIT \\(limit) OFFSET \\(offset)\n                \"\"\"\n        } else {\n            // No filters, return recent messages\n            sql = \"\"\"\n                SELECT * FROM messages m\n                WHERE m.is_deleted = 0\n                ORDER BY m.date_received DESC\n                LIMIT \\(limit) OFFSET \\(offset)\n                \"\"\"\n        }\n\n        let result = try conn.query(sql)\n\n        var messages: [MailMessage] = []\n        for row in result {\n            if let message = try? rowToMessage(row) {\n                messages.append(message)\n            }\n        }\n        return messages\n    }\n\n    /// Get all non-deleted messages (for export without search query)\n    /// - Parameters:\n    ///   - limit: Maximum number of messages to return\n    ///   - offset: Number of messages to skip for pagination\n    /// - Returns: Array of messages ordered by date received (newest first)\n    public func getAllMessages(limit: Int = 100, offset: Int = 0) throws -> [MailMessage] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let query = \"\"\"\n            SELECT * FROM messages\n            WHERE is_deleted = 0\n            ORDER BY date_received DESC\n            LIMIT \\(limit) OFFSET \\(offset)\n            \"\"\"\n\n        let result = try conn.query(query)\n        var messages: [MailMessage] = []\n        for row in result {\n            if let message = try? rowToMessage(row) {\n                messages.append(message)\n            }\n        }\n        return messages\n    }\n\n    /// Get messages that haven't been exported yet (export_path IS NULL)\n    /// Used for incremental auto-export after sync\n    /// - Parameter limit: Maximum number of messages to return (default: unlimited via 0)\n    /// - Returns: Array of messages that need to be exported\n    public func getMessagesNeedingExport(limit: Int = 0) throws -> [MailMessage] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        var query = \"\"\"\n            SELECT * FROM messages\n            WHERE is_deleted = 0 AND export_path IS NULL\n            ORDER BY date_received DESC\n            \"\"\"\n\n        if limit > 0 {\n            query += \" LIMIT \\(limit)\"\n        }\n\n        let result = try conn.query(query)\n        var messages: [MailMessage] = []\n        for row in result {\n            if let message = try? rowToMessage(row) {\n                messages.append(message)\n            }\n        }\n        return messages\n    }\n\n    /// Update the export path for a message\n    public func updateExportPath(id: String, path: String) throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let now = Int(Date().timeIntervalSince1970)\n        _ = try conn.execute(\"\"\"\n            UPDATE messages SET export_path = '\\(escapeSql(path))', updated_at = \\(now)\n            WHERE id = '\\(escapeSql(id))'\n            \"\"\")\n    }\n\n    /// Update the body content for a message (on-demand fetching)\n    /// - Parameters:\n    ///   - id: The message ID\n    ///   - bodyText: Plain text body content (optional)\n    ///   - bodyHtml: HTML body content (optional)\n    public func updateMessageBody(id: String, bodyText: String?, bodyHtml: String?) throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let now = Int(Date().timeIntervalSince1970)\n        _ = try conn.execute(\"\"\"\n            UPDATE messages SET\n                body_text = \\(bodyText.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                body_html = \\(bodyHtml.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                updated_at = \\(now)\n            WHERE id = '\\(escapeSql(id))'\n            \"\"\")\n    }\n\n    // MARK: - Sync Status Operations\n\n    /// Sync status key constants\n    public enum SyncStatusKey {\n        public static let state = \"sync_state\"\n        public static let lastSyncTime = \"last_sync_time\"\n        public static let lastSyncStartTime = \"last_sync_start_time\"\n        public static let lastSyncEndTime = \"last_sync_end_time\"\n        public static let lastSyncError = \"last_sync_error\"\n        public static let lastSyncMessagesAdded = \"last_sync_messages_added\"\n        public static let lastSyncMessagesUpdated = \"last_sync_messages_updated\"\n        public static let lastSyncMessagesDeleted = \"last_sync_messages_deleted\"\n        public static let lastSyncDuration = \"last_sync_duration\"\n        public static let lastSyncIsIncremental = \"last_sync_is_incremental\"\n    }\n\n    /// Sync state values\n    public enum SyncState: String {\n        case idle = \"idle\"\n        case running = \"running\"\n        case success = \"success\"\n        case failed = \"failed\"\n    }\n\n    /// Summary of sync status for reporting\n    public struct SyncStatusSummary {\n        public let state: SyncState\n        public let lastSyncTime: Date?\n        public let lastSyncStartTime: Date?\n        public let lastSyncEndTime: Date?\n        public let lastSyncError: String?\n        public let messagesAdded: Int\n        public let messagesUpdated: Int\n        public let messagesDeleted: Int\n        public let duration: TimeInterval?\n        public let isIncremental: Bool?\n\n        public init(\n            state: SyncState,\n            lastSyncTime: Date? = nil,\n            lastSyncStartTime: Date? = nil,\n            lastSyncEndTime: Date? = nil,\n            lastSyncError: String? = nil,\n            messagesAdded: Int = 0,\n            messagesUpdated: Int = 0,\n            messagesDeleted: Int = 0,\n            duration: TimeInterval? = nil,\n            isIncremental: Bool? = nil\n        ) {\n            self.state = state\n            self.lastSyncTime = lastSyncTime\n            self.lastSyncStartTime = lastSyncStartTime\n            self.lastSyncEndTime = lastSyncEndTime\n            self.lastSyncError = lastSyncError\n            self.messagesAdded = messagesAdded\n            self.messagesUpdated = messagesUpdated\n            self.messagesDeleted = messagesDeleted\n            self.duration = duration\n            self.isIncremental = isIncremental\n        }\n    }\n\n    /// Get a sync status value\n    public func getSyncStatus(key: String) throws -> String? {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"SELECT value FROM sync_status WHERE key = '\\(escapeSql(key))'\")\n\n        for row in result {\n            return try row.getString(0)\n        }\n        return nil\n    }\n\n    /// Set a sync status value\n    public func setSyncStatus(key: String, value: String) throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let now = Int(Date().timeIntervalSince1970)\n        _ = try conn.execute(\"\"\"\n            INSERT INTO sync_status (key, value, updated_at)\n            VALUES ('\\(escapeSql(key))', '\\(escapeSql(value))', \\(now))\n            ON CONFLICT(key) DO UPDATE SET\n                value = excluded.value,\n                updated_at = excluded.updated_at\n            \"\"\")\n    }\n\n    /// Get the last sync timestamp\n    public func getLastSyncTime() throws -> Date? {\n        if let value = try getSyncStatus(key: \"last_sync_time\"),\n           let timestamp = Double(value) {\n            return Date(timeIntervalSince1970: timestamp)\n        }\n        return nil\n    }\n\n    /// Set the last sync timestamp\n    public func setLastSyncTime(_ date: Date) throws {\n        try setSyncStatus(key: SyncStatusKey.lastSyncTime, value: String(date.timeIntervalSince1970))\n    }\n\n    /// Record that a sync operation has started\n    public func recordSyncStart(isIncremental: Bool) throws {\n        let now = Date()\n        try setSyncStatus(key: SyncStatusKey.state, value: SyncState.running.rawValue)\n        try setSyncStatus(key: SyncStatusKey.lastSyncStartTime, value: String(now.timeIntervalSince1970))\n        try setSyncStatus(key: SyncStatusKey.lastSyncIsIncremental, value: isIncremental ? \"1\" : \"0\")\n        // Clear previous error\n        try setSyncStatus(key: SyncStatusKey.lastSyncError, value: \"\")\n    }\n\n    /// Record successful sync completion\n    public func recordSyncSuccess(result: SyncResult) throws {\n        let now = Date()\n        try setSyncStatus(key: SyncStatusKey.state, value: SyncState.success.rawValue)\n        try setSyncStatus(key: SyncStatusKey.lastSyncEndTime, value: String(now.timeIntervalSince1970))\n        try setSyncStatus(key: SyncStatusKey.lastSyncTime, value: String(now.timeIntervalSince1970))\n        try setSyncStatus(key: SyncStatusKey.lastSyncMessagesAdded, value: String(result.messagesAdded))\n        try setSyncStatus(key: SyncStatusKey.lastSyncMessagesUpdated, value: String(result.messagesUpdated))\n        try setSyncStatus(key: SyncStatusKey.lastSyncMessagesDeleted, value: String(result.messagesDeleted))\n        try setSyncStatus(key: SyncStatusKey.lastSyncDuration, value: String(result.duration))\n        try setSyncStatus(key: SyncStatusKey.lastSyncError, value: \"\")\n    }\n\n    /// Record sync failure\n    public func recordSyncFailure(error: Error) throws {\n        let now = Date()\n        try setSyncStatus(key: SyncStatusKey.state, value: SyncState.failed.rawValue)\n        try setSyncStatus(key: SyncStatusKey.lastSyncEndTime, value: String(now.timeIntervalSince1970))\n        try setSyncStatus(key: SyncStatusKey.lastSyncError, value: error.localizedDescription)\n    }\n\n    /// Get a summary of the current sync status\n    public func getSyncStatusSummary() throws -> SyncStatusSummary {\n        let stateStr = try getSyncStatus(key: SyncStatusKey.state)\n        let state = stateStr.flatMap { SyncState(rawValue: $0) } ?? .idle\n\n        let lastSyncTime = try getSyncStatus(key: SyncStatusKey.lastSyncTime)\n            .flatMap { Double($0) }\n            .map { Date(timeIntervalSince1970: $0) }\n\n        let lastSyncStartTime = try getSyncStatus(key: SyncStatusKey.lastSyncStartTime)\n            .flatMap { Double($0) }\n            .map { Date(timeIntervalSince1970: $0) }\n\n        let lastSyncEndTime = try getSyncStatus(key: SyncStatusKey.lastSyncEndTime)\n            .flatMap { Double($0) }\n            .map { Date(timeIntervalSince1970: $0) }\n\n        let lastSyncError = try getSyncStatus(key: SyncStatusKey.lastSyncError)\n            .flatMap { $0.isEmpty ? nil : $0 }\n\n        let messagesAdded = try getSyncStatus(key: SyncStatusKey.lastSyncMessagesAdded)\n            .flatMap { Int($0) } ?? 0\n\n        let messagesUpdated = try getSyncStatus(key: SyncStatusKey.lastSyncMessagesUpdated)\n            .flatMap { Int($0) } ?? 0\n\n        let messagesDeleted = try getSyncStatus(key: SyncStatusKey.lastSyncMessagesDeleted)\n            .flatMap { Int($0) } ?? 0\n\n        let duration = try getSyncStatus(key: SyncStatusKey.lastSyncDuration)\n            .flatMap { Double($0) }\n\n        let isIncremental = try getSyncStatus(key: SyncStatusKey.lastSyncIsIncremental)\n            .map { $0 == \"1\" }\n\n        return SyncStatusSummary(\n            state: state,\n            lastSyncTime: lastSyncTime,\n            lastSyncStartTime: lastSyncStartTime,\n            lastSyncEndTime: lastSyncEndTime,\n            lastSyncError: lastSyncError,\n            messagesAdded: messagesAdded,\n            messagesUpdated: messagesUpdated,\n            messagesDeleted: messagesDeleted,\n            duration: duration,\n            isIncremental: isIncremental\n        )\n    }\n\n    // MARK: - Mailbox Operations\n\n    /// Upsert a mailbox\n    public func upsertMailbox(_ mailbox: Mailbox) throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let now = Int(Date().timeIntervalSince1970)\n        _ = try conn.execute(\"\"\"\n            INSERT INTO mailboxes (id, account_id, name, full_path, parent_id, message_count, unread_count, synced_at)\n            VALUES (\\(mailbox.id), '\\(escapeSql(mailbox.accountId))', '\\(escapeSql(mailbox.name))',\n                    '\\(escapeSql(mailbox.fullPath))', \\(mailbox.parentId ?? 0), \\(mailbox.messageCount),\n                    \\(mailbox.unreadCount), \\(now))\n            ON CONFLICT(id) DO UPDATE SET\n                account_id = excluded.account_id,\n                name = excluded.name,\n                full_path = excluded.full_path,\n                parent_id = excluded.parent_id,\n                message_count = excluded.message_count,\n                unread_count = excluded.unread_count,\n                synced_at = excluded.synced_at\n            \"\"\")\n    }\n\n    /// Get all mailboxes\n    public func getMailboxes() throws -> [Mailbox] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"SELECT * FROM mailboxes ORDER BY full_path\")\n\n        var mailboxes: [Mailbox] = []\n        for row in result {\n            if let mailbox = try? rowToMailbox(row) {\n                mailboxes.append(mailbox)\n            }\n        }\n        return mailboxes\n    }\n\n    // MARK: - FTS5 Trigger Management\n\n    /// Disable FTS5 triggers to prevent per-row FTS updates during bulk operations.\n    /// Call `rebuildFTSIndex()` after bulk operations complete to sync the FTS index.\n    public func disableFTSTriggers() throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        _ = try conn.execute(\"DROP TRIGGER IF EXISTS messages_ai\")\n        _ = try conn.execute(\"DROP TRIGGER IF EXISTS messages_ad\")\n        _ = try conn.execute(\"DROP TRIGGER IF EXISTS messages_au\")\n    }\n\n    /// Re-enable FTS5 triggers for incremental updates after bulk operations.\n    public func enableFTSTriggers() throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        // Recreate the triggers (same as in migration)\n        _ = try conn.execute(\"\"\"\n            CREATE TRIGGER IF NOT EXISTS messages_ai AFTER INSERT ON messages BEGIN\n                INSERT INTO messages_fts(rowid, subject, sender_name, sender_email, body_text)\n                VALUES (NEW.rowid, NEW.subject, NEW.sender_name, NEW.sender_email, NEW.body_text);\n            END\n            \"\"\")\n\n        _ = try conn.execute(\"\"\"\n            CREATE TRIGGER IF NOT EXISTS messages_ad AFTER DELETE ON messages BEGIN\n                INSERT INTO messages_fts(messages_fts, rowid, subject, sender_name, sender_email, body_text)\n                VALUES ('delete', OLD.rowid, OLD.subject, OLD.sender_name, OLD.sender_email, OLD.body_text);\n            END\n            \"\"\")\n\n        _ = try conn.execute(\"\"\"\n            CREATE TRIGGER IF NOT EXISTS messages_au AFTER UPDATE ON messages BEGIN\n                INSERT INTO messages_fts(messages_fts, rowid, subject, sender_name, sender_email, body_text)\n                VALUES ('delete', OLD.rowid, OLD.subject, OLD.sender_name, OLD.sender_email, OLD.body_text);\n                INSERT INTO messages_fts(rowid, subject, sender_name, sender_email, body_text)\n                VALUES (NEW.rowid, NEW.subject, NEW.sender_name, NEW.sender_email, NEW.body_text);\n            END\n            \"\"\")\n    }\n\n    /// Rebuild the FTS5 index from scratch using the messages table content.\n    /// This is much faster than per-row trigger updates for bulk operations.\n    /// Should be called after `disableFTSTriggers()` + bulk operations.\n    public func rebuildFTSIndex() throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        // Delete all FTS content and rebuild from the messages table\n        // The 'rebuild' command is a special FTS5 command that repopulates from the content table\n        _ = try conn.execute(\"INSERT INTO messages_fts(messages_fts) VALUES('rebuild')\")\n    }\n\n    // MARK: - Batch Insert Operations\n\n    /// Configuration for batch insert operations\n    public struct BatchInsertConfig: Sendable {\n        /// Number of messages to insert per transaction batch\n        public let batchSize: Int\n\n        /// Whether to disable FTS triggers during bulk operations (recommended for large syncs)\n        public let disableFTSTriggersForBulk: Bool\n\n        /// Default configuration with batch size of 1000 and FTS trigger optimization enabled\n        public static let `default` = BatchInsertConfig(batchSize: 1000, disableFTSTriggersForBulk: true)\n\n        public init(batchSize: Int = 1000, disableFTSTriggersForBulk: Bool = true) {\n            self.batchSize = max(1, batchSize)  // Ensure at least 1\n            self.disableFTSTriggersForBulk = disableFTSTriggersForBulk\n        }\n    }\n\n    /// Result of a batch insert operation\n    public struct BatchInsertResult: Sendable {\n        public let inserted: Int\n        public let updated: Int\n        public let failed: Int\n        public let errors: [String]\n        public let duration: TimeInterval\n\n        public init(inserted: Int, updated: Int, failed: Int, errors: [String], duration: TimeInterval) {\n            self.inserted = inserted\n            self.updated = updated\n            self.failed = failed\n            self.errors = errors\n            self.duration = duration\n        }\n    }\n\n    /// Insert or update multiple messages in batched transactions for improved performance.\n    /// Each batch is wrapped in a transaction for atomicity - if any insert in a batch fails,\n    /// the entire batch is rolled back.\n    ///\n    /// When `config.disableFTSTriggersForBulk` is true (default), FTS5 triggers are disabled\n    /// during the bulk operation and the FTS index is rebuilt once at the end. This prevents\n    /// the O(n^2) slowdown caused by per-row FTS trigger updates.\n    ///\n    /// - Parameters:\n    ///   - messages: Array of messages to insert/update\n    ///   - config: Batch configuration (default batch size: 1000)\n    /// - Returns: Result with counts and any errors\n    public func batchUpsertMessages(_ messages: [MailMessage], config: BatchInsertConfig = .default) throws -> BatchInsertResult {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let startTime = Date()\n        var totalInserted = 0\n        var totalUpdated = 0\n        var totalFailed = 0\n        var errors: [String] = []\n\n        let now = Int(Date().timeIntervalSince1970)\n\n        // Disable FTS triggers for bulk operations to prevent per-row FTS updates\n        // This is critical for performance: without this, second sync takes 5+ minutes\n        // because each UPDATE fires 2 FTS operations (delete old + insert new)\n        if config.disableFTSTriggersForBulk {\n            try disableFTSTriggers()\n        }\n\n        defer {\n            // Always re-enable triggers and rebuild FTS index\n            if config.disableFTSTriggersForBulk {\n                do {\n                    try rebuildFTSIndex()\n                    try enableFTSTriggers()\n                } catch {\n                    errors.append(\"FTS rebuild failed: \\(error.localizedDescription)\")\n                }\n            }\n        }\n\n        // Process in batches\n        let batches = stride(from: 0, to: messages.count, by: config.batchSize).map { startIndex in\n            let endIndex = min(startIndex + config.batchSize, messages.count)\n            return Array(messages[startIndex..<endIndex])\n        }\n\n        for (batchIndex, batch) in batches.enumerated() {\n            do {\n                let (inserted, updated) = try executeBatchTransaction(batch, connection: conn, timestamp: now)\n                totalInserted += inserted\n                totalUpdated += updated\n            } catch {\n                // Batch failed - record error and count all messages in batch as failed\n                totalFailed += batch.count\n                errors.append(\"Batch \\(batchIndex + 1) failed: \\(error.localizedDescription)\")\n            }\n        }\n\n        let duration = Date().timeIntervalSince(startTime)\n        return BatchInsertResult(\n            inserted: totalInserted,\n            updated: totalUpdated,\n            failed: totalFailed,\n            errors: errors,\n            duration: duration\n        )\n    }\n\n    /// Execute a single batch of inserts within a transaction\n    private func executeBatchTransaction(_ messages: [MailMessage], connection conn: Connection, timestamp: Int) throws -> (inserted: Int, updated: Int) {\n        var inserted = 0\n        var updated = 0\n\n        // Begin transaction\n        _ = try conn.execute(\"BEGIN TRANSACTION\")\n\n        do {\n            for message in messages {\n                // Check if message exists (for tracking insert vs update)\n                let existsResult = try conn.query(\"SELECT 1 FROM messages WHERE id = '\\(escapeSql(message.id))' LIMIT 1\")\n                var exists = false\n                for _ in existsResult {\n                    exists = true\n                    break\n                }\n\n                // Serialize references to JSON for storage\n                let referencesJson = serializeReferences(message.references)\n\n                // Execute upsert\n                _ = try conn.execute(\"\"\"\n                    INSERT INTO messages (\n                        id, apple_rowid, message_id, mailbox_id, mailbox_name, account_id,\n                        subject, sender_name, sender_email, date_sent, date_received,\n                        is_read, is_flagged, is_deleted, has_attachments, emlx_path,\n                        body_text, body_html, synced_at, updated_at,\n                        mailbox_status, pending_sync_action, last_known_mailbox_id,\n                        in_reply_to, threading_references, thread_id,\n                        thread_position, thread_total\n                    ) VALUES (\n                        '\\(escapeSql(message.id))', \\(message.appleRowId ?? 0), \\(message.messageId.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                        \\(message.mailboxId ?? 0), \\(message.mailboxName.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                        \\(message.accountId.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                        '\\(escapeSql(message.subject))', \\(message.senderName.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                        \\(message.senderEmail.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                        \\(message.dateSent.map { Int($0.timeIntervalSince1970) } ?? 0),\n                        \\(message.dateReceived.map { Int($0.timeIntervalSince1970) } ?? 0),\n                        \\(message.isRead ? 1 : 0), \\(message.isFlagged ? 1 : 0), \\(message.isDeleted ? 1 : 0),\n                        \\(message.hasAttachments ? 1 : 0), \\(message.emlxPath.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                        \\(message.bodyText.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                        \\(message.bodyHtml.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                        \\(timestamp), \\(timestamp),\n                        '\\(message.mailboxStatus.rawValue)',\n                        \\(message.pendingSyncAction.map { \"'\\($0.rawValue)'\" } ?? \"NULL\"),\n                        \\(message.lastKnownMailboxId.map { String($0) } ?? \"NULL\"),\n                        \\(message.inReplyTo.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                        \\(referencesJson.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                        \\(message.threadId.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                        \\(message.threadPosition.map { String($0) } ?? \"NULL\"),\n                        \\(message.threadTotal.map { String($0) } ?? \"NULL\")\n                    )\n                    ON CONFLICT(id) DO UPDATE SET\n                        apple_rowid = excluded.apple_rowid,\n                        message_id = excluded.message_id,\n                        mailbox_id = excluded.mailbox_id,\n                        mailbox_name = excluded.mailbox_name,\n                        account_id = excluded.account_id,\n                        subject = excluded.subject,\n                        sender_name = excluded.sender_name,\n                        sender_email = excluded.sender_email,\n                        date_sent = excluded.date_sent,\n                        date_received = excluded.date_received,\n                        is_read = excluded.is_read,\n                        is_flagged = excluded.is_flagged,\n                        is_deleted = excluded.is_deleted,\n                        has_attachments = excluded.has_attachments,\n                        emlx_path = excluded.emlx_path,\n                        body_text = excluded.body_text,\n                        body_html = excluded.body_html,\n                        updated_at = \\(timestamp),\n                        mailbox_status = excluded.mailbox_status,\n                        pending_sync_action = excluded.pending_sync_action,\n                        last_known_mailbox_id = excluded.last_known_mailbox_id,\n                        in_reply_to = excluded.in_reply_to,\n                        threading_references = excluded.threading_references,\n                        thread_id = excluded.thread_id,\n                        thread_position = excluded.thread_position,\n                        thread_total = excluded.thread_total\n                    \"\"\")\n\n                if exists {\n                    updated += 1\n                } else {\n                    inserted += 1\n                }\n            }\n\n            // Commit transaction\n            _ = try conn.execute(\"COMMIT\")\n\n            return (inserted, updated)\n        } catch {\n            // Rollback on any error\n            _ = try? conn.execute(\"ROLLBACK\")\n            throw error\n        }\n    }\n\n    /// Insert or update multiple mailboxes in a single transaction for improved performance.\n    ///\n    /// - Parameter mailboxes: Array of mailboxes to insert/update\n    public func batchUpsertMailboxes(_ mailboxes: [Mailbox]) throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let now = Int(Date().timeIntervalSince1970)\n\n        // Begin transaction\n        _ = try conn.execute(\"BEGIN TRANSACTION\")\n\n        do {\n            for mailbox in mailboxes {\n                _ = try conn.execute(\"\"\"\n                    INSERT INTO mailboxes (id, account_id, name, full_path, parent_id, message_count, unread_count, synced_at)\n                    VALUES (\\(mailbox.id), '\\(escapeSql(mailbox.accountId))', '\\(escapeSql(mailbox.name))',\n                            '\\(escapeSql(mailbox.fullPath))', \\(mailbox.parentId ?? 0), \\(mailbox.messageCount),\n                            \\(mailbox.unreadCount), \\(now))\n                    ON CONFLICT(id) DO UPDATE SET\n                        account_id = excluded.account_id,\n                        name = excluded.name,\n                        full_path = excluded.full_path,\n                        parent_id = excluded.parent_id,\n                        message_count = excluded.message_count,\n                        unread_count = excluded.unread_count,\n                        synced_at = excluded.synced_at\n                    \"\"\")\n            }\n\n            // Commit transaction\n            _ = try conn.execute(\"COMMIT\")\n        } catch {\n            // Rollback on any error\n            _ = try? conn.execute(\"ROLLBACK\")\n            throw error\n        }\n    }\n\n    // MARK: - Incremental Sync Support\n\n    /// Represents minimal message status info for change detection\n    public struct MessageStatus {\n        public let id: String\n        public let appleRowId: Int\n        public let isRead: Bool\n        public let isFlagged: Bool\n    }\n\n    /// Get all message statuses for change detection\n    public func getAllMessageStatuses() throws -> [MessageStatus] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"\"\"\n            SELECT id, apple_rowid, is_read, is_flagged\n            FROM messages\n            WHERE is_deleted = 0 AND apple_rowid IS NOT NULL\n            \"\"\")\n\n        var statuses: [MessageStatus] = []\n        for row in result {\n            guard let id = getStringValue(row, 0),\n                  let appleRowId = getIntValue(row, 1) else {\n                continue\n            }\n            let isRead = (getIntValue(row, 2) ?? 0) == 1\n            let isFlagged = (getIntValue(row, 3) ?? 0) == 1\n            statuses.append(MessageStatus(id: id, appleRowId: appleRowId, isRead: isRead, isFlagged: isFlagged))\n        }\n        return statuses\n    }\n\n    /// Update the read/flagged status of a message\n    public func updateMessageStatus(id: String, isRead: Bool, isFlagged: Bool) throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let now = Int(Date().timeIntervalSince1970)\n        _ = try conn.execute(\"\"\"\n            UPDATE messages\n            SET is_read = \\(isRead ? 1 : 0), is_flagged = \\(isFlagged ? 1 : 0), updated_at = \\(now)\n            WHERE id = '\\(escapeSql(id))'\n            \"\"\")\n    }\n\n    /// Get all Apple rowids from the mirror for deletion detection\n    public func getAllAppleRowIds() throws -> [Int] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"\"\"\n            SELECT apple_rowid FROM messages\n            WHERE is_deleted = 0 AND apple_rowid IS NOT NULL\n            \"\"\")\n\n        var rowIds: [Int] = []\n        for row in result {\n            if let rowId = getIntValue(row, 0) {\n                rowIds.append(rowId)\n            }\n        }\n        return rowIds\n    }\n\n    /// Mark a message as deleted (soft delete)\n    public func markMessageDeleted(appleRowId: Int) throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let now = Int(Date().timeIntervalSince1970)\n        _ = try conn.execute(\"\"\"\n            UPDATE messages SET is_deleted = 1, updated_at = \\(now)\n            WHERE apple_rowid = \\(appleRowId)\n            \"\"\")\n    }\n\n    // MARK: - Mailbox Status Operations (Bidirectional Sync)\n\n    /// Update the mailbox status of a message\n    /// - Parameters:\n    ///   - id: The message ID\n    ///   - status: The new mailbox status (inbox, archived, deleted)\n    public func updateMailboxStatus(id: String, status: MailboxStatus) throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let now = Int(Date().timeIntervalSince1970)\n        _ = try conn.execute(\"\"\"\n            UPDATE messages SET mailbox_status = '\\(status.rawValue)', updated_at = \\(now)\n            WHERE id = '\\(escapeSql(id))'\n            \"\"\")\n    }\n\n    /// Set a pending sync action for a message\n    /// - Parameters:\n    ///   - id: The message ID\n    ///   - action: The sync action to queue (archive or delete)\n    public func setPendingSyncAction(id: String, action: SyncAction) throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let now = Int(Date().timeIntervalSince1970)\n        _ = try conn.execute(\"\"\"\n            UPDATE messages SET pending_sync_action = '\\(action.rawValue)', updated_at = \\(now)\n            WHERE id = '\\(escapeSql(id))'\n            \"\"\")\n    }\n\n    /// Clear the pending sync action for a message (after successful sync)\n    /// - Parameter id: The message ID\n    public func clearPendingSyncAction(id: String) throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let now = Int(Date().timeIntervalSince1970)\n        _ = try conn.execute(\"\"\"\n            UPDATE messages SET pending_sync_action = NULL, updated_at = \\(now)\n            WHERE id = '\\(escapeSql(id))'\n            \"\"\")\n    }\n\n    /// Get all messages with pending sync actions\n    /// - Returns: Array of messages that have pending actions to sync to Apple Mail\n    public func getMessagesWithPendingActions() throws -> [MailMessage] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"\"\"\n            SELECT * FROM messages\n            WHERE pending_sync_action IS NOT NULL AND is_deleted = 0\n            ORDER BY updated_at ASC\n            \"\"\")\n\n        var messages: [MailMessage] = []\n        for row in result {\n            if let message = try? rowToMessage(row) {\n                messages.append(message)\n            }\n        }\n        return messages\n    }\n\n    /// Get messages filtered by mailbox status\n    /// - Parameters:\n    ///   - status: The mailbox status to filter by\n    ///   - limit: Maximum number of messages to return (default: 100)\n    ///   - offset: Number of messages to skip for pagination (default: 0)\n    /// - Returns: Array of messages with the specified status\n    public func getMessagesByStatus(_ status: MailboxStatus, limit: Int = 100, offset: Int = 0) throws -> [MailMessage] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"\"\"\n            SELECT * FROM messages\n            WHERE mailbox_status = '\\(status.rawValue)' AND is_deleted = 0\n            ORDER BY date_received DESC\n            LIMIT \\(limit) OFFSET \\(offset)\n            \"\"\")\n\n        var messages: [MailMessage] = []\n        for row in result {\n            if let message = try? rowToMessage(row) {\n                messages.append(message)\n            }\n        }\n        return messages\n    }\n\n    /// Get message counts grouped by mailbox status\n    /// - Returns: Dictionary with status as key and count as value\n    public func getMessageCountByStatus() throws -> [MailboxStatus: Int] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"\"\"\n            SELECT mailbox_status, COUNT(*) as count FROM messages\n            WHERE is_deleted = 0\n            GROUP BY mailbox_status\n            \"\"\")\n\n        var counts: [MailboxStatus: Int] = [\n            .inbox: 0,\n            .archived: 0,\n            .deleted: 0\n        ]\n\n        for row in result {\n            if let statusStr = getStringValue(row, 0),\n               let status = MailboxStatus(rawValue: statusStr),\n               let count = getIntValue(row, 1) {\n                counts[status] = count\n            }\n        }\n        return counts\n    }\n\n    /// Represents tracked message info for mailbox move detection\n    public struct TrackedMessageInfo {\n        public let id: String\n        public let appleRowId: Int\n        public let mailboxId: Int?\n        public let mailboxStatus: MailboxStatus\n    }\n\n    /// Get all tracked messages with their mailbox IDs for move detection\n    /// This includes all messages (inbox, archived, deleted status) so we can detect\n    /// when messages move between mailboxes, including moves back to INBOX.\n    /// - Returns: Array of tracked message info for all non-soft-deleted messages\n    public func getTrackedInboxMessages() throws -> [TrackedMessageInfo] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"\"\"\n            SELECT id, apple_rowid, mailbox_id, mailbox_status\n            FROM messages\n            WHERE is_deleted = 0\n              AND apple_rowid IS NOT NULL\n            \"\"\")\n\n        var messages: [TrackedMessageInfo] = []\n        for row in result {\n            guard let id = getStringValue(row, 0),\n                  let appleRowId = getIntValue(row, 1) else {\n                continue\n            }\n            let mailboxId = getIntValue(row, 2)\n            let statusStr = getStringValue(row, 3)\n            let status = statusStr.flatMap { MailboxStatus(rawValue: $0) } ?? .inbox\n\n            messages.append(TrackedMessageInfo(\n                id: id,\n                appleRowId: appleRowId,\n                mailboxId: mailboxId,\n                mailboxStatus: status\n            ))\n        }\n        return messages\n    }\n\n    // MARK: - Thread Operations\n\n    /// Insert or update a thread in the database\n    public func upsertThread(_ thread: Thread) throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let now = Int(Date().timeIntervalSince1970)\n\n        _ = try conn.execute(\"\"\"\n            INSERT INTO threads (\n                id, subject, participant_count, message_count, first_date, last_date,\n                created_at, updated_at\n            ) VALUES (\n                '\\(escapeSql(thread.id))',\n                \\(thread.subject.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                \\(thread.participantCount),\n                \\(thread.messageCount),\n                \\(thread.firstDate.map { String(Int($0.timeIntervalSince1970)) } ?? \"NULL\"),\n                \\(thread.lastDate.map { String(Int($0.timeIntervalSince1970)) } ?? \"NULL\"),\n                \\(now), \\(now)\n            )\n            ON CONFLICT(id) DO UPDATE SET\n                subject = COALESCE(excluded.subject, threads.subject),\n                participant_count = excluded.participant_count,\n                message_count = excluded.message_count,\n                first_date = MIN(COALESCE(threads.first_date, excluded.first_date), COALESCE(excluded.first_date, threads.first_date)),\n                last_date = MAX(COALESCE(threads.last_date, excluded.last_date), COALESCE(excluded.last_date, threads.last_date)),\n                updated_at = \\(now)\n            \"\"\")\n    }\n\n    /// Get a thread by its ID\n    public func getThread(id: String) throws -> Thread? {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"SELECT * FROM threads WHERE id = '\\(escapeSql(id))'\")\n\n        for row in result {\n            return try rowToThread(row)\n        }\n        return nil\n    }\n\n    /// Get all threads, ordered by last date descending\n    public func getThreads(limit: Int = 100, offset: Int = 0) throws -> [Thread] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"\"\"\n            SELECT * FROM threads\n            ORDER BY last_date DESC\n            LIMIT \\(limit) OFFSET \\(offset)\n            \"\"\")\n\n        var threads: [Thread] = []\n        for row in result {\n            if let thread = try? rowToThread(row) {\n                threads.append(thread)\n            }\n        }\n        return threads\n    }\n\n    /// Get threads with filtering and sorting options\n    /// - Parameters:\n    ///   - limit: Maximum number of threads to return\n    ///   - offset: Number of threads to skip (for pagination)\n    ///   - sortBy: Sort order for results\n    ///   - participant: Filter by participant email (matches sender or recipient)\n    /// - Returns: Array of threads matching the criteria\n    public func getThreads(\n        limit: Int = 100,\n        offset: Int = 0,\n        sortBy: ThreadSortOrder = .date,\n        participant: String? = nil\n    ) throws -> [Thread] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        var sql: String\n        if let participant = participant {\n            // Filter threads by participant (sender or recipient in any message)\n            // Uses EXISTS subqueries for better query plan optimization vs JOINs\n            // Note: LIKE with leading % cannot use indexes, but EXISTS limits the scan\n            // to messages within each thread rather than a full cross-join\n            let escaped = escapeSql(participant.lowercased())\n            sql = \"\"\"\n                SELECT t.* FROM threads t\n                WHERE EXISTS (\n                    SELECT 1 FROM thread_messages tm\n                    JOIN messages m ON tm.message_id = m.id\n                    WHERE tm.thread_id = t.id\n                    AND LOWER(m.sender_email) LIKE '%\\(escaped)%'\n                )\n                OR EXISTS (\n                    SELECT 1 FROM thread_messages tm\n                    JOIN messages m ON tm.message_id = m.id\n                    JOIN recipients r ON m.id = r.message_id\n                    WHERE tm.thread_id = t.id\n                    AND LOWER(r.email) LIKE '%\\(escaped)%'\n                )\n                ORDER BY t.\\(sortBy.sqlOrderBy)\n                LIMIT \\(limit) OFFSET \\(offset)\n                \"\"\"\n        } else {\n            sql = \"\"\"\n                SELECT * FROM threads\n                ORDER BY \\(sortBy.sqlOrderBy)\n                LIMIT \\(limit) OFFSET \\(offset)\n                \"\"\"\n        }\n\n        let result = try conn.query(sql)\n\n        var threads: [Thread] = []\n        for row in result {\n            if let thread = try? rowToThread(row) {\n                threads.append(thread)\n            }\n        }\n        return threads\n    }\n\n    /// Get count of threads matching filter criteria\n    /// - Parameter participant: Filter by participant email (matches sender or recipient)\n    /// - Returns: Count of matching threads\n    public func getThreadCount(participant: String? = nil) throws -> Int {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        var sql: String\n        if let participant = participant {\n            // Use EXISTS subqueries for efficient counting with participant filter\n            let escaped = escapeSql(participant.lowercased())\n            sql = \"\"\"\n                SELECT COUNT(*) FROM threads t\n                WHERE EXISTS (\n                    SELECT 1 FROM thread_messages tm\n                    JOIN messages m ON tm.message_id = m.id\n                    WHERE tm.thread_id = t.id\n                    AND LOWER(m.sender_email) LIKE '%\\(escaped)%'\n                )\n                OR EXISTS (\n                    SELECT 1 FROM thread_messages tm\n                    JOIN messages m ON tm.message_id = m.id\n                    JOIN recipients r ON m.id = r.message_id\n                    WHERE tm.thread_id = t.id\n                    AND LOWER(r.email) LIKE '%\\(escaped)%'\n                )\n                \"\"\"\n        } else {\n            sql = \"SELECT COUNT(*) FROM threads\"\n        }\n\n        let result = try conn.query(sql)\n        for row in result {\n            return getIntValue(row, 0) ?? 0\n        }\n        return 0\n    }\n\n    /// Get all messages in a thread\n    public func getMessagesInThread(threadId: String, limit: Int = 100, offset: Int = 0) throws -> [MailMessage] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"\"\"\n            SELECT * FROM messages\n            WHERE thread_id = '\\(escapeSql(threadId))' AND is_deleted = 0\n            ORDER BY date_received ASC\n            LIMIT \\(limit) OFFSET \\(offset)\n            \"\"\")\n\n        var messages: [MailMessage] = []\n        for row in result {\n            if let message = try? rowToMessage(row) {\n                messages.append(message)\n            }\n        }\n        return messages\n    }\n\n    /// Update the thread_id for a message\n    public func updateMessageThreadId(messageId: String, threadId: String) throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let now = Int(Date().timeIntervalSince1970)\n        _ = try conn.execute(\"\"\"\n            UPDATE messages SET thread_id = '\\(escapeSql(threadId))', updated_at = \\(now)\n            WHERE id = '\\(escapeSql(messageId))'\n            \"\"\")\n    }\n\n    /// Update the thread position metadata for a message\n    /// - Parameters:\n    ///   - messageId: The message ID to update\n    ///   - threadPosition: Position of the message within its thread (1-based)\n    ///   - threadTotal: Total number of messages in the thread\n    public func updateMessageThreadPosition(messageId: String, threadPosition: Int, threadTotal: Int) throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let now = Int(Date().timeIntervalSince1970)\n        _ = try conn.execute(\"\"\"\n            UPDATE messages SET thread_position = \\(threadPosition), thread_total = \\(threadTotal), updated_at = \\(now)\n            WHERE id = '\\(escapeSql(messageId))'\n            \"\"\")\n    }\n\n    /// Update thread position metadata for all messages in a thread\n    /// Uses batch update for efficiency with large threads\n    /// - Parameter threadId: The thread ID whose messages should be updated\n    public func updateThreadPositions(threadId: String) throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        // Get all messages in the thread ordered by date\n        let messages = try getMessagesInThreadViaJunction(threadId: threadId, limit: 10000, offset: 0)\n        let total = messages.count\n\n        if total == 0 {\n            return\n        }\n\n        // For small threads, use individual updates (simpler, avoids query size limits)\n        if total <= 10 {\n            for (index, message) in messages.enumerated() {\n                try updateMessageThreadPosition(messageId: message.id, threadPosition: index + 1, threadTotal: total)\n            }\n            return\n        }\n\n        // For larger threads, use batch update with CASE statement for efficiency\n        // This reduces N database round trips to just 1\n        let now = Int(Date().timeIntervalSince1970)\n\n        // Build CASE statement for positions\n        var caseClauses: [String] = []\n        var idList: [String] = []\n        for (index, message) in messages.enumerated() {\n            let escapedId = escapeSql(message.id)\n            caseClauses.append(\"WHEN '\\(escapedId)' THEN \\(index + 1)\")\n            idList.append(\"'\\(escapedId)'\")\n        }\n\n        let sql = \"\"\"\n            UPDATE messages SET\n                thread_position = CASE id\n                    \\(caseClauses.joined(separator: \"\\n                \"))\n                    ELSE thread_position\n                END,\n                thread_total = \\(total),\n                updated_at = \\(now)\n            WHERE id IN (\\(idList.joined(separator: \", \")))\n            \"\"\"\n\n        _ = try conn.execute(sql)\n    }\n\n    /// Get the count of threads\n    public func getThreadCount() throws -> Int {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"SELECT COUNT(*) FROM threads\")\n        for row in result {\n            return getIntValue(row, 0) ?? 0\n        }\n        return 0\n    }\n\n    // MARK: - Thread-Message Junction Operations\n\n    /// Add a message to a thread (creates the junction table entry)\n    /// - Parameters:\n    ///   - messageId: The message ID to add\n    ///   - threadId: The thread ID to add the message to\n    public func addMessageToThread(messageId: String, threadId: String) throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        _ = try conn.execute(\"\"\"\n            INSERT OR IGNORE INTO thread_messages (thread_id, message_id)\n            VALUES ('\\(escapeSql(threadId))', '\\(escapeSql(messageId))')\n            \"\"\")\n    }\n\n    /// Remove a message from a thread (deletes the junction table entry)\n    /// - Parameters:\n    ///   - messageId: The message ID to remove\n    ///   - threadId: The thread ID to remove the message from\n    public func removeMessageFromThread(messageId: String, threadId: String) throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        _ = try conn.execute(\"\"\"\n            DELETE FROM thread_messages\n            WHERE thread_id = '\\(escapeSql(threadId))' AND message_id = '\\(escapeSql(messageId))'\n            \"\"\")\n    }\n\n    /// Get all message IDs in a thread via the junction table\n    /// - Parameter threadId: The thread ID to query\n    /// - Returns: Array of message IDs in the thread\n    public func getMessageIdsInThread(threadId: String) throws -> [String] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"\"\"\n            SELECT message_id FROM thread_messages\n            WHERE thread_id = '\\(escapeSql(threadId))'\n            ORDER BY added_at ASC\n            \"\"\")\n\n        var messageIds: [String] = []\n        for row in result {\n            if let messageId = getStringValue(row, 0) {\n                messageIds.append(messageId)\n            }\n        }\n        return messageIds\n    }\n\n    /// Get all thread IDs that a message belongs to via the junction table\n    /// - Parameter messageId: The message ID to query\n    /// - Returns: Array of thread IDs the message belongs to\n    public func getThreadIdsForMessage(messageId: String) throws -> [String] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"\"\"\n            SELECT thread_id FROM thread_messages\n            WHERE message_id = '\\(escapeSql(messageId))'\n            ORDER BY added_at ASC\n            \"\"\")\n\n        var threadIds: [String] = []\n        for row in result {\n            if let threadId = getStringValue(row, 0) {\n                threadIds.append(threadId)\n            }\n        }\n        return threadIds\n    }\n\n    /// Get full messages in a thread via the junction table\n    /// - Parameters:\n    ///   - threadId: The thread ID to query\n    ///   - limit: Maximum number of messages to return\n    ///   - offset: Number of messages to skip for pagination\n    /// - Returns: Array of MailMessage objects in the thread\n    public func getMessagesInThreadViaJunction(threadId: String, limit: Int = 100, offset: Int = 0) throws -> [MailMessage] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"\"\"\n            SELECT m.* FROM messages m\n            JOIN thread_messages tm ON m.id = tm.message_id\n            WHERE tm.thread_id = '\\(escapeSql(threadId))' AND m.is_deleted = 0\n            ORDER BY m.date_received ASC\n            LIMIT \\(limit) OFFSET \\(offset)\n            \"\"\")\n\n        var messages: [MailMessage] = []\n        for row in result {\n            if let message = try? rowToMessage(row) {\n                messages.append(message)\n            }\n        }\n        return messages\n    }\n\n    /// Get full threads that a message belongs to via the junction table\n    /// - Parameter messageId: The message ID to query\n    /// - Returns: Array of Thread objects the message belongs to\n    public func getThreadsForMessage(messageId: String) throws -> [Thread] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"\"\"\n            SELECT t.* FROM threads t\n            JOIN thread_messages tm ON t.id = tm.thread_id\n            WHERE tm.message_id = '\\(escapeSql(messageId))'\n            ORDER BY t.last_date DESC\n            \"\"\")\n\n        var threads: [Thread] = []\n        for row in result {\n            if let thread = try? rowToThread(row) {\n                threads.append(thread)\n            }\n        }\n        return threads\n    }\n\n    /// Get the count of messages in a thread via the junction table\n    /// - Parameter threadId: The thread ID to query\n    /// - Returns: Number of messages in the thread\n    public func getMessageCountInThread(threadId: String) throws -> Int {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"\"\"\n            SELECT COUNT(*) FROM thread_messages\n            WHERE thread_id = '\\(escapeSql(threadId))'\n            \"\"\")\n\n        for row in result {\n            return getIntValue(row, 0) ?? 0\n        }\n        return 0\n    }\n\n    /// Check if a message is in a thread\n    /// - Parameters:\n    ///   - messageId: The message ID to check\n    ///   - threadId: The thread ID to check\n    /// - Returns: True if the message is in the thread\n    public func isMessageInThread(messageId: String, threadId: String) throws -> Bool {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"\"\"\n            SELECT 1 FROM thread_messages\n            WHERE thread_id = '\\(escapeSql(threadId))' AND message_id = '\\(escapeSql(messageId))'\n            LIMIT 1\n            \"\"\")\n\n        for _ in result {\n            return true\n        }\n        return false\n    }\n\n    // MARK: - Helpers\n\n    private func escapeSql(_ string: String) -> String {\n        string.replacingOccurrences(of: \"'\", with: \"''\")\n    }\n\n    /// Escape a query string for safe use in FTS5 MATCH clauses.\n    /// FTS5 has special syntax characters (\", *, OR, AND, NOT, NEAR, etc.) that can cause\n    /// syntax errors if not properly escaped. This function wraps the query in double quotes\n    /// to treat it as a literal phrase, escaping any embedded double quotes.\n    /// - Parameter query: The user's search query\n    /// - Returns: A safely escaped FTS5 query string\n    private func escapeFts5Query(_ query: String) -> String {\n        // Empty or whitespace-only queries should return empty (will match nothing)\n        let trimmed = query.trimmingCharacters(in: .whitespacesAndNewlines)\n        guard !trimmed.isEmpty else {\n            return \"\\\"\\\"\"\n        }\n\n        // In FTS5, wrapping a term in double quotes makes it a literal phrase.\n        // Any double quotes within the phrase must be escaped by doubling them.\n        // Example: search for hello\"world becomes \"hello\"\"world\"\n        let escaped = trimmed.replacingOccurrences(of: \"\\\"\", with: \"\\\"\\\"\")\n        return \"\\\"\\(escaped)\\\"\"\n    }\n\n    /// Serialize a references array to JSON string for database storage\n    private func serializeReferences(_ references: [String]) -> String? {\n        guard !references.isEmpty else { return nil }\n        guard let data = try? JSONEncoder().encode(references),\n              let json = String(data: data, encoding: .utf8) else {\n            return nil\n        }\n        return json\n    }\n\n    /// Deserialize a JSON string to references array\n    private func deserializeReferences(_ json: String?) -> [String] {\n        guard let json = json,\n              let data = json.data(using: .utf8),\n              let references = try? JSONDecoder().decode([String].self, from: data) else {\n            return []\n        }\n        return references\n    }\n}\n\n/// Parse a date string in YYYY-MM-DD format\nprivate func parseDate(_ string: String) -> Date? {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"yyyy-MM-dd\"\n    formatter.timeZone = TimeZone.current\n    return formatter.date(from: string)\n}\n\nextension MailDatabase {\n\n    private func getValue(_ row: Row, _ index: Int32) -> Value? {\n        try? row.get(index)\n    }\n\n    private func getStringValue(_ row: Row, _ index: Int32) -> String? {\n        guard let value = getValue(row, index) else { return nil }\n        if case .text(let str) = value {\n            return str\n        }\n        return nil\n    }\n\n    private func getIntValue(_ row: Row, _ index: Int32) -> Int? {\n        guard let value = getValue(row, index) else { return nil }\n        if case .integer(let num) = value {\n            return Int(num)\n        }\n        return nil\n    }\n\n    private func rowToMessage(_ row: Row) throws -> MailMessage {\n        // Parse mailbox_status (column 21) - default to .inbox if null or unknown\n        let mailboxStatusStr = getStringValue(row, 21)\n        let mailboxStatus = mailboxStatusStr.flatMap { MailboxStatus(rawValue: $0) } ?? .inbox\n\n        // Parse pending_sync_action (column 22) - nullable\n        let pendingSyncActionStr = getStringValue(row, 22)\n        let pendingSyncAction = pendingSyncActionStr.flatMap { SyncAction(rawValue: $0) }\n\n        // Parse threading headers (columns 24, 25) - added in migration V3\n        let inReplyTo = getStringValue(row, 24)\n        let referencesJson = getStringValue(row, 25)\n        let references = deserializeReferences(referencesJson)\n\n        // Parse thread_id (column 26) - added in migration V4\n        let threadId = getStringValue(row, 26)\n\n        // Parse thread_position (column 27) and thread_total (column 28) - added in migration V6\n        let threadPosition = getIntValue(row, 27)\n        let threadTotal = getIntValue(row, 28)\n\n        return MailMessage(\n            id: getStringValue(row, 0) ?? \"\",\n            appleRowId: getIntValue(row, 1),\n            messageId: getStringValue(row, 2),\n            mailboxId: getIntValue(row, 3),\n            mailboxName: getStringValue(row, 4),\n            accountId: getStringValue(row, 5),\n            subject: getStringValue(row, 6) ?? \"\",\n            senderName: getStringValue(row, 7),\n            senderEmail: getStringValue(row, 8),\n            dateSent: getIntValue(row, 9).map { Date(timeIntervalSince1970: Double($0)) },\n            dateReceived: getIntValue(row, 10).map { Date(timeIntervalSince1970: Double($0)) },\n            isRead: (getIntValue(row, 11) ?? 0) == 1,\n            isFlagged: (getIntValue(row, 12) ?? 0) == 1,\n            isDeleted: (getIntValue(row, 13) ?? 0) == 1,\n            hasAttachments: (getIntValue(row, 14) ?? 0) == 1,\n            emlxPath: getStringValue(row, 15),\n            bodyText: getStringValue(row, 16),\n            bodyHtml: getStringValue(row, 17),\n            exportPath: getStringValue(row, 18),\n            mailboxStatus: mailboxStatus,\n            pendingSyncAction: pendingSyncAction,\n            lastKnownMailboxId: getIntValue(row, 23),\n            inReplyTo: inReplyTo,\n            references: references,\n            threadId: threadId,\n            threadPosition: threadPosition,\n            threadTotal: threadTotal\n        )\n    }\n\n    private func rowToMailbox(_ row: Row) throws -> Mailbox {\n        Mailbox(\n            id: getIntValue(row, 0) ?? 0,\n            accountId: getStringValue(row, 1) ?? \"\",\n            name: getStringValue(row, 2) ?? \"\",\n            fullPath: getStringValue(row, 3) ?? \"\",\n            parentId: getIntValue(row, 4),\n            messageCount: getIntValue(row, 5) ?? 0,\n            unreadCount: getIntValue(row, 6) ?? 0\n        )\n    }\n\n    private func rowToThread(_ row: Row) throws -> Thread {\n        Thread(\n            id: getStringValue(row, 0) ?? \"\",\n            subject: getStringValue(row, 1),\n            participantCount: getIntValue(row, 2) ?? 0,\n            messageCount: getIntValue(row, 3) ?? 0,\n            firstDate: getIntValue(row, 4).map { Date(timeIntervalSince1970: Double($0)) },\n            lastDate: getIntValue(row, 5).map { Date(timeIntervalSince1970: Double($0)) },\n            createdAt: getIntValue(row, 6).map { Date(timeIntervalSince1970: Double($0)) },\n            updatedAt: getIntValue(row, 7).map { Date(timeIntervalSince1970: Double($0)) }\n        )\n    }\n\n    // MARK: - Index Verification (for testing)\n\n    /// Get list of indexes on a table\n    /// - Parameter tableName: The table to query indexes for\n    /// - Returns: Array of index names\n    public func getIndexes(on tableName: String) throws -> [String] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"PRAGMA index_list('\\(escapeSql(tableName))')\")\n        var indexes: [String] = []\n        for row in result {\n            if let name = getStringValue(row, 1) {\n                indexes.append(name)\n            }\n        }\n        return indexes\n    }\n\n    /// Run EXPLAIN QUERY PLAN and return the plan details\n    /// - Parameter query: The SQL query to explain\n    /// - Returns: Array of plan detail strings\n    public func explainQueryPlan(_ query: String) throws -> [String] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"EXPLAIN QUERY PLAN \\(query)\")\n        var planDetails: [String] = []\n        for row in result {\n            if let detail = getStringValue(row, 3) {\n                planDetails.append(detail)\n            }\n        }\n        return planDetails\n    }\n}\n\n// MARK: - Data Models\n\n/// Tracks the mailbox status of a message for bidirectional sync\npublic enum MailboxStatus: String, Sendable {\n    case inbox = \"inbox\"\n    case archived = \"archived\"\n    case deleted = \"deleted\"\n}\n\n/// Pending sync action to be pushed to Apple Mail\npublic enum SyncAction: String, Sendable {\n    case archive = \"archive\"\n    case delete = \"delete\"\n}\n\n/// Represents a mirrored email message\npublic struct MailMessage: Sendable {\n    public let id: String\n    public let appleRowId: Int?\n    public let messageId: String?\n    public let mailboxId: Int?\n    public let mailboxName: String?\n    public let accountId: String?\n    public let subject: String\n    public let senderName: String?\n    public let senderEmail: String?\n    public let dateSent: Date?\n    public let dateReceived: Date?\n    public let isRead: Bool\n    public let isFlagged: Bool\n    public let isDeleted: Bool\n    public let hasAttachments: Bool\n    public let emlxPath: String?\n    public let bodyText: String?\n    public let bodyHtml: String?\n    public let exportPath: String?\n    // Mailbox status tracking for bidirectional sync (added in migration V2)\n    public let mailboxStatus: MailboxStatus\n    public let pendingSyncAction: SyncAction?\n    public let lastKnownMailboxId: Int?\n    // Threading headers (added in migration V3)\n    public let inReplyTo: String?\n    public let references: [String]\n    // Thread ID reference (added in migration V4)\n    public let threadId: String?\n    // Thread position metadata (added in migration V6)\n    public let threadPosition: Int?\n    public let threadTotal: Int?\n\n    public init(\n        id: String,\n        appleRowId: Int? = nil,\n        messageId: String? = nil,\n        mailboxId: Int? = nil,\n        mailboxName: String? = nil,\n        accountId: String? = nil,\n        subject: String,\n        senderName: String? = nil,\n        senderEmail: String? = nil,\n        dateSent: Date? = nil,\n        dateReceived: Date? = nil,\n        isRead: Bool = false,\n        isFlagged: Bool = false,\n        isDeleted: Bool = false,\n        hasAttachments: Bool = false,\n        emlxPath: String? = nil,\n        bodyText: String? = nil,\n        bodyHtml: String? = nil,\n        exportPath: String? = nil,\n        mailboxStatus: MailboxStatus = .inbox,\n        pendingSyncAction: SyncAction? = nil,\n        lastKnownMailboxId: Int? = nil,\n        inReplyTo: String? = nil,\n        references: [String] = [],\n        threadId: String? = nil,\n        threadPosition: Int? = nil,\n        threadTotal: Int? = nil\n    ) {\n        self.id = id\n        self.appleRowId = appleRowId\n        self.messageId = messageId\n        self.mailboxId = mailboxId\n        self.mailboxName = mailboxName\n        self.accountId = accountId\n        self.subject = subject\n        self.senderName = senderName\n        self.senderEmail = senderEmail\n        self.dateSent = dateSent\n        self.dateReceived = dateReceived\n        self.isRead = isRead\n        self.isFlagged = isFlagged\n        self.isDeleted = isDeleted\n        self.hasAttachments = hasAttachments\n        self.emlxPath = emlxPath\n        self.bodyText = bodyText\n        self.bodyHtml = bodyHtml\n        self.exportPath = exportPath\n        self.mailboxStatus = mailboxStatus\n        self.pendingSyncAction = pendingSyncAction\n        self.lastKnownMailboxId = lastKnownMailboxId\n        self.inReplyTo = inReplyTo\n        self.references = references\n        self.threadId = threadId\n        self.threadPosition = threadPosition\n        self.threadTotal = threadTotal\n    }\n}\n\n/// Represents a mailbox/folder\npublic struct Mailbox: Sendable {\n    public let id: Int\n    public let accountId: String\n    public let name: String\n    public let fullPath: String\n    public let parentId: Int?\n    public let messageCount: Int\n    public let unreadCount: Int\n\n    public init(\n        id: Int,\n        accountId: String,\n        name: String,\n        fullPath: String,\n        parentId: Int? = nil,\n        messageCount: Int = 0,\n        unreadCount: Int = 0\n    ) {\n        self.id = id\n        self.accountId = accountId\n        self.name = name\n        self.fullPath = fullPath\n        self.parentId = parentId\n        self.messageCount = messageCount\n        self.unreadCount = unreadCount\n    }\n}\n\n/// Represents an email attachment\npublic struct MailAttachment: Sendable {\n    public let id: Int\n    public let messageId: String\n    public let filename: String\n    public let mimeType: String?\n    public let size: Int?\n    public let contentId: String?\n    public let isInline: Bool\n\n    public init(\n        id: Int = 0,\n        messageId: String,\n        filename: String,\n        mimeType: String? = nil,\n        size: Int? = nil,\n        contentId: String? = nil,\n        isInline: Bool = false\n    ) {\n        self.id = id\n        self.messageId = messageId\n        self.filename = filename\n        self.mimeType = mimeType\n        self.size = size\n        self.contentId = contentId\n        self.isInline = isInline\n    }\n}\n\n/// Represents a conversation thread grouping related messages\npublic struct Thread: Sendable {\n    public let id: String\n    public let subject: String?\n    public let participantCount: Int\n    public let messageCount: Int\n    public let firstDate: Date?\n    public let lastDate: Date?\n    public let createdAt: Date?\n    public let updatedAt: Date?\n\n    public init(\n        id: String,\n        subject: String? = nil,\n        participantCount: Int = 0,\n        messageCount: Int = 0,\n        firstDate: Date? = nil,\n        lastDate: Date? = nil,\n        createdAt: Date? = nil,\n        updatedAt: Date? = nil\n    ) {\n        self.id = id\n        self.subject = subject\n        self.participantCount = participantCount\n        self.messageCount = messageCount\n        self.firstDate = firstDate\n        self.lastDate = lastDate\n        self.createdAt = createdAt\n        self.updatedAt = updatedAt\n    }\n}\n\n/// Protocol for thread-like types to avoid ambiguity with Foundation.Thread in CLI\npublic protocol ThreadLike {\n    var id: String { get }\n    var subject: String? { get }\n    var participantCount: Int { get }\n    var messageCount: Int { get }\n    var firstDate: Date? { get }\n    var lastDate: Date? { get }\n}\n\nextension Thread: ThreadLike {}\n","structuredPatch":[{"oldStart":678,"oldLines":6,"newStart":678,"newLines":8,"lines":["         public var hasAttachments: Bool?","         public var freeText: String?","         public var mailboxStatus: MailboxStatus?","+        /// Unknown filter names found in the query (e.g., \"badfilter\" from \"badfilter:value\")","+        public var unknownFilters: [String] = []"," ","         public init() {}"," "]},{"oldStart":692,"oldLines":6,"newStart":694,"newLines":14,"lines":["         public var hasFreeText: Bool {","             freeText != nil && !freeText!.isEmpty","         }","+","+        /// Check if unknown filters were found","+        public var hasUnknownFilters: Bool {","+            !unknownFilters.isEmpty","+        }","+","+        /// List of valid filter names for error messages","+        public static let validFilterNames = [\"from\", \"to\", \"subject\", \"mailbox\", \"is\", \"has\", \"after\", \"before\", \"date\"]","     }"," ","     /// Parse a structured query string into filters"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01T75HKPt84vQPq3ZwyC1ukM","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to modify the `parseQuery` function to detect unknown filter names. Let me look at the current implementation more closely:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1543,"cache_read_input_tokens":49238,"cache_creation":{"ephemeral_5m_input_tokens":1543,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"7ce76967-031d-4078-977e-d943dc3413ab"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01T75HKPt84vQPq3ZwyC1ukM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019P3KUGYV52L3UcULU87XjY","name":"Read","input":{"file_path":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift","offset":707,"limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1543,"cache_read_input_tokens":49238,"cache_creation":{"ephemeral_5m_input_tokens":1543,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"15989417-8eaa-4df8-b960-0f1afdf9b062"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019P3KUGYV52L3UcULU87XjY","type":"tool_result","content":"   707â†’    /// Parse a structured query string into filters\n   708â†’    /// Supports: from:, to:, subject:, mailbox:, is:read, is:unread, is:flagged, is:unflagged,\n   709â†’    /// after:, before:, date:, has:attachments\n   710â†’    public func parseQuery(_ query: String) -> SearchFilter {\n   711â†’        var filter = SearchFilter()\n   712â†’\n   713â†’        // Regex patterns for structured filters\n   714â†’        let filterPatterns: [(pattern: String, handler: (String, inout SearchFilter) -> Void)] = [\n   715â†’            // from: filter (email or name)\n   716â†’            (\"from:\\\"([^\\\"]+)\\\"\", { value, f in f.from = value }),\n   717â†’            (\"from:(\\\\S+)\", { value, f in f.from = value }),\n   718â†’\n   719â†’            // to: filter\n   720â†’            (\"to:\\\"([^\\\"]+)\\\"\", { value, f in f.to = value }),\n   721â†’            (\"to:(\\\\S+)\", { value, f in f.to = value }),\n   722â†’\n   723â†’            // subject: filter\n   724â†’            (\"subject:\\\"([^\\\"]+)\\\"\", { value, f in f.subject = value }),\n   725â†’            (\"subject:(\\\\S+)\", { value, f in f.subject = value }),\n   726â†’\n   727â†’            // mailbox: filter\n   728â†’            (\"mailbox:\\\"([^\\\"]+)\\\"\", { value, f in f.mailbox = value }),\n   729â†’            (\"mailbox:(\\\\S+)\", { value, f in f.mailbox = value }),\n   730â†’\n   731â†’            // is: status filters\n   732â†’            (\"is:read\", { _, f in f.isRead = true }),\n   733â†’            (\"is:unread\", { _, f in f.isRead = false }),\n   734â†’            (\"is:flagged\", { _, f in f.isFlagged = true }),\n   735â†’            (\"is:unflagged\", { _, f in f.isFlagged = false }),\n   736â†’\n   737â†’            // has: filters\n   738â†’            (\"has:attachments?\", { _, f in f.hasAttachments = true }),\n   739â†’\n   740â†’            // Date filters (YYYY-MM-DD format)\n   741â†’            (\"after:(\\\\d{4}-\\\\d{2}-\\\\d{2})\", { value, f in f.dateAfter = parseDate(value) }),\n   742â†’            (\"before:(\\\\d{4}-\\\\d{2}-\\\\d{2})\", { value, f in f.dateBefore = parseDate(value) }),\n   743â†’            (\"date:(\\\\d{4}-\\\\d{2}-\\\\d{2})\", { value, f in\n   744â†’                // date: sets both after and before to cover the whole day\n   745â†’                if let date = parseDate(value) {\n   746â†’                    f.dateAfter = date\n   747â†’                    // Set before to end of day\n   748â†’                    if let endOfDay = Calendar.current.date(byAdding: .day, value: 1, to: date) {\n   749â†’                        f.dateBefore = endOfDay\n   750â†’                    }\n   751â†’                }\n   752â†’            })\n   753â†’        ]\n   754â†’\n   755â†’        var remainingQuery = query\n   756â†’\n   757â†’        // Process each filter pattern\n   758â†’        for (pattern, handler) in filterPatterns {\n   759â†’            if let regex = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive) {\n   760â†’                let range = NSRange(remainingQuery.startIndex..., in: remainingQuery)\n   761â†’                let matches = regex.matches(in: remainingQuery, options: [], range: range)\n   762â†’\n   763â†’                // Process matches in reverse to preserve indices\n   764â†’                for match in matches.reversed() {\n   765â†’                    // Extract captured group if present, otherwise use the whole match\n   766â†’                    let valueRange = match.numberOfRanges > 1 ? match.range(at: 1) : match.range\n   767â†’                    if let swiftRange = Range(valueRange, in: remainingQuery) {\n   768â†’                        let value = String(remainingQuery[swiftRange])\n   769â†’                        handler(value, &filter)\n   770â†’                    } else {\n   771â†’                        handler(\"\", &filter)\n   772â†’                    }\n   773â†’\n   774â†’                    // Remove matched text from query\n   775â†’                    if let swiftRange = Range(match.range, in: remainingQuery) {\n   776â†’                        remainingQuery.removeSubrange(swiftRange)\n   777â†’                    }\n   778â†’                }\n   779â†’            }\n   780â†’        }\n   781â†’\n   782â†’        // Clean up remaining query (free text for FTS)\n   783â†’        let cleanedFreeText = remainingQuery\n   784â†’            .trimmingCharacters(in: .whitespaces)\n   785â†’            .components(separatedBy: .whitespaces)\n   786â†’            .filter { !$0.isEmpty }\n   787â†’            .joined(separator: \" \")\n   788â†’\n   789â†’        if !cleanedFreeText.isEmpty {\n   790â†’            filter.freeText = cleanedFreeText\n   791â†’        }\n   792â†’\n   793â†’        return filter\n   794â†’    }\n   795â†’\n   796â†’    /// Search messages using structured filters and optional FTS\n   797â†’    public func searchMessagesWithFilters(_ filter: SearchFilter, limit: Int = 50, offset: Int = 0) throws -> [MailMessage] {\n   798â†’        guard let conn = connection else {\n   799â†’            throw MailDatabaseError.notInitialized\n   800â†’        }\n   801â†’\n   802â†’        var whereClauses: [String] = []\n   803â†’\n   804â†’        // Build WHERE clauses from filters\n   805â†’\n   806â†’        // from: filter (matches sender_name or sender_email)\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"7b78c960-28cd-4dc3-9087-c2b2b1c4fe81","tool_use_result":{"type":"text","file":{"filePath":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift","content":"    /// Parse a structured query string into filters\n    /// Supports: from:, to:, subject:, mailbox:, is:read, is:unread, is:flagged, is:unflagged,\n    /// after:, before:, date:, has:attachments\n    public func parseQuery(_ query: String) -> SearchFilter {\n        var filter = SearchFilter()\n\n        // Regex patterns for structured filters\n        let filterPatterns: [(pattern: String, handler: (String, inout SearchFilter) -> Void)] = [\n            // from: filter (email or name)\n            (\"from:\\\"([^\\\"]+)\\\"\", { value, f in f.from = value }),\n            (\"from:(\\\\S+)\", { value, f in f.from = value }),\n\n            // to: filter\n            (\"to:\\\"([^\\\"]+)\\\"\", { value, f in f.to = value }),\n            (\"to:(\\\\S+)\", { value, f in f.to = value }),\n\n            // subject: filter\n            (\"subject:\\\"([^\\\"]+)\\\"\", { value, f in f.subject = value }),\n            (\"subject:(\\\\S+)\", { value, f in f.subject = value }),\n\n            // mailbox: filter\n            (\"mailbox:\\\"([^\\\"]+)\\\"\", { value, f in f.mailbox = value }),\n            (\"mailbox:(\\\\S+)\", { value, f in f.mailbox = value }),\n\n            // is: status filters\n            (\"is:read\", { _, f in f.isRead = true }),\n            (\"is:unread\", { _, f in f.isRead = false }),\n            (\"is:flagged\", { _, f in f.isFlagged = true }),\n            (\"is:unflagged\", { _, f in f.isFlagged = false }),\n\n            // has: filters\n            (\"has:attachments?\", { _, f in f.hasAttachments = true }),\n\n            // Date filters (YYYY-MM-DD format)\n            (\"after:(\\\\d{4}-\\\\d{2}-\\\\d{2})\", { value, f in f.dateAfter = parseDate(value) }),\n            (\"before:(\\\\d{4}-\\\\d{2}-\\\\d{2})\", { value, f in f.dateBefore = parseDate(value) }),\n            (\"date:(\\\\d{4}-\\\\d{2}-\\\\d{2})\", { value, f in\n                // date: sets both after and before to cover the whole day\n                if let date = parseDate(value) {\n                    f.dateAfter = date\n                    // Set before to end of day\n                    if let endOfDay = Calendar.current.date(byAdding: .day, value: 1, to: date) {\n                        f.dateBefore = endOfDay\n                    }\n                }\n            })\n        ]\n\n        var remainingQuery = query\n\n        // Process each filter pattern\n        for (pattern, handler) in filterPatterns {\n            if let regex = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive) {\n                let range = NSRange(remainingQuery.startIndex..., in: remainingQuery)\n                let matches = regex.matches(in: remainingQuery, options: [], range: range)\n\n                // Process matches in reverse to preserve indices\n                for match in matches.reversed() {\n                    // Extract captured group if present, otherwise use the whole match\n                    let valueRange = match.numberOfRanges > 1 ? match.range(at: 1) : match.range\n                    if let swiftRange = Range(valueRange, in: remainingQuery) {\n                        let value = String(remainingQuery[swiftRange])\n                        handler(value, &filter)\n                    } else {\n                        handler(\"\", &filter)\n                    }\n\n                    // Remove matched text from query\n                    if let swiftRange = Range(match.range, in: remainingQuery) {\n                        remainingQuery.removeSubrange(swiftRange)\n                    }\n                }\n            }\n        }\n\n        // Clean up remaining query (free text for FTS)\n        let cleanedFreeText = remainingQuery\n            .trimmingCharacters(in: .whitespaces)\n            .components(separatedBy: .whitespaces)\n            .filter { !$0.isEmpty }\n            .joined(separator: \" \")\n\n        if !cleanedFreeText.isEmpty {\n            filter.freeText = cleanedFreeText\n        }\n\n        return filter\n    }\n\n    /// Search messages using structured filters and optional FTS\n    public func searchMessagesWithFilters(_ filter: SearchFilter, limit: Int = 50, offset: Int = 0) throws -> [MailMessage] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        var whereClauses: [String] = []\n\n        // Build WHERE clauses from filters\n\n        // from: filter (matches sender_name or sender_email)","numLines":100,"startLine":707,"totalLines":2644}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01LYENKMNyZ43fNitKa8jnQK","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to add code after the known filter parsing to detect unknown filter patterns like `word:value` in the remaining query. I'll modify the section that cleans up the remaining query:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1816,"cache_read_input_tokens":50781,"cache_creation":{"ephemeral_5m_input_tokens":1816,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"5e28ac17-851f-4f33-a435-dd3c65ac871a"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01LYENKMNyZ43fNitKa8jnQK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FKnNXbPxXuUV6p3pMpuHHH","name":"Edit","input":{"replace_all":false,"file_path":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift","old_string":"        // Clean up remaining query (free text for FTS)\n        let cleanedFreeText = remainingQuery\n            .trimmingCharacters(in: .whitespaces)\n            .components(separatedBy: .whitespaces)\n            .filter { !$0.isEmpty }\n            .joined(separator: \" \")\n\n        if !cleanedFreeText.isEmpty {\n            filter.freeText = cleanedFreeText\n        }\n\n        return filter\n    }","new_string":"        // Clean up remaining query and detect unknown filters\n        let tokens = remainingQuery\n            .trimmingCharacters(in: .whitespaces)\n            .components(separatedBy: .whitespaces)\n            .filter { !$0.isEmpty }\n\n        // Check for unknown filter patterns (word:value format)\n        // Valid filter prefixes: from, to, subject, mailbox, is, has, after, before, date\n        let unknownFilterRegex = try? NSRegularExpression(pattern: \"^([a-zA-Z]+):\", options: [])\n        var freeTextTokens: [String] = []\n\n        for token in tokens {\n            let range = NSRange(token.startIndex..., in: token)\n            if let match = unknownFilterRegex?.firstMatch(in: token, options: [], range: range),\n               let filterNameRange = Range(match.range(at: 1), in: token) {\n                let filterName = String(token[filterNameRange]).lowercased()\n                // Check if this is an unknown filter name\n                if !SearchFilter.validFilterNames.contains(filterName) {\n                    filter.unknownFilters.append(filterName)\n                }\n            }\n            freeTextTokens.append(token)\n        }\n\n        let cleanedFreeText = freeTextTokens.joined(separator: \" \")\n        if !cleanedFreeText.isEmpty {\n            filter.freeText = cleanedFreeText\n        }\n\n        return filter\n    }"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1816,"cache_read_input_tokens":50781,"cache_creation":{"ephemeral_5m_input_tokens":1816,"ephemeral_1h_input_tokens":0},"output_tokens":661,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"ac4ea9b9-9c9c-4e38-af7e-90325d575077"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FKnNXbPxXuUV6p3pMpuHHH","type":"tool_result","content":"The file /Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   778â†’                }\n   779â†’            }\n   780â†’        }\n   781â†’\n   782â†’        // Clean up remaining query and detect unknown filters\n   783â†’        let tokens = remainingQuery\n   784â†’            .trimmingCharacters(in: .whitespaces)\n   785â†’            .components(separatedBy: .whitespaces)\n   786â†’            .filter { !$0.isEmpty }\n   787â†’\n   788â†’        // Check for unknown filter patterns (word:value format)\n   789â†’        // Valid filter prefixes: from, to, subject, mailbox, is, has, after, before, date\n   790â†’        let unknownFilterRegex = try? NSRegularExpression(pattern: \"^([a-zA-Z]+):\", options: [])\n   791â†’        var freeTextTokens: [String] = []\n   792â†’\n   793â†’        for token in tokens {\n   794â†’            let range = NSRange(token.startIndex..., in: token)\n   795â†’            if let match = unknownFilterRegex?.firstMatch(in: token, options: [], range: range),\n   796â†’               let filterNameRange = Range(match.range(at: 1), in: token) {\n   797â†’                let filterName = String(token[filterNameRange]).lowercased()\n   798â†’                // Check if this is an unknown filter name\n   799â†’                if !SearchFilter.validFilterNames.contains(filterName) {\n   800â†’                    filter.unknownFilters.append(filterName)\n   801â†’                }\n   802â†’            }\n   803â†’            freeTextTokens.append(token)\n   804â†’        }\n   805â†’\n   806â†’        let cleanedFreeText = freeTextTokens.joined(separator: \" \")\n   807â†’        if !cleanedFreeText.isEmpty {\n   808â†’            filter.freeText = cleanedFreeText\n   809â†’        }\n   810â†’\n   811â†’        return filter\n   812â†’    }\n   813â†’\n   814â†’    /// Search messages using structured filters and optional FTS\n   815â†’    public func searchMessagesWithFilters(_ filter: SearchFilter, limit: Int = 50, offset: Int = 0) throws -> [MailMessage] {\n   816â†’        guard let conn = connection else {"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"0dd074e6-9821-4514-a6bf-9f476091dff0","tool_use_result":{"filePath":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift","oldString":"        // Clean up remaining query (free text for FTS)\n        let cleanedFreeText = remainingQuery\n            .trimmingCharacters(in: .whitespaces)\n            .components(separatedBy: .whitespaces)\n            .filter { !$0.isEmpty }\n            .joined(separator: \" \")\n\n        if !cleanedFreeText.isEmpty {\n            filter.freeText = cleanedFreeText\n        }\n\n        return filter\n    }","newString":"        // Clean up remaining query and detect unknown filters\n        let tokens = remainingQuery\n            .trimmingCharacters(in: .whitespaces)\n            .components(separatedBy: .whitespaces)\n            .filter { !$0.isEmpty }\n\n        // Check for unknown filter patterns (word:value format)\n        // Valid filter prefixes: from, to, subject, mailbox, is, has, after, before, date\n        let unknownFilterRegex = try? NSRegularExpression(pattern: \"^([a-zA-Z]+):\", options: [])\n        var freeTextTokens: [String] = []\n\n        for token in tokens {\n            let range = NSRange(token.startIndex..., in: token)\n            if let match = unknownFilterRegex?.firstMatch(in: token, options: [], range: range),\n               let filterNameRange = Range(match.range(at: 1), in: token) {\n                let filterName = String(token[filterNameRange]).lowercased()\n                // Check if this is an unknown filter name\n                if !SearchFilter.validFilterNames.contains(filterName) {\n                    filter.unknownFilters.append(filterName)\n                }\n            }\n            freeTextTokens.append(token)\n        }\n\n        let cleanedFreeText = freeTextTokens.joined(separator: \" \")\n        if !cleanedFreeText.isEmpty {\n            filter.freeText = cleanedFreeText\n        }\n\n        return filter\n    }","originalFile":"// MailDatabase - libSQL mirror database for Apple Mail data\n\nimport Foundation\nimport Libsql\n\n/// Errors that can occur during mail database operations\npublic enum MailDatabaseError: Error, LocalizedError {\n    case connectionFailed(underlying: Error)\n    case migrationFailed(underlying: Error)\n    case queryFailed(underlying: Error)\n    case notInitialized\n\n    public var errorDescription: String? {\n        switch self {\n        case .connectionFailed(let error):\n            return \"Failed to connect to mail database: \\(error.localizedDescription)\"\n        case .migrationFailed(let error):\n            return \"Failed to run database migration: \\(error.localizedDescription)\"\n        case .queryFailed(let error):\n            return \"Database query failed: \\(error.localizedDescription)\"\n        case .notInitialized:\n            return \"Mail database not initialized\"\n        }\n    }\n}\n\n/// Sort options for thread listing\npublic enum ThreadSortOrder: String, CaseIterable, Sendable {\n    case date = \"date\"\n    case subject = \"subject\"\n    case messageCount = \"message_count\"\n\n    /// SQL ORDER BY clause for this sort option\n    var sqlOrderBy: String {\n        switch self {\n        case .date:\n            return \"last_date DESC\"\n        case .subject:\n            return \"subject ASC NULLS LAST\"\n        case .messageCount:\n            return \"message_count DESC\"\n        }\n    }\n}\n\n/// Manages the libSQL mirror database for Apple Mail data\npublic final class MailDatabase: @unchecked Sendable {\n    private var database: Database?\n    private var connection: Connection?\n    private let databasePath: String\n\n    public init(databasePath: String) {\n        self.databasePath = databasePath\n    }\n\n    /// Initialize the database connection and run migrations\n    public func initialize() throws {\n        do {\n            database = try Database(databasePath)\n            connection = try database?.connect()\n\n            // Enable WAL mode for concurrent access (allows readers while writing)\n            // This prevents \"database is locked\" errors when daemon and manual sync run concurrently\n            if let conn = connection {\n                _ = try conn.query(\"PRAGMA journal_mode=WAL\")\n                // Set busy timeout to 5 seconds to wait for locks instead of failing immediately\n                _ = try conn.query(\"PRAGMA busy_timeout=5000\")\n            }\n\n            try runMigrations()\n        } catch {\n            throw MailDatabaseError.connectionFailed(underlying: error)\n        }\n    }\n\n    /// Close the database connection\n    public func close() {\n        connection = nil\n        database = nil\n    }\n\n    // MARK: - Schema Definition\n\n    /// Run all pending migrations to bring schema up to date\n    private func runMigrations() throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        // Create schema version tracking table\n        _ = try conn.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS schema_version (\n                version INTEGER PRIMARY KEY,\n                applied_at TEXT NOT NULL DEFAULT (datetime('now'))\n            )\n            \"\"\")\n\n        // Get current version\n        let result = try conn.query(\"SELECT MAX(version) as v FROM schema_version\")\n        var currentVersion = 0\n        for row in result {\n            if let v = try? row.getInt(0) {\n                currentVersion = v\n            }\n        }\n\n        // Apply migrations\n        if currentVersion < 1 {\n            try applyMigrationV1(conn)\n        }\n        if currentVersion < 2 {\n            try applyMigrationV2(conn)\n        }\n        if currentVersion < 3 {\n            try applyMigrationV3(conn)\n        }\n        if currentVersion < 4 {\n            try applyMigrationV4(conn)\n        }\n        if currentVersion < 5 {\n            try applyMigrationV5(conn)\n        }\n        if currentVersion < 6 {\n            try applyMigrationV6(conn)\n        }\n        if currentVersion < 7 {\n            try applyMigrationV7(conn)\n        }\n    }\n\n    /// Migration v1: Initial schema with all mail tables\n    private func applyMigrationV1(_ conn: Connection) throws {\n        do {\n            // Messages table - core email metadata\n            _ = try conn.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS messages (\n                    id TEXT PRIMARY KEY,\n                    apple_rowid INTEGER,\n                    message_id TEXT,\n                    mailbox_id INTEGER,\n                    mailbox_name TEXT,\n                    account_id TEXT,\n                    subject TEXT,\n                    sender_name TEXT,\n                    sender_email TEXT,\n                    date_sent INTEGER,\n                    date_received INTEGER,\n                    is_read INTEGER DEFAULT 0,\n                    is_flagged INTEGER DEFAULT 0,\n                    is_deleted INTEGER DEFAULT 0,\n                    has_attachments INTEGER DEFAULT 0,\n                    emlx_path TEXT,\n                    body_text TEXT,\n                    body_html TEXT,\n                    export_path TEXT,\n                    synced_at INTEGER NOT NULL,\n                    updated_at INTEGER NOT NULL\n                )\n                \"\"\")\n\n            // Recipients table - to/cc/bcc addresses\n            _ = try conn.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS recipients (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    message_id TEXT NOT NULL,\n                    type TEXT NOT NULL,\n                    name TEXT,\n                    email TEXT NOT NULL,\n                    FOREIGN KEY (message_id) REFERENCES messages(id) ON DELETE CASCADE\n                )\n                \"\"\")\n\n            // Attachments table - attachment metadata\n            _ = try conn.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS attachments (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    message_id TEXT NOT NULL,\n                    filename TEXT NOT NULL,\n                    mime_type TEXT,\n                    size INTEGER,\n                    content_id TEXT,\n                    is_inline INTEGER DEFAULT 0,\n                    FOREIGN KEY (message_id) REFERENCES messages(id) ON DELETE CASCADE\n                )\n                \"\"\")\n\n            // Mailboxes table - folder hierarchy\n            _ = try conn.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS mailboxes (\n                    id INTEGER PRIMARY KEY,\n                    account_id TEXT NOT NULL,\n                    name TEXT NOT NULL,\n                    full_path TEXT NOT NULL,\n                    parent_id INTEGER,\n                    message_count INTEGER DEFAULT 0,\n                    unread_count INTEGER DEFAULT 0,\n                    synced_at INTEGER NOT NULL\n                )\n                \"\"\")\n\n            // Sync status table - track sync progress\n            _ = try conn.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS sync_status (\n                    key TEXT PRIMARY KEY,\n                    value TEXT NOT NULL,\n                    updated_at INTEGER NOT NULL\n                )\n                \"\"\")\n\n            // Create indexes for common lookups\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_messages_apple_rowid ON messages(apple_rowid)\")\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_messages_message_id ON messages(message_id)\")\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_messages_mailbox_id ON messages(mailbox_id)\")\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_messages_account_id ON messages(account_id)\")\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_messages_date_received ON messages(date_received)\")\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_messages_is_read ON messages(is_read)\")\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_messages_is_flagged ON messages(is_flagged)\")\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_recipients_message_id ON recipients(message_id)\")\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_attachments_message_id ON attachments(message_id)\")\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_mailboxes_account_id ON mailboxes(account_id)\")\n\n            // Create FTS5 virtual table for full-text search\n            // Note: Using external content table (content='messages') means FTS reads from messages table\n            _ = try conn.execute(\"\"\"\n                CREATE VIRTUAL TABLE IF NOT EXISTS messages_fts USING fts5(\n                    subject,\n                    sender_name,\n                    sender_email,\n                    body_text,\n                    content='messages',\n                    content_rowid='rowid',\n                    tokenize='porter unicode61'\n                )\n                \"\"\")\n\n            // Create triggers to keep FTS index in sync\n            _ = try conn.execute(\"\"\"\n                CREATE TRIGGER IF NOT EXISTS messages_ai AFTER INSERT ON messages BEGIN\n                    INSERT INTO messages_fts(rowid, subject, sender_name, sender_email, body_text)\n                    VALUES (NEW.rowid, NEW.subject, NEW.sender_name, NEW.sender_email, NEW.body_text);\n                END\n                \"\"\")\n\n            _ = try conn.execute(\"\"\"\n                CREATE TRIGGER IF NOT EXISTS messages_ad AFTER DELETE ON messages BEGIN\n                    INSERT INTO messages_fts(messages_fts, rowid, subject, sender_name, sender_email, body_text)\n                    VALUES ('delete', OLD.rowid, OLD.subject, OLD.sender_name, OLD.sender_email, OLD.body_text);\n                END\n                \"\"\")\n\n            _ = try conn.execute(\"\"\"\n                CREATE TRIGGER IF NOT EXISTS messages_au AFTER UPDATE ON messages BEGIN\n                    INSERT INTO messages_fts(messages_fts, rowid, subject, sender_name, sender_email, body_text)\n                    VALUES ('delete', OLD.rowid, OLD.subject, OLD.sender_name, OLD.sender_email, OLD.body_text);\n                    INSERT INTO messages_fts(rowid, subject, sender_name, sender_email, body_text)\n                    VALUES (NEW.rowid, NEW.subject, NEW.sender_name, NEW.sender_email, NEW.body_text);\n                END\n                \"\"\")\n\n            // Record migration version\n            _ = try conn.execute(\"INSERT INTO schema_version (version) VALUES (1)\")\n\n        } catch {\n            throw MailDatabaseError.migrationFailed(underlying: error)\n        }\n    }\n\n    /// Migration v2: Add mailbox status tracking columns for bidirectional sync\n    private func applyMigrationV2(_ conn: Connection) throws {\n        do {\n            // Add mailbox_status column with default 'inbox' for existing messages\n            _ = try conn.execute(\"ALTER TABLE messages ADD COLUMN mailbox_status TEXT DEFAULT 'inbox'\")\n\n            // Add pending_sync_action column (nullable - only set when action is pending)\n            _ = try conn.execute(\"ALTER TABLE messages ADD COLUMN pending_sync_action TEXT\")\n\n            // Add last_known_mailbox_id column (nullable - tracks original mailbox for move detection)\n            _ = try conn.execute(\"ALTER TABLE messages ADD COLUMN last_known_mailbox_id INTEGER\")\n\n            // Create index for querying messages by mailbox status\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_messages_mailbox_status ON messages(mailbox_status)\")\n\n            // Create index for finding messages with pending sync actions\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_messages_pending_sync_action ON messages(pending_sync_action)\")\n\n            // Record migration version\n            _ = try conn.execute(\"INSERT INTO schema_version (version) VALUES (2)\")\n\n        } catch {\n            throw MailDatabaseError.migrationFailed(underlying: error)\n        }\n    }\n\n    /// Migration v3: Add threading header columns (in_reply_to, references)\n    private func applyMigrationV3(_ conn: Connection) throws {\n        do {\n            // Add in_reply_to column (nullable - stores the In-Reply-To header value)\n            _ = try conn.execute(\"ALTER TABLE messages ADD COLUMN in_reply_to TEXT\")\n\n            // Add references column (nullable - stores JSON array of message IDs from References header)\n            _ = try conn.execute(\"ALTER TABLE messages ADD COLUMN threading_references TEXT\")\n\n            // Create index for looking up messages by in_reply_to (for thread detection)\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_messages_in_reply_to ON messages(in_reply_to)\")\n\n            // Record migration version\n            _ = try conn.execute(\"INSERT INTO schema_version (version) VALUES (3)\")\n\n        } catch {\n            throw MailDatabaseError.migrationFailed(underlying: error)\n        }\n    }\n\n    /// Migration v4: Create threads table for conversation-level metadata\n    private func applyMigrationV4(_ conn: Connection) throws {\n        do {\n            // Create threads table for conversation-level metadata\n            // Thread IDs are 32-character hex strings generated by ThreadIDGenerator\n            _ = try conn.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS threads (\n                    id TEXT PRIMARY KEY,\n                    subject TEXT,\n                    participant_count INTEGER DEFAULT 0,\n                    message_count INTEGER DEFAULT 0,\n                    first_date INTEGER,\n                    last_date INTEGER,\n                    created_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now')),\n                    updated_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now'))\n                )\n                \"\"\")\n\n            // Add thread_id column to messages table (foreign key reference to threads)\n            _ = try conn.execute(\"ALTER TABLE messages ADD COLUMN thread_id TEXT REFERENCES threads(id)\")\n\n            // Create index for efficient thread lookups\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_threads_last_date ON threads(last_date DESC)\")\n\n            // Create index for efficient message lookup by thread_id\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_messages_thread_id ON messages(thread_id)\")\n\n            // Record migration version\n            _ = try conn.execute(\"INSERT INTO schema_version (version) VALUES (4)\")\n\n        } catch {\n            throw MailDatabaseError.migrationFailed(underlying: error)\n        }\n    }\n\n    /// Migration v5: Create thread_messages junction table for many-to-many relationships\n    private func applyMigrationV5(_ conn: Connection) throws {\n        do {\n            // Create thread_messages junction table\n            // This allows many-to-many relationships between threads and messages\n            // A message can belong to multiple threads (e.g., cross-posted, forwarded chains)\n            // A thread can contain multiple messages\n            _ = try conn.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS thread_messages (\n                    thread_id TEXT NOT NULL,\n                    message_id TEXT NOT NULL,\n                    added_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now')),\n                    PRIMARY KEY (thread_id, message_id),\n                    FOREIGN KEY (thread_id) REFERENCES threads(id) ON DELETE CASCADE,\n                    FOREIGN KEY (message_id) REFERENCES messages(id) ON DELETE CASCADE\n                )\n                \"\"\")\n\n            // Create index for efficient lookup by thread_id (get all messages in a thread)\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_thread_messages_thread_id ON thread_messages(thread_id)\")\n\n            // Create index for efficient lookup by message_id (get all threads a message belongs to)\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_thread_messages_message_id ON thread_messages(message_id)\")\n\n            // Record migration version\n            _ = try conn.execute(\"INSERT INTO schema_version (version) VALUES (5)\")\n\n        } catch {\n            throw MailDatabaseError.migrationFailed(underlying: error)\n        }\n    }\n\n    /// Migration v6: Add thread_position and thread_total columns to messages table\n    private func applyMigrationV6(_ conn: Connection) throws {\n        do {\n            // Add thread_position column (nullable - position of message within its thread)\n            _ = try conn.execute(\"ALTER TABLE messages ADD COLUMN thread_position INTEGER\")\n\n            // Add thread_total column (nullable - total messages in the thread)\n            _ = try conn.execute(\"ALTER TABLE messages ADD COLUMN thread_total INTEGER\")\n\n            // Record migration version\n            _ = try conn.execute(\"INSERT INTO schema_version (version) VALUES (6)\")\n\n        } catch {\n            throw MailDatabaseError.migrationFailed(underlying: error)\n        }\n    }\n\n    /// Migration v7: Add indexes for large inbox query optimization (>100k emails)\n    /// This migration optimizes thread listing and filtering for large inboxes\n    private func applyMigrationV7(_ conn: Connection) throws {\n        do {\n            // Index on threads(subject) for sorting by subject\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_threads_subject ON threads(subject)\")\n\n            // Index on threads(message_count) for sorting by message count\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_threads_message_count ON threads(message_count DESC)\")\n\n            // Index on messages(sender_email) for participant filtering\n            // Uses LOWER() to support case-insensitive queries\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_messages_sender_email ON messages(sender_email)\")\n\n            // Index on recipients(email) for participant filtering\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_recipients_email ON recipients(email)\")\n\n            // Composite index for efficient thread position batch updates\n            _ = try conn.execute(\"CREATE INDEX IF NOT EXISTS idx_messages_thread_position ON messages(thread_id, thread_position)\")\n\n            // Record migration version\n            _ = try conn.execute(\"INSERT INTO schema_version (version) VALUES (7)\")\n\n        } catch {\n            throw MailDatabaseError.migrationFailed(underlying: error)\n        }\n    }\n\n    // MARK: - Schema Version API\n\n    /// The current schema version number (latest migration version)\n    public static let currentSchemaVersion = 7\n\n    /// Description of each schema migration\n    public static let migrationDescriptions: [Int: String] = [\n        1: \"Initial schema with messages, recipients, attachments, mailboxes, sync_status tables and FTS5\",\n        2: \"Bidirectional sync columns (mailbox_status, pending_sync_action, last_known_mailbox_id)\",\n        3: \"Threading headers (in_reply_to, threading_references)\",\n        4: \"Threads table and thread_id column on messages\",\n        5: \"Thread-messages junction table for many-to-many relationships\",\n        6: \"Thread position metadata (thread_position, thread_total)\",\n        7: \"Large inbox query optimization indexes\"\n    ]\n\n    /// Get the current schema version from the database\n    /// Returns 0 if database has no schema_version table (empty/new database)\n    public func getSchemaVersion() throws -> Int {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        // Check if schema_version table exists\n        let tableCheck = try conn.query(\"\"\"\n            SELECT name FROM sqlite_master\n            WHERE type='table' AND name='schema_version'\n            \"\"\")\n\n        var tableExists = false\n        for _ in tableCheck {\n            tableExists = true\n            break\n        }\n\n        if !tableExists {\n            return 0\n        }\n\n        // Get current version\n        let result = try conn.query(\"SELECT MAX(version) as v FROM schema_version\")\n        for row in result {\n            if let v = try? row.getInt(0) {\n                return v\n            }\n        }\n        return 0\n    }\n\n    /// Get the migration history with timestamps\n    public func getMigrationHistory() throws -> [(version: Int, appliedAt: String)] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        // Check if schema_version table exists\n        let tableCheck = try conn.query(\"\"\"\n            SELECT name FROM sqlite_master\n            WHERE type='table' AND name='schema_version'\n            \"\"\")\n\n        var tableExists = false\n        for _ in tableCheck {\n            tableExists = true\n            break\n        }\n\n        if !tableExists {\n            return []\n        }\n\n        var history: [(version: Int, appliedAt: String)] = []\n        let result = try conn.query(\"SELECT version, applied_at FROM schema_version ORDER BY version ASC\")\n        for row in result {\n            if let version = try? row.getInt(0),\n               let appliedAt = try? row.getString(1) {\n                history.append((version: version, appliedAt: appliedAt))\n            }\n        }\n        return history\n    }\n\n    /// Check if a specific table exists in the database\n    public func tableExists(_ tableName: String) throws -> Bool {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"\"\"\n            SELECT name FROM sqlite_master\n            WHERE type='table' AND name='\\(escapeSql(tableName))'\n            \"\"\")\n\n        for _ in result {\n            return true\n        }\n        return false\n    }\n\n    /// Get the columns for a specific table\n    public func getTableColumns(_ tableName: String) throws -> [String] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        var columns: [String] = []\n        let result = try conn.query(\"PRAGMA table_info('\\(escapeSql(tableName))')\")\n        for row in result {\n            if let name = try? row.getString(1) {\n                columns.append(name)\n            }\n        }\n        return columns\n    }\n\n    // MARK: - Message Operations\n\n    /// Insert or update a message in the mirror database\n    public func upsertMessage(_ message: MailMessage) throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let now = Int(Date().timeIntervalSince1970)\n\n        // Serialize references array to JSON for storage\n        let referencesJson = serializeReferences(message.references)\n\n        _ = try conn.execute(\"\"\"\n            INSERT INTO messages (\n                id, apple_rowid, message_id, mailbox_id, mailbox_name, account_id,\n                subject, sender_name, sender_email, date_sent, date_received,\n                is_read, is_flagged, is_deleted, has_attachments, emlx_path,\n                body_text, body_html, synced_at, updated_at,\n                mailbox_status, pending_sync_action, last_known_mailbox_id,\n                in_reply_to, threading_references, thread_id,\n                thread_position, thread_total\n            ) VALUES (\n                '\\(message.id)', \\(message.appleRowId ?? 0), \\(message.messageId.map { \"'\\($0)'\" } ?? \"NULL\"),\n                \\(message.mailboxId ?? 0), \\(message.mailboxName.map { \"'\\($0)'\" } ?? \"NULL\"),\n                \\(message.accountId.map { \"'\\($0)'\" } ?? \"NULL\"),\n                '\\(escapeSql(message.subject))', \\(message.senderName.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                \\(message.senderEmail.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                \\(message.dateSent.map { Int($0.timeIntervalSince1970) } ?? 0),\n                \\(message.dateReceived.map { Int($0.timeIntervalSince1970) } ?? 0),\n                \\(message.isRead ? 1 : 0), \\(message.isFlagged ? 1 : 0), \\(message.isDeleted ? 1 : 0),\n                \\(message.hasAttachments ? 1 : 0), \\(message.emlxPath.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                \\(message.bodyText.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                \\(message.bodyHtml.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                \\(now), \\(now),\n                '\\(message.mailboxStatus.rawValue)',\n                \\(message.pendingSyncAction.map { \"'\\($0.rawValue)'\" } ?? \"NULL\"),\n                \\(message.lastKnownMailboxId.map { String($0) } ?? \"NULL\"),\n                \\(message.inReplyTo.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                \\(referencesJson.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                \\(message.threadId.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                \\(message.threadPosition.map { String($0) } ?? \"NULL\"),\n                \\(message.threadTotal.map { String($0) } ?? \"NULL\")\n            )\n            ON CONFLICT(id) DO UPDATE SET\n                apple_rowid = excluded.apple_rowid,\n                message_id = excluded.message_id,\n                mailbox_id = excluded.mailbox_id,\n                mailbox_name = excluded.mailbox_name,\n                account_id = excluded.account_id,\n                subject = excluded.subject,\n                sender_name = excluded.sender_name,\n                sender_email = excluded.sender_email,\n                date_sent = excluded.date_sent,\n                date_received = excluded.date_received,\n                is_read = excluded.is_read,\n                is_flagged = excluded.is_flagged,\n                is_deleted = excluded.is_deleted,\n                has_attachments = excluded.has_attachments,\n                emlx_path = excluded.emlx_path,\n                body_text = excluded.body_text,\n                body_html = excluded.body_html,\n                updated_at = \\(now),\n                mailbox_status = excluded.mailbox_status,\n                pending_sync_action = excluded.pending_sync_action,\n                last_known_mailbox_id = excluded.last_known_mailbox_id,\n                in_reply_to = excluded.in_reply_to,\n                threading_references = excluded.threading_references,\n                thread_id = excluded.thread_id,\n                thread_position = excluded.thread_position,\n                thread_total = excluded.thread_total\n            \"\"\")\n    }\n\n    /// Get a message by its stable ID\n    public func getMessage(id: String) throws -> MailMessage? {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"SELECT * FROM messages WHERE id = '\\(escapeSql(id))'\")\n\n        for row in result {\n            return try rowToMessage(row)\n        }\n        return nil\n    }\n\n    /// Get a message by Apple Mail rowid\n    public func getMessage(appleRowId: Int) throws -> MailMessage? {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"SELECT * FROM messages WHERE apple_rowid = \\(appleRowId)\")\n\n        for row in result {\n            return try rowToMessage(row)\n        }\n        return nil\n    }\n\n    /// Search messages using FTS\n    public func searchMessages(query: String, limit: Int = 50, offset: Int = 0) throws -> [MailMessage] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"\"\"\n            SELECT m.* FROM messages m\n            JOIN messages_fts fts ON m.rowid = fts.rowid\n            WHERE messages_fts MATCH '\\(escapeSql(escapeFts5Query(query)))'\n            ORDER BY bm25(messages_fts)\n            LIMIT \\(limit) OFFSET \\(offset)\n            \"\"\")\n\n        var messages: [MailMessage] = []\n        for row in result {\n            if let message = try? rowToMessage(row) {\n                messages.append(message)\n            }\n        }\n        return messages\n    }\n\n    // MARK: - Structured Query Search\n\n    /// Parsed filter from a structured query\n    public struct SearchFilter {\n        public var from: String?\n        public var to: String?\n        public var subject: String?\n        public var mailbox: String?\n        public var isRead: Bool?\n        public var isFlagged: Bool?\n        public var dateAfter: Date?\n        public var dateBefore: Date?\n        public var hasAttachments: Bool?\n        public var freeText: String?\n        public var mailboxStatus: MailboxStatus?\n        /// Unknown filter names found in the query (e.g., \"badfilter\" from \"badfilter:value\")\n        public var unknownFilters: [String] = []\n\n        public init() {}\n\n        /// Check if any filters are set\n        public var hasFilters: Bool {\n            from != nil || to != nil || subject != nil || mailbox != nil ||\n            isRead != nil || isFlagged != nil || dateAfter != nil ||\n            dateBefore != nil || hasAttachments != nil || mailboxStatus != nil\n        }\n\n        /// Check if there's free text for FTS\n        public var hasFreeText: Bool {\n            freeText != nil && !freeText!.isEmpty\n        }\n\n        /// Check if unknown filters were found\n        public var hasUnknownFilters: Bool {\n            !unknownFilters.isEmpty\n        }\n\n        /// List of valid filter names for error messages\n        public static let validFilterNames = [\"from\", \"to\", \"subject\", \"mailbox\", \"is\", \"has\", \"after\", \"before\", \"date\"]\n    }\n\n    /// Parse a structured query string into filters\n    /// Supports: from:, to:, subject:, mailbox:, is:read, is:unread, is:flagged, is:unflagged,\n    /// after:, before:, date:, has:attachments\n    public func parseQuery(_ query: String) -> SearchFilter {\n        var filter = SearchFilter()\n\n        // Regex patterns for structured filters\n        let filterPatterns: [(pattern: String, handler: (String, inout SearchFilter) -> Void)] = [\n            // from: filter (email or name)\n            (\"from:\\\"([^\\\"]+)\\\"\", { value, f in f.from = value }),\n            (\"from:(\\\\S+)\", { value, f in f.from = value }),\n\n            // to: filter\n            (\"to:\\\"([^\\\"]+)\\\"\", { value, f in f.to = value }),\n            (\"to:(\\\\S+)\", { value, f in f.to = value }),\n\n            // subject: filter\n            (\"subject:\\\"([^\\\"]+)\\\"\", { value, f in f.subject = value }),\n            (\"subject:(\\\\S+)\", { value, f in f.subject = value }),\n\n            // mailbox: filter\n            (\"mailbox:\\\"([^\\\"]+)\\\"\", { value, f in f.mailbox = value }),\n            (\"mailbox:(\\\\S+)\", { value, f in f.mailbox = value }),\n\n            // is: status filters\n            (\"is:read\", { _, f in f.isRead = true }),\n            (\"is:unread\", { _, f in f.isRead = false }),\n            (\"is:flagged\", { _, f in f.isFlagged = true }),\n            (\"is:unflagged\", { _, f in f.isFlagged = false }),\n\n            // has: filters\n            (\"has:attachments?\", { _, f in f.hasAttachments = true }),\n\n            // Date filters (YYYY-MM-DD format)\n            (\"after:(\\\\d{4}-\\\\d{2}-\\\\d{2})\", { value, f in f.dateAfter = parseDate(value) }),\n            (\"before:(\\\\d{4}-\\\\d{2}-\\\\d{2})\", { value, f in f.dateBefore = parseDate(value) }),\n            (\"date:(\\\\d{4}-\\\\d{2}-\\\\d{2})\", { value, f in\n                // date: sets both after and before to cover the whole day\n                if let date = parseDate(value) {\n                    f.dateAfter = date\n                    // Set before to end of day\n                    if let endOfDay = Calendar.current.date(byAdding: .day, value: 1, to: date) {\n                        f.dateBefore = endOfDay\n                    }\n                }\n            })\n        ]\n\n        var remainingQuery = query\n\n        // Process each filter pattern\n        for (pattern, handler) in filterPatterns {\n            if let regex = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive) {\n                let range = NSRange(remainingQuery.startIndex..., in: remainingQuery)\n                let matches = regex.matches(in: remainingQuery, options: [], range: range)\n\n                // Process matches in reverse to preserve indices\n                for match in matches.reversed() {\n                    // Extract captured group if present, otherwise use the whole match\n                    let valueRange = match.numberOfRanges > 1 ? match.range(at: 1) : match.range\n                    if let swiftRange = Range(valueRange, in: remainingQuery) {\n                        let value = String(remainingQuery[swiftRange])\n                        handler(value, &filter)\n                    } else {\n                        handler(\"\", &filter)\n                    }\n\n                    // Remove matched text from query\n                    if let swiftRange = Range(match.range, in: remainingQuery) {\n                        remainingQuery.removeSubrange(swiftRange)\n                    }\n                }\n            }\n        }\n\n        // Clean up remaining query (free text for FTS)\n        let cleanedFreeText = remainingQuery\n            .trimmingCharacters(in: .whitespaces)\n            .components(separatedBy: .whitespaces)\n            .filter { !$0.isEmpty }\n            .joined(separator: \" \")\n\n        if !cleanedFreeText.isEmpty {\n            filter.freeText = cleanedFreeText\n        }\n\n        return filter\n    }\n\n    /// Search messages using structured filters and optional FTS\n    public func searchMessagesWithFilters(_ filter: SearchFilter, limit: Int = 50, offset: Int = 0) throws -> [MailMessage] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        var whereClauses: [String] = []\n\n        // Build WHERE clauses from filters\n\n        // from: filter (matches sender_name or sender_email)\n        if let from = filter.from {\n            let escaped = escapeSql(from)\n            whereClauses.append(\"(m.sender_email LIKE '%\\(escaped)%' OR m.sender_name LIKE '%\\(escaped)%')\")\n        }\n\n        // to: filter (requires join with recipients table)\n        // For simplicity, we'll use a subquery\n        if let to = filter.to {\n            let escaped = escapeSql(to)\n            whereClauses.append(\"\"\"\n                EXISTS (SELECT 1 FROM recipients r WHERE r.message_id = m.id\n                        AND (r.email LIKE '%\\(escaped)%' OR r.name LIKE '%\\(escaped)%'))\n                \"\"\")\n        }\n\n        // subject: filter\n        if let subject = filter.subject {\n            let escaped = escapeSql(subject)\n            whereClauses.append(\"m.subject LIKE '%\\(escaped)%'\")\n        }\n\n        // mailbox: filter\n        if let mailbox = filter.mailbox {\n            let escaped = escapeSql(mailbox)\n            whereClauses.append(\"m.mailbox_name LIKE '%\\(escaped)%'\")\n        }\n\n        // is:read / is:unread filter\n        if let isRead = filter.isRead {\n            whereClauses.append(\"m.is_read = \\(isRead ? 1 : 0)\")\n        }\n\n        // is:flagged / is:unflagged filter\n        if let isFlagged = filter.isFlagged {\n            whereClauses.append(\"m.is_flagged = \\(isFlagged ? 1 : 0)\")\n        }\n\n        // has:attachments filter\n        if let hasAttachments = filter.hasAttachments, hasAttachments {\n            whereClauses.append(\"m.has_attachments = 1\")\n        }\n\n        // Date filters\n        if let dateAfter = filter.dateAfter {\n            let timestamp = Int(dateAfter.timeIntervalSince1970)\n            whereClauses.append(\"m.date_received >= \\(timestamp)\")\n        }\n\n        if let dateBefore = filter.dateBefore {\n            let timestamp = Int(dateBefore.timeIntervalSince1970)\n            whereClauses.append(\"m.date_received < \\(timestamp)\")\n        }\n\n        // Mailbox status filter (inbox, archived, deleted)\n        if let mailboxStatus = filter.mailboxStatus {\n            whereClauses.append(\"m.mailbox_status = '\\(mailboxStatus.rawValue)'\")\n        }\n\n        // Always exclude deleted messages\n        whereClauses.append(\"m.is_deleted = 0\")\n\n        // Build the query\n        var sql: String\n\n        if filter.hasFreeText, let freeText = filter.freeText {\n            // Use FTS with additional filters\n            let whereClause = whereClauses.isEmpty ? \"\" : \"AND \" + whereClauses.joined(separator: \" AND \")\n            sql = \"\"\"\n                SELECT m.* FROM messages m\n                JOIN messages_fts fts ON m.rowid = fts.rowid\n                WHERE messages_fts MATCH '\\(escapeSql(escapeFts5Query(freeText)))'\n                \\(whereClause)\n                ORDER BY bm25(messages_fts)\n                LIMIT \\(limit) OFFSET \\(offset)\n                \"\"\"\n        } else if !whereClauses.isEmpty {\n            // Filters only, no FTS\n            let whereClause = whereClauses.joined(separator: \" AND \")\n            sql = \"\"\"\n                SELECT m.* FROM messages m\n                WHERE \\(whereClause)\n                ORDER BY m.date_received DESC\n                LIMIT \\(limit) OFFSET \\(offset)\n                \"\"\"\n        } else {\n            // No filters, return recent messages\n            sql = \"\"\"\n                SELECT * FROM messages m\n                WHERE m.is_deleted = 0\n                ORDER BY m.date_received DESC\n                LIMIT \\(limit) OFFSET \\(offset)\n                \"\"\"\n        }\n\n        let result = try conn.query(sql)\n\n        var messages: [MailMessage] = []\n        for row in result {\n            if let message = try? rowToMessage(row) {\n                messages.append(message)\n            }\n        }\n        return messages\n    }\n\n    /// Get all non-deleted messages (for export without search query)\n    /// - Parameters:\n    ///   - limit: Maximum number of messages to return\n    ///   - offset: Number of messages to skip for pagination\n    /// - Returns: Array of messages ordered by date received (newest first)\n    public func getAllMessages(limit: Int = 100, offset: Int = 0) throws -> [MailMessage] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let query = \"\"\"\n            SELECT * FROM messages\n            WHERE is_deleted = 0\n            ORDER BY date_received DESC\n            LIMIT \\(limit) OFFSET \\(offset)\n            \"\"\"\n\n        let result = try conn.query(query)\n        var messages: [MailMessage] = []\n        for row in result {\n            if let message = try? rowToMessage(row) {\n                messages.append(message)\n            }\n        }\n        return messages\n    }\n\n    /// Get messages that haven't been exported yet (export_path IS NULL)\n    /// Used for incremental auto-export after sync\n    /// - Parameter limit: Maximum number of messages to return (default: unlimited via 0)\n    /// - Returns: Array of messages that need to be exported\n    public func getMessagesNeedingExport(limit: Int = 0) throws -> [MailMessage] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        var query = \"\"\"\n            SELECT * FROM messages\n            WHERE is_deleted = 0 AND export_path IS NULL\n            ORDER BY date_received DESC\n            \"\"\"\n\n        if limit > 0 {\n            query += \" LIMIT \\(limit)\"\n        }\n\n        let result = try conn.query(query)\n        var messages: [MailMessage] = []\n        for row in result {\n            if let message = try? rowToMessage(row) {\n                messages.append(message)\n            }\n        }\n        return messages\n    }\n\n    /// Update the export path for a message\n    public func updateExportPath(id: String, path: String) throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let now = Int(Date().timeIntervalSince1970)\n        _ = try conn.execute(\"\"\"\n            UPDATE messages SET export_path = '\\(escapeSql(path))', updated_at = \\(now)\n            WHERE id = '\\(escapeSql(id))'\n            \"\"\")\n    }\n\n    /// Update the body content for a message (on-demand fetching)\n    /// - Parameters:\n    ///   - id: The message ID\n    ///   - bodyText: Plain text body content (optional)\n    ///   - bodyHtml: HTML body content (optional)\n    public func updateMessageBody(id: String, bodyText: String?, bodyHtml: String?) throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let now = Int(Date().timeIntervalSince1970)\n        _ = try conn.execute(\"\"\"\n            UPDATE messages SET\n                body_text = \\(bodyText.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                body_html = \\(bodyHtml.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                updated_at = \\(now)\n            WHERE id = '\\(escapeSql(id))'\n            \"\"\")\n    }\n\n    // MARK: - Sync Status Operations\n\n    /// Sync status key constants\n    public enum SyncStatusKey {\n        public static let state = \"sync_state\"\n        public static let lastSyncTime = \"last_sync_time\"\n        public static let lastSyncStartTime = \"last_sync_start_time\"\n        public static let lastSyncEndTime = \"last_sync_end_time\"\n        public static let lastSyncError = \"last_sync_error\"\n        public static let lastSyncMessagesAdded = \"last_sync_messages_added\"\n        public static let lastSyncMessagesUpdated = \"last_sync_messages_updated\"\n        public static let lastSyncMessagesDeleted = \"last_sync_messages_deleted\"\n        public static let lastSyncDuration = \"last_sync_duration\"\n        public static let lastSyncIsIncremental = \"last_sync_is_incremental\"\n    }\n\n    /// Sync state values\n    public enum SyncState: String {\n        case idle = \"idle\"\n        case running = \"running\"\n        case success = \"success\"\n        case failed = \"failed\"\n    }\n\n    /// Summary of sync status for reporting\n    public struct SyncStatusSummary {\n        public let state: SyncState\n        public let lastSyncTime: Date?\n        public let lastSyncStartTime: Date?\n        public let lastSyncEndTime: Date?\n        public let lastSyncError: String?\n        public let messagesAdded: Int\n        public let messagesUpdated: Int\n        public let messagesDeleted: Int\n        public let duration: TimeInterval?\n        public let isIncremental: Bool?\n\n        public init(\n            state: SyncState,\n            lastSyncTime: Date? = nil,\n            lastSyncStartTime: Date? = nil,\n            lastSyncEndTime: Date? = nil,\n            lastSyncError: String? = nil,\n            messagesAdded: Int = 0,\n            messagesUpdated: Int = 0,\n            messagesDeleted: Int = 0,\n            duration: TimeInterval? = nil,\n            isIncremental: Bool? = nil\n        ) {\n            self.state = state\n            self.lastSyncTime = lastSyncTime\n            self.lastSyncStartTime = lastSyncStartTime\n            self.lastSyncEndTime = lastSyncEndTime\n            self.lastSyncError = lastSyncError\n            self.messagesAdded = messagesAdded\n            self.messagesUpdated = messagesUpdated\n            self.messagesDeleted = messagesDeleted\n            self.duration = duration\n            self.isIncremental = isIncremental\n        }\n    }\n\n    /// Get a sync status value\n    public func getSyncStatus(key: String) throws -> String? {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"SELECT value FROM sync_status WHERE key = '\\(escapeSql(key))'\")\n\n        for row in result {\n            return try row.getString(0)\n        }\n        return nil\n    }\n\n    /// Set a sync status value\n    public func setSyncStatus(key: String, value: String) throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let now = Int(Date().timeIntervalSince1970)\n        _ = try conn.execute(\"\"\"\n            INSERT INTO sync_status (key, value, updated_at)\n            VALUES ('\\(escapeSql(key))', '\\(escapeSql(value))', \\(now))\n            ON CONFLICT(key) DO UPDATE SET\n                value = excluded.value,\n                updated_at = excluded.updated_at\n            \"\"\")\n    }\n\n    /// Get the last sync timestamp\n    public func getLastSyncTime() throws -> Date? {\n        if let value = try getSyncStatus(key: \"last_sync_time\"),\n           let timestamp = Double(value) {\n            return Date(timeIntervalSince1970: timestamp)\n        }\n        return nil\n    }\n\n    /// Set the last sync timestamp\n    public func setLastSyncTime(_ date: Date) throws {\n        try setSyncStatus(key: SyncStatusKey.lastSyncTime, value: String(date.timeIntervalSince1970))\n    }\n\n    /// Record that a sync operation has started\n    public func recordSyncStart(isIncremental: Bool) throws {\n        let now = Date()\n        try setSyncStatus(key: SyncStatusKey.state, value: SyncState.running.rawValue)\n        try setSyncStatus(key: SyncStatusKey.lastSyncStartTime, value: String(now.timeIntervalSince1970))\n        try setSyncStatus(key: SyncStatusKey.lastSyncIsIncremental, value: isIncremental ? \"1\" : \"0\")\n        // Clear previous error\n        try setSyncStatus(key: SyncStatusKey.lastSyncError, value: \"\")\n    }\n\n    /// Record successful sync completion\n    public func recordSyncSuccess(result: SyncResult) throws {\n        let now = Date()\n        try setSyncStatus(key: SyncStatusKey.state, value: SyncState.success.rawValue)\n        try setSyncStatus(key: SyncStatusKey.lastSyncEndTime, value: String(now.timeIntervalSince1970))\n        try setSyncStatus(key: SyncStatusKey.lastSyncTime, value: String(now.timeIntervalSince1970))\n        try setSyncStatus(key: SyncStatusKey.lastSyncMessagesAdded, value: String(result.messagesAdded))\n        try setSyncStatus(key: SyncStatusKey.lastSyncMessagesUpdated, value: String(result.messagesUpdated))\n        try setSyncStatus(key: SyncStatusKey.lastSyncMessagesDeleted, value: String(result.messagesDeleted))\n        try setSyncStatus(key: SyncStatusKey.lastSyncDuration, value: String(result.duration))\n        try setSyncStatus(key: SyncStatusKey.lastSyncError, value: \"\")\n    }\n\n    /// Record sync failure\n    public func recordSyncFailure(error: Error) throws {\n        let now = Date()\n        try setSyncStatus(key: SyncStatusKey.state, value: SyncState.failed.rawValue)\n        try setSyncStatus(key: SyncStatusKey.lastSyncEndTime, value: String(now.timeIntervalSince1970))\n        try setSyncStatus(key: SyncStatusKey.lastSyncError, value: error.localizedDescription)\n    }\n\n    /// Get a summary of the current sync status\n    public func getSyncStatusSummary() throws -> SyncStatusSummary {\n        let stateStr = try getSyncStatus(key: SyncStatusKey.state)\n        let state = stateStr.flatMap { SyncState(rawValue: $0) } ?? .idle\n\n        let lastSyncTime = try getSyncStatus(key: SyncStatusKey.lastSyncTime)\n            .flatMap { Double($0) }\n            .map { Date(timeIntervalSince1970: $0) }\n\n        let lastSyncStartTime = try getSyncStatus(key: SyncStatusKey.lastSyncStartTime)\n            .flatMap { Double($0) }\n            .map { Date(timeIntervalSince1970: $0) }\n\n        let lastSyncEndTime = try getSyncStatus(key: SyncStatusKey.lastSyncEndTime)\n            .flatMap { Double($0) }\n            .map { Date(timeIntervalSince1970: $0) }\n\n        let lastSyncError = try getSyncStatus(key: SyncStatusKey.lastSyncError)\n            .flatMap { $0.isEmpty ? nil : $0 }\n\n        let messagesAdded = try getSyncStatus(key: SyncStatusKey.lastSyncMessagesAdded)\n            .flatMap { Int($0) } ?? 0\n\n        let messagesUpdated = try getSyncStatus(key: SyncStatusKey.lastSyncMessagesUpdated)\n            .flatMap { Int($0) } ?? 0\n\n        let messagesDeleted = try getSyncStatus(key: SyncStatusKey.lastSyncMessagesDeleted)\n            .flatMap { Int($0) } ?? 0\n\n        let duration = try getSyncStatus(key: SyncStatusKey.lastSyncDuration)\n            .flatMap { Double($0) }\n\n        let isIncremental = try getSyncStatus(key: SyncStatusKey.lastSyncIsIncremental)\n            .map { $0 == \"1\" }\n\n        return SyncStatusSummary(\n            state: state,\n            lastSyncTime: lastSyncTime,\n            lastSyncStartTime: lastSyncStartTime,\n            lastSyncEndTime: lastSyncEndTime,\n            lastSyncError: lastSyncError,\n            messagesAdded: messagesAdded,\n            messagesUpdated: messagesUpdated,\n            messagesDeleted: messagesDeleted,\n            duration: duration,\n            isIncremental: isIncremental\n        )\n    }\n\n    // MARK: - Mailbox Operations\n\n    /// Upsert a mailbox\n    public func upsertMailbox(_ mailbox: Mailbox) throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let now = Int(Date().timeIntervalSince1970)\n        _ = try conn.execute(\"\"\"\n            INSERT INTO mailboxes (id, account_id, name, full_path, parent_id, message_count, unread_count, synced_at)\n            VALUES (\\(mailbox.id), '\\(escapeSql(mailbox.accountId))', '\\(escapeSql(mailbox.name))',\n                    '\\(escapeSql(mailbox.fullPath))', \\(mailbox.parentId ?? 0), \\(mailbox.messageCount),\n                    \\(mailbox.unreadCount), \\(now))\n            ON CONFLICT(id) DO UPDATE SET\n                account_id = excluded.account_id,\n                name = excluded.name,\n                full_path = excluded.full_path,\n                parent_id = excluded.parent_id,\n                message_count = excluded.message_count,\n                unread_count = excluded.unread_count,\n                synced_at = excluded.synced_at\n            \"\"\")\n    }\n\n    /// Get all mailboxes\n    public func getMailboxes() throws -> [Mailbox] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"SELECT * FROM mailboxes ORDER BY full_path\")\n\n        var mailboxes: [Mailbox] = []\n        for row in result {\n            if let mailbox = try? rowToMailbox(row) {\n                mailboxes.append(mailbox)\n            }\n        }\n        return mailboxes\n    }\n\n    // MARK: - FTS5 Trigger Management\n\n    /// Disable FTS5 triggers to prevent per-row FTS updates during bulk operations.\n    /// Call `rebuildFTSIndex()` after bulk operations complete to sync the FTS index.\n    public func disableFTSTriggers() throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        _ = try conn.execute(\"DROP TRIGGER IF EXISTS messages_ai\")\n        _ = try conn.execute(\"DROP TRIGGER IF EXISTS messages_ad\")\n        _ = try conn.execute(\"DROP TRIGGER IF EXISTS messages_au\")\n    }\n\n    /// Re-enable FTS5 triggers for incremental updates after bulk operations.\n    public func enableFTSTriggers() throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        // Recreate the triggers (same as in migration)\n        _ = try conn.execute(\"\"\"\n            CREATE TRIGGER IF NOT EXISTS messages_ai AFTER INSERT ON messages BEGIN\n                INSERT INTO messages_fts(rowid, subject, sender_name, sender_email, body_text)\n                VALUES (NEW.rowid, NEW.subject, NEW.sender_name, NEW.sender_email, NEW.body_text);\n            END\n            \"\"\")\n\n        _ = try conn.execute(\"\"\"\n            CREATE TRIGGER IF NOT EXISTS messages_ad AFTER DELETE ON messages BEGIN\n                INSERT INTO messages_fts(messages_fts, rowid, subject, sender_name, sender_email, body_text)\n                VALUES ('delete', OLD.rowid, OLD.subject, OLD.sender_name, OLD.sender_email, OLD.body_text);\n            END\n            \"\"\")\n\n        _ = try conn.execute(\"\"\"\n            CREATE TRIGGER IF NOT EXISTS messages_au AFTER UPDATE ON messages BEGIN\n                INSERT INTO messages_fts(messages_fts, rowid, subject, sender_name, sender_email, body_text)\n                VALUES ('delete', OLD.rowid, OLD.subject, OLD.sender_name, OLD.sender_email, OLD.body_text);\n                INSERT INTO messages_fts(rowid, subject, sender_name, sender_email, body_text)\n                VALUES (NEW.rowid, NEW.subject, NEW.sender_name, NEW.sender_email, NEW.body_text);\n            END\n            \"\"\")\n    }\n\n    /// Rebuild the FTS5 index from scratch using the messages table content.\n    /// This is much faster than per-row trigger updates for bulk operations.\n    /// Should be called after `disableFTSTriggers()` + bulk operations.\n    public func rebuildFTSIndex() throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        // Delete all FTS content and rebuild from the messages table\n        // The 'rebuild' command is a special FTS5 command that repopulates from the content table\n        _ = try conn.execute(\"INSERT INTO messages_fts(messages_fts) VALUES('rebuild')\")\n    }\n\n    // MARK: - Batch Insert Operations\n\n    /// Configuration for batch insert operations\n    public struct BatchInsertConfig: Sendable {\n        /// Number of messages to insert per transaction batch\n        public let batchSize: Int\n\n        /// Whether to disable FTS triggers during bulk operations (recommended for large syncs)\n        public let disableFTSTriggersForBulk: Bool\n\n        /// Default configuration with batch size of 1000 and FTS trigger optimization enabled\n        public static let `default` = BatchInsertConfig(batchSize: 1000, disableFTSTriggersForBulk: true)\n\n        public init(batchSize: Int = 1000, disableFTSTriggersForBulk: Bool = true) {\n            self.batchSize = max(1, batchSize)  // Ensure at least 1\n            self.disableFTSTriggersForBulk = disableFTSTriggersForBulk\n        }\n    }\n\n    /// Result of a batch insert operation\n    public struct BatchInsertResult: Sendable {\n        public let inserted: Int\n        public let updated: Int\n        public let failed: Int\n        public let errors: [String]\n        public let duration: TimeInterval\n\n        public init(inserted: Int, updated: Int, failed: Int, errors: [String], duration: TimeInterval) {\n            self.inserted = inserted\n            self.updated = updated\n            self.failed = failed\n            self.errors = errors\n            self.duration = duration\n        }\n    }\n\n    /// Insert or update multiple messages in batched transactions for improved performance.\n    /// Each batch is wrapped in a transaction for atomicity - if any insert in a batch fails,\n    /// the entire batch is rolled back.\n    ///\n    /// When `config.disableFTSTriggersForBulk` is true (default), FTS5 triggers are disabled\n    /// during the bulk operation and the FTS index is rebuilt once at the end. This prevents\n    /// the O(n^2) slowdown caused by per-row FTS trigger updates.\n    ///\n    /// - Parameters:\n    ///   - messages: Array of messages to insert/update\n    ///   - config: Batch configuration (default batch size: 1000)\n    /// - Returns: Result with counts and any errors\n    public func batchUpsertMessages(_ messages: [MailMessage], config: BatchInsertConfig = .default) throws -> BatchInsertResult {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let startTime = Date()\n        var totalInserted = 0\n        var totalUpdated = 0\n        var totalFailed = 0\n        var errors: [String] = []\n\n        let now = Int(Date().timeIntervalSince1970)\n\n        // Disable FTS triggers for bulk operations to prevent per-row FTS updates\n        // This is critical for performance: without this, second sync takes 5+ minutes\n        // because each UPDATE fires 2 FTS operations (delete old + insert new)\n        if config.disableFTSTriggersForBulk {\n            try disableFTSTriggers()\n        }\n\n        defer {\n            // Always re-enable triggers and rebuild FTS index\n            if config.disableFTSTriggersForBulk {\n                do {\n                    try rebuildFTSIndex()\n                    try enableFTSTriggers()\n                } catch {\n                    errors.append(\"FTS rebuild failed: \\(error.localizedDescription)\")\n                }\n            }\n        }\n\n        // Process in batches\n        let batches = stride(from: 0, to: messages.count, by: config.batchSize).map { startIndex in\n            let endIndex = min(startIndex + config.batchSize, messages.count)\n            return Array(messages[startIndex..<endIndex])\n        }\n\n        for (batchIndex, batch) in batches.enumerated() {\n            do {\n                let (inserted, updated) = try executeBatchTransaction(batch, connection: conn, timestamp: now)\n                totalInserted += inserted\n                totalUpdated += updated\n            } catch {\n                // Batch failed - record error and count all messages in batch as failed\n                totalFailed += batch.count\n                errors.append(\"Batch \\(batchIndex + 1) failed: \\(error.localizedDescription)\")\n            }\n        }\n\n        let duration = Date().timeIntervalSince(startTime)\n        return BatchInsertResult(\n            inserted: totalInserted,\n            updated: totalUpdated,\n            failed: totalFailed,\n            errors: errors,\n            duration: duration\n        )\n    }\n\n    /// Execute a single batch of inserts within a transaction\n    private func executeBatchTransaction(_ messages: [MailMessage], connection conn: Connection, timestamp: Int) throws -> (inserted: Int, updated: Int) {\n        var inserted = 0\n        var updated = 0\n\n        // Begin transaction\n        _ = try conn.execute(\"BEGIN TRANSACTION\")\n\n        do {\n            for message in messages {\n                // Check if message exists (for tracking insert vs update)\n                let existsResult = try conn.query(\"SELECT 1 FROM messages WHERE id = '\\(escapeSql(message.id))' LIMIT 1\")\n                var exists = false\n                for _ in existsResult {\n                    exists = true\n                    break\n                }\n\n                // Serialize references to JSON for storage\n                let referencesJson = serializeReferences(message.references)\n\n                // Execute upsert\n                _ = try conn.execute(\"\"\"\n                    INSERT INTO messages (\n                        id, apple_rowid, message_id, mailbox_id, mailbox_name, account_id,\n                        subject, sender_name, sender_email, date_sent, date_received,\n                        is_read, is_flagged, is_deleted, has_attachments, emlx_path,\n                        body_text, body_html, synced_at, updated_at,\n                        mailbox_status, pending_sync_action, last_known_mailbox_id,\n                        in_reply_to, threading_references, thread_id,\n                        thread_position, thread_total\n                    ) VALUES (\n                        '\\(escapeSql(message.id))', \\(message.appleRowId ?? 0), \\(message.messageId.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                        \\(message.mailboxId ?? 0), \\(message.mailboxName.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                        \\(message.accountId.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                        '\\(escapeSql(message.subject))', \\(message.senderName.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                        \\(message.senderEmail.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                        \\(message.dateSent.map { Int($0.timeIntervalSince1970) } ?? 0),\n                        \\(message.dateReceived.map { Int($0.timeIntervalSince1970) } ?? 0),\n                        \\(message.isRead ? 1 : 0), \\(message.isFlagged ? 1 : 0), \\(message.isDeleted ? 1 : 0),\n                        \\(message.hasAttachments ? 1 : 0), \\(message.emlxPath.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                        \\(message.bodyText.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                        \\(message.bodyHtml.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                        \\(timestamp), \\(timestamp),\n                        '\\(message.mailboxStatus.rawValue)',\n                        \\(message.pendingSyncAction.map { \"'\\($0.rawValue)'\" } ?? \"NULL\"),\n                        \\(message.lastKnownMailboxId.map { String($0) } ?? \"NULL\"),\n                        \\(message.inReplyTo.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                        \\(referencesJson.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                        \\(message.threadId.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                        \\(message.threadPosition.map { String($0) } ?? \"NULL\"),\n                        \\(message.threadTotal.map { String($0) } ?? \"NULL\")\n                    )\n                    ON CONFLICT(id) DO UPDATE SET\n                        apple_rowid = excluded.apple_rowid,\n                        message_id = excluded.message_id,\n                        mailbox_id = excluded.mailbox_id,\n                        mailbox_name = excluded.mailbox_name,\n                        account_id = excluded.account_id,\n                        subject = excluded.subject,\n                        sender_name = excluded.sender_name,\n                        sender_email = excluded.sender_email,\n                        date_sent = excluded.date_sent,\n                        date_received = excluded.date_received,\n                        is_read = excluded.is_read,\n                        is_flagged = excluded.is_flagged,\n                        is_deleted = excluded.is_deleted,\n                        has_attachments = excluded.has_attachments,\n                        emlx_path = excluded.emlx_path,\n                        body_text = excluded.body_text,\n                        body_html = excluded.body_html,\n                        updated_at = \\(timestamp),\n                        mailbox_status = excluded.mailbox_status,\n                        pending_sync_action = excluded.pending_sync_action,\n                        last_known_mailbox_id = excluded.last_known_mailbox_id,\n                        in_reply_to = excluded.in_reply_to,\n                        threading_references = excluded.threading_references,\n                        thread_id = excluded.thread_id,\n                        thread_position = excluded.thread_position,\n                        thread_total = excluded.thread_total\n                    \"\"\")\n\n                if exists {\n                    updated += 1\n                } else {\n                    inserted += 1\n                }\n            }\n\n            // Commit transaction\n            _ = try conn.execute(\"COMMIT\")\n\n            return (inserted, updated)\n        } catch {\n            // Rollback on any error\n            _ = try? conn.execute(\"ROLLBACK\")\n            throw error\n        }\n    }\n\n    /// Insert or update multiple mailboxes in a single transaction for improved performance.\n    ///\n    /// - Parameter mailboxes: Array of mailboxes to insert/update\n    public func batchUpsertMailboxes(_ mailboxes: [Mailbox]) throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let now = Int(Date().timeIntervalSince1970)\n\n        // Begin transaction\n        _ = try conn.execute(\"BEGIN TRANSACTION\")\n\n        do {\n            for mailbox in mailboxes {\n                _ = try conn.execute(\"\"\"\n                    INSERT INTO mailboxes (id, account_id, name, full_path, parent_id, message_count, unread_count, synced_at)\n                    VALUES (\\(mailbox.id), '\\(escapeSql(mailbox.accountId))', '\\(escapeSql(mailbox.name))',\n                            '\\(escapeSql(mailbox.fullPath))', \\(mailbox.parentId ?? 0), \\(mailbox.messageCount),\n                            \\(mailbox.unreadCount), \\(now))\n                    ON CONFLICT(id) DO UPDATE SET\n                        account_id = excluded.account_id,\n                        name = excluded.name,\n                        full_path = excluded.full_path,\n                        parent_id = excluded.parent_id,\n                        message_count = excluded.message_count,\n                        unread_count = excluded.unread_count,\n                        synced_at = excluded.synced_at\n                    \"\"\")\n            }\n\n            // Commit transaction\n            _ = try conn.execute(\"COMMIT\")\n        } catch {\n            // Rollback on any error\n            _ = try? conn.execute(\"ROLLBACK\")\n            throw error\n        }\n    }\n\n    // MARK: - Incremental Sync Support\n\n    /// Represents minimal message status info for change detection\n    public struct MessageStatus {\n        public let id: String\n        public let appleRowId: Int\n        public let isRead: Bool\n        public let isFlagged: Bool\n    }\n\n    /// Get all message statuses for change detection\n    public func getAllMessageStatuses() throws -> [MessageStatus] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"\"\"\n            SELECT id, apple_rowid, is_read, is_flagged\n            FROM messages\n            WHERE is_deleted = 0 AND apple_rowid IS NOT NULL\n            \"\"\")\n\n        var statuses: [MessageStatus] = []\n        for row in result {\n            guard let id = getStringValue(row, 0),\n                  let appleRowId = getIntValue(row, 1) else {\n                continue\n            }\n            let isRead = (getIntValue(row, 2) ?? 0) == 1\n            let isFlagged = (getIntValue(row, 3) ?? 0) == 1\n            statuses.append(MessageStatus(id: id, appleRowId: appleRowId, isRead: isRead, isFlagged: isFlagged))\n        }\n        return statuses\n    }\n\n    /// Update the read/flagged status of a message\n    public func updateMessageStatus(id: String, isRead: Bool, isFlagged: Bool) throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let now = Int(Date().timeIntervalSince1970)\n        _ = try conn.execute(\"\"\"\n            UPDATE messages\n            SET is_read = \\(isRead ? 1 : 0), is_flagged = \\(isFlagged ? 1 : 0), updated_at = \\(now)\n            WHERE id = '\\(escapeSql(id))'\n            \"\"\")\n    }\n\n    /// Get all Apple rowids from the mirror for deletion detection\n    public func getAllAppleRowIds() throws -> [Int] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"\"\"\n            SELECT apple_rowid FROM messages\n            WHERE is_deleted = 0 AND apple_rowid IS NOT NULL\n            \"\"\")\n\n        var rowIds: [Int] = []\n        for row in result {\n            if let rowId = getIntValue(row, 0) {\n                rowIds.append(rowId)\n            }\n        }\n        return rowIds\n    }\n\n    /// Mark a message as deleted (soft delete)\n    public func markMessageDeleted(appleRowId: Int) throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let now = Int(Date().timeIntervalSince1970)\n        _ = try conn.execute(\"\"\"\n            UPDATE messages SET is_deleted = 1, updated_at = \\(now)\n            WHERE apple_rowid = \\(appleRowId)\n            \"\"\")\n    }\n\n    // MARK: - Mailbox Status Operations (Bidirectional Sync)\n\n    /// Update the mailbox status of a message\n    /// - Parameters:\n    ///   - id: The message ID\n    ///   - status: The new mailbox status (inbox, archived, deleted)\n    public func updateMailboxStatus(id: String, status: MailboxStatus) throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let now = Int(Date().timeIntervalSince1970)\n        _ = try conn.execute(\"\"\"\n            UPDATE messages SET mailbox_status = '\\(status.rawValue)', updated_at = \\(now)\n            WHERE id = '\\(escapeSql(id))'\n            \"\"\")\n    }\n\n    /// Set a pending sync action for a message\n    /// - Parameters:\n    ///   - id: The message ID\n    ///   - action: The sync action to queue (archive or delete)\n    public func setPendingSyncAction(id: String, action: SyncAction) throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let now = Int(Date().timeIntervalSince1970)\n        _ = try conn.execute(\"\"\"\n            UPDATE messages SET pending_sync_action = '\\(action.rawValue)', updated_at = \\(now)\n            WHERE id = '\\(escapeSql(id))'\n            \"\"\")\n    }\n\n    /// Clear the pending sync action for a message (after successful sync)\n    /// - Parameter id: The message ID\n    public func clearPendingSyncAction(id: String) throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let now = Int(Date().timeIntervalSince1970)\n        _ = try conn.execute(\"\"\"\n            UPDATE messages SET pending_sync_action = NULL, updated_at = \\(now)\n            WHERE id = '\\(escapeSql(id))'\n            \"\"\")\n    }\n\n    /// Get all messages with pending sync actions\n    /// - Returns: Array of messages that have pending actions to sync to Apple Mail\n    public func getMessagesWithPendingActions() throws -> [MailMessage] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"\"\"\n            SELECT * FROM messages\n            WHERE pending_sync_action IS NOT NULL AND is_deleted = 0\n            ORDER BY updated_at ASC\n            \"\"\")\n\n        var messages: [MailMessage] = []\n        for row in result {\n            if let message = try? rowToMessage(row) {\n                messages.append(message)\n            }\n        }\n        return messages\n    }\n\n    /// Get messages filtered by mailbox status\n    /// - Parameters:\n    ///   - status: The mailbox status to filter by\n    ///   - limit: Maximum number of messages to return (default: 100)\n    ///   - offset: Number of messages to skip for pagination (default: 0)\n    /// - Returns: Array of messages with the specified status\n    public func getMessagesByStatus(_ status: MailboxStatus, limit: Int = 100, offset: Int = 0) throws -> [MailMessage] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"\"\"\n            SELECT * FROM messages\n            WHERE mailbox_status = '\\(status.rawValue)' AND is_deleted = 0\n            ORDER BY date_received DESC\n            LIMIT \\(limit) OFFSET \\(offset)\n            \"\"\")\n\n        var messages: [MailMessage] = []\n        for row in result {\n            if let message = try? rowToMessage(row) {\n                messages.append(message)\n            }\n        }\n        return messages\n    }\n\n    /// Get message counts grouped by mailbox status\n    /// - Returns: Dictionary with status as key and count as value\n    public func getMessageCountByStatus() throws -> [MailboxStatus: Int] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"\"\"\n            SELECT mailbox_status, COUNT(*) as count FROM messages\n            WHERE is_deleted = 0\n            GROUP BY mailbox_status\n            \"\"\")\n\n        var counts: [MailboxStatus: Int] = [\n            .inbox: 0,\n            .archived: 0,\n            .deleted: 0\n        ]\n\n        for row in result {\n            if let statusStr = getStringValue(row, 0),\n               let status = MailboxStatus(rawValue: statusStr),\n               let count = getIntValue(row, 1) {\n                counts[status] = count\n            }\n        }\n        return counts\n    }\n\n    /// Represents tracked message info for mailbox move detection\n    public struct TrackedMessageInfo {\n        public let id: String\n        public let appleRowId: Int\n        public let mailboxId: Int?\n        public let mailboxStatus: MailboxStatus\n    }\n\n    /// Get all tracked messages with their mailbox IDs for move detection\n    /// This includes all messages (inbox, archived, deleted status) so we can detect\n    /// when messages move between mailboxes, including moves back to INBOX.\n    /// - Returns: Array of tracked message info for all non-soft-deleted messages\n    public func getTrackedInboxMessages() throws -> [TrackedMessageInfo] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"\"\"\n            SELECT id, apple_rowid, mailbox_id, mailbox_status\n            FROM messages\n            WHERE is_deleted = 0\n              AND apple_rowid IS NOT NULL\n            \"\"\")\n\n        var messages: [TrackedMessageInfo] = []\n        for row in result {\n            guard let id = getStringValue(row, 0),\n                  let appleRowId = getIntValue(row, 1) else {\n                continue\n            }\n            let mailboxId = getIntValue(row, 2)\n            let statusStr = getStringValue(row, 3)\n            let status = statusStr.flatMap { MailboxStatus(rawValue: $0) } ?? .inbox\n\n            messages.append(TrackedMessageInfo(\n                id: id,\n                appleRowId: appleRowId,\n                mailboxId: mailboxId,\n                mailboxStatus: status\n            ))\n        }\n        return messages\n    }\n\n    // MARK: - Thread Operations\n\n    /// Insert or update a thread in the database\n    public func upsertThread(_ thread: Thread) throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let now = Int(Date().timeIntervalSince1970)\n\n        _ = try conn.execute(\"\"\"\n            INSERT INTO threads (\n                id, subject, participant_count, message_count, first_date, last_date,\n                created_at, updated_at\n            ) VALUES (\n                '\\(escapeSql(thread.id))',\n                \\(thread.subject.map { \"'\\(escapeSql($0))'\" } ?? \"NULL\"),\n                \\(thread.participantCount),\n                \\(thread.messageCount),\n                \\(thread.firstDate.map { String(Int($0.timeIntervalSince1970)) } ?? \"NULL\"),\n                \\(thread.lastDate.map { String(Int($0.timeIntervalSince1970)) } ?? \"NULL\"),\n                \\(now), \\(now)\n            )\n            ON CONFLICT(id) DO UPDATE SET\n                subject = COALESCE(excluded.subject, threads.subject),\n                participant_count = excluded.participant_count,\n                message_count = excluded.message_count,\n                first_date = MIN(COALESCE(threads.first_date, excluded.first_date), COALESCE(excluded.first_date, threads.first_date)),\n                last_date = MAX(COALESCE(threads.last_date, excluded.last_date), COALESCE(excluded.last_date, threads.last_date)),\n                updated_at = \\(now)\n            \"\"\")\n    }\n\n    /// Get a thread by its ID\n    public func getThread(id: String) throws -> Thread? {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"SELECT * FROM threads WHERE id = '\\(escapeSql(id))'\")\n\n        for row in result {\n            return try rowToThread(row)\n        }\n        return nil\n    }\n\n    /// Get all threads, ordered by last date descending\n    public func getThreads(limit: Int = 100, offset: Int = 0) throws -> [Thread] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"\"\"\n            SELECT * FROM threads\n            ORDER BY last_date DESC\n            LIMIT \\(limit) OFFSET \\(offset)\n            \"\"\")\n\n        var threads: [Thread] = []\n        for row in result {\n            if let thread = try? rowToThread(row) {\n                threads.append(thread)\n            }\n        }\n        return threads\n    }\n\n    /// Get threads with filtering and sorting options\n    /// - Parameters:\n    ///   - limit: Maximum number of threads to return\n    ///   - offset: Number of threads to skip (for pagination)\n    ///   - sortBy: Sort order for results\n    ///   - participant: Filter by participant email (matches sender or recipient)\n    /// - Returns: Array of threads matching the criteria\n    public func getThreads(\n        limit: Int = 100,\n        offset: Int = 0,\n        sortBy: ThreadSortOrder = .date,\n        participant: String? = nil\n    ) throws -> [Thread] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        var sql: String\n        if let participant = participant {\n            // Filter threads by participant (sender or recipient in any message)\n            // Uses EXISTS subqueries for better query plan optimization vs JOINs\n            // Note: LIKE with leading % cannot use indexes, but EXISTS limits the scan\n            // to messages within each thread rather than a full cross-join\n            let escaped = escapeSql(participant.lowercased())\n            sql = \"\"\"\n                SELECT t.* FROM threads t\n                WHERE EXISTS (\n                    SELECT 1 FROM thread_messages tm\n                    JOIN messages m ON tm.message_id = m.id\n                    WHERE tm.thread_id = t.id\n                    AND LOWER(m.sender_email) LIKE '%\\(escaped)%'\n                )\n                OR EXISTS (\n                    SELECT 1 FROM thread_messages tm\n                    JOIN messages m ON tm.message_id = m.id\n                    JOIN recipients r ON m.id = r.message_id\n                    WHERE tm.thread_id = t.id\n                    AND LOWER(r.email) LIKE '%\\(escaped)%'\n                )\n                ORDER BY t.\\(sortBy.sqlOrderBy)\n                LIMIT \\(limit) OFFSET \\(offset)\n                \"\"\"\n        } else {\n            sql = \"\"\"\n                SELECT * FROM threads\n                ORDER BY \\(sortBy.sqlOrderBy)\n                LIMIT \\(limit) OFFSET \\(offset)\n                \"\"\"\n        }\n\n        let result = try conn.query(sql)\n\n        var threads: [Thread] = []\n        for row in result {\n            if let thread = try? rowToThread(row) {\n                threads.append(thread)\n            }\n        }\n        return threads\n    }\n\n    /// Get count of threads matching filter criteria\n    /// - Parameter participant: Filter by participant email (matches sender or recipient)\n    /// - Returns: Count of matching threads\n    public func getThreadCount(participant: String? = nil) throws -> Int {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        var sql: String\n        if let participant = participant {\n            // Use EXISTS subqueries for efficient counting with participant filter\n            let escaped = escapeSql(participant.lowercased())\n            sql = \"\"\"\n                SELECT COUNT(*) FROM threads t\n                WHERE EXISTS (\n                    SELECT 1 FROM thread_messages tm\n                    JOIN messages m ON tm.message_id = m.id\n                    WHERE tm.thread_id = t.id\n                    AND LOWER(m.sender_email) LIKE '%\\(escaped)%'\n                )\n                OR EXISTS (\n                    SELECT 1 FROM thread_messages tm\n                    JOIN messages m ON tm.message_id = m.id\n                    JOIN recipients r ON m.id = r.message_id\n                    WHERE tm.thread_id = t.id\n                    AND LOWER(r.email) LIKE '%\\(escaped)%'\n                )\n                \"\"\"\n        } else {\n            sql = \"SELECT COUNT(*) FROM threads\"\n        }\n\n        let result = try conn.query(sql)\n        for row in result {\n            return getIntValue(row, 0) ?? 0\n        }\n        return 0\n    }\n\n    /// Get all messages in a thread\n    public func getMessagesInThread(threadId: String, limit: Int = 100, offset: Int = 0) throws -> [MailMessage] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"\"\"\n            SELECT * FROM messages\n            WHERE thread_id = '\\(escapeSql(threadId))' AND is_deleted = 0\n            ORDER BY date_received ASC\n            LIMIT \\(limit) OFFSET \\(offset)\n            \"\"\")\n\n        var messages: [MailMessage] = []\n        for row in result {\n            if let message = try? rowToMessage(row) {\n                messages.append(message)\n            }\n        }\n        return messages\n    }\n\n    /// Update the thread_id for a message\n    public func updateMessageThreadId(messageId: String, threadId: String) throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let now = Int(Date().timeIntervalSince1970)\n        _ = try conn.execute(\"\"\"\n            UPDATE messages SET thread_id = '\\(escapeSql(threadId))', updated_at = \\(now)\n            WHERE id = '\\(escapeSql(messageId))'\n            \"\"\")\n    }\n\n    /// Update the thread position metadata for a message\n    /// - Parameters:\n    ///   - messageId: The message ID to update\n    ///   - threadPosition: Position of the message within its thread (1-based)\n    ///   - threadTotal: Total number of messages in the thread\n    public func updateMessageThreadPosition(messageId: String, threadPosition: Int, threadTotal: Int) throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let now = Int(Date().timeIntervalSince1970)\n        _ = try conn.execute(\"\"\"\n            UPDATE messages SET thread_position = \\(threadPosition), thread_total = \\(threadTotal), updated_at = \\(now)\n            WHERE id = '\\(escapeSql(messageId))'\n            \"\"\")\n    }\n\n    /// Update thread position metadata for all messages in a thread\n    /// Uses batch update for efficiency with large threads\n    /// - Parameter threadId: The thread ID whose messages should be updated\n    public func updateThreadPositions(threadId: String) throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        // Get all messages in the thread ordered by date\n        let messages = try getMessagesInThreadViaJunction(threadId: threadId, limit: 10000, offset: 0)\n        let total = messages.count\n\n        if total == 0 {\n            return\n        }\n\n        // For small threads, use individual updates (simpler, avoids query size limits)\n        if total <= 10 {\n            for (index, message) in messages.enumerated() {\n                try updateMessageThreadPosition(messageId: message.id, threadPosition: index + 1, threadTotal: total)\n            }\n            return\n        }\n\n        // For larger threads, use batch update with CASE statement for efficiency\n        // This reduces N database round trips to just 1\n        let now = Int(Date().timeIntervalSince1970)\n\n        // Build CASE statement for positions\n        var caseClauses: [String] = []\n        var idList: [String] = []\n        for (index, message) in messages.enumerated() {\n            let escapedId = escapeSql(message.id)\n            caseClauses.append(\"WHEN '\\(escapedId)' THEN \\(index + 1)\")\n            idList.append(\"'\\(escapedId)'\")\n        }\n\n        let sql = \"\"\"\n            UPDATE messages SET\n                thread_position = CASE id\n                    \\(caseClauses.joined(separator: \"\\n                \"))\n                    ELSE thread_position\n                END,\n                thread_total = \\(total),\n                updated_at = \\(now)\n            WHERE id IN (\\(idList.joined(separator: \", \")))\n            \"\"\"\n\n        _ = try conn.execute(sql)\n    }\n\n    /// Get the count of threads\n    public func getThreadCount() throws -> Int {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"SELECT COUNT(*) FROM threads\")\n        for row in result {\n            return getIntValue(row, 0) ?? 0\n        }\n        return 0\n    }\n\n    // MARK: - Thread-Message Junction Operations\n\n    /// Add a message to a thread (creates the junction table entry)\n    /// - Parameters:\n    ///   - messageId: The message ID to add\n    ///   - threadId: The thread ID to add the message to\n    public func addMessageToThread(messageId: String, threadId: String) throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        _ = try conn.execute(\"\"\"\n            INSERT OR IGNORE INTO thread_messages (thread_id, message_id)\n            VALUES ('\\(escapeSql(threadId))', '\\(escapeSql(messageId))')\n            \"\"\")\n    }\n\n    /// Remove a message from a thread (deletes the junction table entry)\n    /// - Parameters:\n    ///   - messageId: The message ID to remove\n    ///   - threadId: The thread ID to remove the message from\n    public func removeMessageFromThread(messageId: String, threadId: String) throws {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        _ = try conn.execute(\"\"\"\n            DELETE FROM thread_messages\n            WHERE thread_id = '\\(escapeSql(threadId))' AND message_id = '\\(escapeSql(messageId))'\n            \"\"\")\n    }\n\n    /// Get all message IDs in a thread via the junction table\n    /// - Parameter threadId: The thread ID to query\n    /// - Returns: Array of message IDs in the thread\n    public func getMessageIdsInThread(threadId: String) throws -> [String] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"\"\"\n            SELECT message_id FROM thread_messages\n            WHERE thread_id = '\\(escapeSql(threadId))'\n            ORDER BY added_at ASC\n            \"\"\")\n\n        var messageIds: [String] = []\n        for row in result {\n            if let messageId = getStringValue(row, 0) {\n                messageIds.append(messageId)\n            }\n        }\n        return messageIds\n    }\n\n    /// Get all thread IDs that a message belongs to via the junction table\n    /// - Parameter messageId: The message ID to query\n    /// - Returns: Array of thread IDs the message belongs to\n    public func getThreadIdsForMessage(messageId: String) throws -> [String] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"\"\"\n            SELECT thread_id FROM thread_messages\n            WHERE message_id = '\\(escapeSql(messageId))'\n            ORDER BY added_at ASC\n            \"\"\")\n\n        var threadIds: [String] = []\n        for row in result {\n            if let threadId = getStringValue(row, 0) {\n                threadIds.append(threadId)\n            }\n        }\n        return threadIds\n    }\n\n    /// Get full messages in a thread via the junction table\n    /// - Parameters:\n    ///   - threadId: The thread ID to query\n    ///   - limit: Maximum number of messages to return\n    ///   - offset: Number of messages to skip for pagination\n    /// - Returns: Array of MailMessage objects in the thread\n    public func getMessagesInThreadViaJunction(threadId: String, limit: Int = 100, offset: Int = 0) throws -> [MailMessage] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"\"\"\n            SELECT m.* FROM messages m\n            JOIN thread_messages tm ON m.id = tm.message_id\n            WHERE tm.thread_id = '\\(escapeSql(threadId))' AND m.is_deleted = 0\n            ORDER BY m.date_received ASC\n            LIMIT \\(limit) OFFSET \\(offset)\n            \"\"\")\n\n        var messages: [MailMessage] = []\n        for row in result {\n            if let message = try? rowToMessage(row) {\n                messages.append(message)\n            }\n        }\n        return messages\n    }\n\n    /// Get full threads that a message belongs to via the junction table\n    /// - Parameter messageId: The message ID to query\n    /// - Returns: Array of Thread objects the message belongs to\n    public func getThreadsForMessage(messageId: String) throws -> [Thread] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"\"\"\n            SELECT t.* FROM threads t\n            JOIN thread_messages tm ON t.id = tm.thread_id\n            WHERE tm.message_id = '\\(escapeSql(messageId))'\n            ORDER BY t.last_date DESC\n            \"\"\")\n\n        var threads: [Thread] = []\n        for row in result {\n            if let thread = try? rowToThread(row) {\n                threads.append(thread)\n            }\n        }\n        return threads\n    }\n\n    /// Get the count of messages in a thread via the junction table\n    /// - Parameter threadId: The thread ID to query\n    /// - Returns: Number of messages in the thread\n    public func getMessageCountInThread(threadId: String) throws -> Int {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"\"\"\n            SELECT COUNT(*) FROM thread_messages\n            WHERE thread_id = '\\(escapeSql(threadId))'\n            \"\"\")\n\n        for row in result {\n            return getIntValue(row, 0) ?? 0\n        }\n        return 0\n    }\n\n    /// Check if a message is in a thread\n    /// - Parameters:\n    ///   - messageId: The message ID to check\n    ///   - threadId: The thread ID to check\n    /// - Returns: True if the message is in the thread\n    public func isMessageInThread(messageId: String, threadId: String) throws -> Bool {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"\"\"\n            SELECT 1 FROM thread_messages\n            WHERE thread_id = '\\(escapeSql(threadId))' AND message_id = '\\(escapeSql(messageId))'\n            LIMIT 1\n            \"\"\")\n\n        for _ in result {\n            return true\n        }\n        return false\n    }\n\n    // MARK: - Helpers\n\n    private func escapeSql(_ string: String) -> String {\n        string.replacingOccurrences(of: \"'\", with: \"''\")\n    }\n\n    /// Escape a query string for safe use in FTS5 MATCH clauses.\n    /// FTS5 has special syntax characters (\", *, OR, AND, NOT, NEAR, etc.) that can cause\n    /// syntax errors if not properly escaped. This function wraps the query in double quotes\n    /// to treat it as a literal phrase, escaping any embedded double quotes.\n    /// - Parameter query: The user's search query\n    /// - Returns: A safely escaped FTS5 query string\n    private func escapeFts5Query(_ query: String) -> String {\n        // Empty or whitespace-only queries should return empty (will match nothing)\n        let trimmed = query.trimmingCharacters(in: .whitespacesAndNewlines)\n        guard !trimmed.isEmpty else {\n            return \"\\\"\\\"\"\n        }\n\n        // In FTS5, wrapping a term in double quotes makes it a literal phrase.\n        // Any double quotes within the phrase must be escaped by doubling them.\n        // Example: search for hello\"world becomes \"hello\"\"world\"\n        let escaped = trimmed.replacingOccurrences(of: \"\\\"\", with: \"\\\"\\\"\")\n        return \"\\\"\\(escaped)\\\"\"\n    }\n\n    /// Serialize a references array to JSON string for database storage\n    private func serializeReferences(_ references: [String]) -> String? {\n        guard !references.isEmpty else { return nil }\n        guard let data = try? JSONEncoder().encode(references),\n              let json = String(data: data, encoding: .utf8) else {\n            return nil\n        }\n        return json\n    }\n\n    /// Deserialize a JSON string to references array\n    private func deserializeReferences(_ json: String?) -> [String] {\n        guard let json = json,\n              let data = json.data(using: .utf8),\n              let references = try? JSONDecoder().decode([String].self, from: data) else {\n            return []\n        }\n        return references\n    }\n}\n\n/// Parse a date string in YYYY-MM-DD format\nprivate func parseDate(_ string: String) -> Date? {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"yyyy-MM-dd\"\n    formatter.timeZone = TimeZone.current\n    return formatter.date(from: string)\n}\n\nextension MailDatabase {\n\n    private func getValue(_ row: Row, _ index: Int32) -> Value? {\n        try? row.get(index)\n    }\n\n    private func getStringValue(_ row: Row, _ index: Int32) -> String? {\n        guard let value = getValue(row, index) else { return nil }\n        if case .text(let str) = value {\n            return str\n        }\n        return nil\n    }\n\n    private func getIntValue(_ row: Row, _ index: Int32) -> Int? {\n        guard let value = getValue(row, index) else { return nil }\n        if case .integer(let num) = value {\n            return Int(num)\n        }\n        return nil\n    }\n\n    private func rowToMessage(_ row: Row) throws -> MailMessage {\n        // Parse mailbox_status (column 21) - default to .inbox if null or unknown\n        let mailboxStatusStr = getStringValue(row, 21)\n        let mailboxStatus = mailboxStatusStr.flatMap { MailboxStatus(rawValue: $0) } ?? .inbox\n\n        // Parse pending_sync_action (column 22) - nullable\n        let pendingSyncActionStr = getStringValue(row, 22)\n        let pendingSyncAction = pendingSyncActionStr.flatMap { SyncAction(rawValue: $0) }\n\n        // Parse threading headers (columns 24, 25) - added in migration V3\n        let inReplyTo = getStringValue(row, 24)\n        let referencesJson = getStringValue(row, 25)\n        let references = deserializeReferences(referencesJson)\n\n        // Parse thread_id (column 26) - added in migration V4\n        let threadId = getStringValue(row, 26)\n\n        // Parse thread_position (column 27) and thread_total (column 28) - added in migration V6\n        let threadPosition = getIntValue(row, 27)\n        let threadTotal = getIntValue(row, 28)\n\n        return MailMessage(\n            id: getStringValue(row, 0) ?? \"\",\n            appleRowId: getIntValue(row, 1),\n            messageId: getStringValue(row, 2),\n            mailboxId: getIntValue(row, 3),\n            mailboxName: getStringValue(row, 4),\n            accountId: getStringValue(row, 5),\n            subject: getStringValue(row, 6) ?? \"\",\n            senderName: getStringValue(row, 7),\n            senderEmail: getStringValue(row, 8),\n            dateSent: getIntValue(row, 9).map { Date(timeIntervalSince1970: Double($0)) },\n            dateReceived: getIntValue(row, 10).map { Date(timeIntervalSince1970: Double($0)) },\n            isRead: (getIntValue(row, 11) ?? 0) == 1,\n            isFlagged: (getIntValue(row, 12) ?? 0) == 1,\n            isDeleted: (getIntValue(row, 13) ?? 0) == 1,\n            hasAttachments: (getIntValue(row, 14) ?? 0) == 1,\n            emlxPath: getStringValue(row, 15),\n            bodyText: getStringValue(row, 16),\n            bodyHtml: getStringValue(row, 17),\n            exportPath: getStringValue(row, 18),\n            mailboxStatus: mailboxStatus,\n            pendingSyncAction: pendingSyncAction,\n            lastKnownMailboxId: getIntValue(row, 23),\n            inReplyTo: inReplyTo,\n            references: references,\n            threadId: threadId,\n            threadPosition: threadPosition,\n            threadTotal: threadTotal\n        )\n    }\n\n    private func rowToMailbox(_ row: Row) throws -> Mailbox {\n        Mailbox(\n            id: getIntValue(row, 0) ?? 0,\n            accountId: getStringValue(row, 1) ?? \"\",\n            name: getStringValue(row, 2) ?? \"\",\n            fullPath: getStringValue(row, 3) ?? \"\",\n            parentId: getIntValue(row, 4),\n            messageCount: getIntValue(row, 5) ?? 0,\n            unreadCount: getIntValue(row, 6) ?? 0\n        )\n    }\n\n    private func rowToThread(_ row: Row) throws -> Thread {\n        Thread(\n            id: getStringValue(row, 0) ?? \"\",\n            subject: getStringValue(row, 1),\n            participantCount: getIntValue(row, 2) ?? 0,\n            messageCount: getIntValue(row, 3) ?? 0,\n            firstDate: getIntValue(row, 4).map { Date(timeIntervalSince1970: Double($0)) },\n            lastDate: getIntValue(row, 5).map { Date(timeIntervalSince1970: Double($0)) },\n            createdAt: getIntValue(row, 6).map { Date(timeIntervalSince1970: Double($0)) },\n            updatedAt: getIntValue(row, 7).map { Date(timeIntervalSince1970: Double($0)) }\n        )\n    }\n\n    // MARK: - Index Verification (for testing)\n\n    /// Get list of indexes on a table\n    /// - Parameter tableName: The table to query indexes for\n    /// - Returns: Array of index names\n    public func getIndexes(on tableName: String) throws -> [String] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"PRAGMA index_list('\\(escapeSql(tableName))')\")\n        var indexes: [String] = []\n        for row in result {\n            if let name = getStringValue(row, 1) {\n                indexes.append(name)\n            }\n        }\n        return indexes\n    }\n\n    /// Run EXPLAIN QUERY PLAN and return the plan details\n    /// - Parameter query: The SQL query to explain\n    /// - Returns: Array of plan detail strings\n    public func explainQueryPlan(_ query: String) throws -> [String] {\n        guard let conn = connection else {\n            throw MailDatabaseError.notInitialized\n        }\n\n        let result = try conn.query(\"EXPLAIN QUERY PLAN \\(query)\")\n        var planDetails: [String] = []\n        for row in result {\n            if let detail = getStringValue(row, 3) {\n                planDetails.append(detail)\n            }\n        }\n        return planDetails\n    }\n}\n\n// MARK: - Data Models\n\n/// Tracks the mailbox status of a message for bidirectional sync\npublic enum MailboxStatus: String, Sendable {\n    case inbox = \"inbox\"\n    case archived = \"archived\"\n    case deleted = \"deleted\"\n}\n\n/// Pending sync action to be pushed to Apple Mail\npublic enum SyncAction: String, Sendable {\n    case archive = \"archive\"\n    case delete = \"delete\"\n}\n\n/// Represents a mirrored email message\npublic struct MailMessage: Sendable {\n    public let id: String\n    public let appleRowId: Int?\n    public let messageId: String?\n    public let mailboxId: Int?\n    public let mailboxName: String?\n    public let accountId: String?\n    public let subject: String\n    public let senderName: String?\n    public let senderEmail: String?\n    public let dateSent: Date?\n    public let dateReceived: Date?\n    public let isRead: Bool\n    public let isFlagged: Bool\n    public let isDeleted: Bool\n    public let hasAttachments: Bool\n    public let emlxPath: String?\n    public let bodyText: String?\n    public let bodyHtml: String?\n    public let exportPath: String?\n    // Mailbox status tracking for bidirectional sync (added in migration V2)\n    public let mailboxStatus: MailboxStatus\n    public let pendingSyncAction: SyncAction?\n    public let lastKnownMailboxId: Int?\n    // Threading headers (added in migration V3)\n    public let inReplyTo: String?\n    public let references: [String]\n    // Thread ID reference (added in migration V4)\n    public let threadId: String?\n    // Thread position metadata (added in migration V6)\n    public let threadPosition: Int?\n    public let threadTotal: Int?\n\n    public init(\n        id: String,\n        appleRowId: Int? = nil,\n        messageId: String? = nil,\n        mailboxId: Int? = nil,\n        mailboxName: String? = nil,\n        accountId: String? = nil,\n        subject: String,\n        senderName: String? = nil,\n        senderEmail: String? = nil,\n        dateSent: Date? = nil,\n        dateReceived: Date? = nil,\n        isRead: Bool = false,\n        isFlagged: Bool = false,\n        isDeleted: Bool = false,\n        hasAttachments: Bool = false,\n        emlxPath: String? = nil,\n        bodyText: String? = nil,\n        bodyHtml: String? = nil,\n        exportPath: String? = nil,\n        mailboxStatus: MailboxStatus = .inbox,\n        pendingSyncAction: SyncAction? = nil,\n        lastKnownMailboxId: Int? = nil,\n        inReplyTo: String? = nil,\n        references: [String] = [],\n        threadId: String? = nil,\n        threadPosition: Int? = nil,\n        threadTotal: Int? = nil\n    ) {\n        self.id = id\n        self.appleRowId = appleRowId\n        self.messageId = messageId\n        self.mailboxId = mailboxId\n        self.mailboxName = mailboxName\n        self.accountId = accountId\n        self.subject = subject\n        self.senderName = senderName\n        self.senderEmail = senderEmail\n        self.dateSent = dateSent\n        self.dateReceived = dateReceived\n        self.isRead = isRead\n        self.isFlagged = isFlagged\n        self.isDeleted = isDeleted\n        self.hasAttachments = hasAttachments\n        self.emlxPath = emlxPath\n        self.bodyText = bodyText\n        self.bodyHtml = bodyHtml\n        self.exportPath = exportPath\n        self.mailboxStatus = mailboxStatus\n        self.pendingSyncAction = pendingSyncAction\n        self.lastKnownMailboxId = lastKnownMailboxId\n        self.inReplyTo = inReplyTo\n        self.references = references\n        self.threadId = threadId\n        self.threadPosition = threadPosition\n        self.threadTotal = threadTotal\n    }\n}\n\n/// Represents a mailbox/folder\npublic struct Mailbox: Sendable {\n    public let id: Int\n    public let accountId: String\n    public let name: String\n    public let fullPath: String\n    public let parentId: Int?\n    public let messageCount: Int\n    public let unreadCount: Int\n\n    public init(\n        id: Int,\n        accountId: String,\n        name: String,\n        fullPath: String,\n        parentId: Int? = nil,\n        messageCount: Int = 0,\n        unreadCount: Int = 0\n    ) {\n        self.id = id\n        self.accountId = accountId\n        self.name = name\n        self.fullPath = fullPath\n        self.parentId = parentId\n        self.messageCount = messageCount\n        self.unreadCount = unreadCount\n    }\n}\n\n/// Represents an email attachment\npublic struct MailAttachment: Sendable {\n    public let id: Int\n    public let messageId: String\n    public let filename: String\n    public let mimeType: String?\n    public let size: Int?\n    public let contentId: String?\n    public let isInline: Bool\n\n    public init(\n        id: Int = 0,\n        messageId: String,\n        filename: String,\n        mimeType: String? = nil,\n        size: Int? = nil,\n        contentId: String? = nil,\n        isInline: Bool = false\n    ) {\n        self.id = id\n        self.messageId = messageId\n        self.filename = filename\n        self.mimeType = mimeType\n        self.size = size\n        self.contentId = contentId\n        self.isInline = isInline\n    }\n}\n\n/// Represents a conversation thread grouping related messages\npublic struct Thread: Sendable {\n    public let id: String\n    public let subject: String?\n    public let participantCount: Int\n    public let messageCount: Int\n    public let firstDate: Date?\n    public let lastDate: Date?\n    public let createdAt: Date?\n    public let updatedAt: Date?\n\n    public init(\n        id: String,\n        subject: String? = nil,\n        participantCount: Int = 0,\n        messageCount: Int = 0,\n        firstDate: Date? = nil,\n        lastDate: Date? = nil,\n        createdAt: Date? = nil,\n        updatedAt: Date? = nil\n    ) {\n        self.id = id\n        self.subject = subject\n        self.participantCount = participantCount\n        self.messageCount = messageCount\n        self.firstDate = firstDate\n        self.lastDate = lastDate\n        self.createdAt = createdAt\n        self.updatedAt = updatedAt\n    }\n}\n\n/// Protocol for thread-like types to avoid ambiguity with Foundation.Thread in CLI\npublic protocol ThreadLike {\n    var id: String { get }\n    var subject: String? { get }\n    var participantCount: Int { get }\n    var messageCount: Int { get }\n    var firstDate: Date? { get }\n    var lastDate: Date? { get }\n}\n\nextension Thread: ThreadLike {}\n","structuredPatch":[{"oldStart":779,"oldLines":13,"newStart":779,"newLines":31,"lines":["             }","         }"," ","-        // Clean up remaining query (free text for FTS)","-        let cleanedFreeText = remainingQuery","+        // Clean up remaining query and detect unknown filters","+        let tokens = remainingQuery","             .trimmingCharacters(in: .whitespaces)","             .components(separatedBy: .whitespaces)","             .filter { !$0.isEmpty }","-            .joined(separator: \" \")"," ","+        // Check for unknown filter patterns (word:value format)","+        // Valid filter prefixes: from, to, subject, mailbox, is, has, after, before, date","+        let unknownFilterRegex = try? NSRegularExpression(pattern: \"^([a-zA-Z]+):\", options: [])","+        var freeTextTokens: [String] = []","+","+        for token in tokens {","+            let range = NSRange(token.startIndex..., in: token)","+            if let match = unknownFilterRegex?.firstMatch(in: token, options: [], range: range),","+               let filterNameRange = Range(match.range(at: 1), in: token) {","+                let filterName = String(token[filterNameRange]).lowercased()","+                // Check if this is an unknown filter name","+                if !SearchFilter.validFilterNames.contains(filterName) {","+                    filter.unknownFilters.append(filterName)","+                }","+            }","+            freeTextTokens.append(token)","+        }","+","+        let cleanedFreeText = freeTextTokens.joined(separator: \" \")","         if !cleanedFreeText.isEmpty {","             filter.freeText = cleanedFreeText","         }"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_012e6Z9ice3MrAvW6rs93Mdz","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to update the `MailSearchCommand` in the CLI to check for unknown filters and display a user-friendly error message. Let me look at the command handler:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1293,"cache_read_input_tokens":52597,"cache_creation":{"ephemeral_5m_input_tokens":1293,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"cc42743f-a65f-4d14-a17e-1ef444fd57fe"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_012e6Z9ice3MrAvW6rs93Mdz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Ckq3FFyCVc4nnT5o8zM14L","name":"Read","input":{"file_path":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEACLI/Commands/MailCommand.swift","offset":1265,"limit":40}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1293,"cache_read_input_tokens":52597,"cache_creation":{"ephemeral_5m_input_tokens":1293,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"8f6dc653-d052-43c4-a49b-59d203a8b8b8"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Ckq3FFyCVc4nnT5o8zM14L","type":"tool_result","content":"  1265â†’        }\n  1266â†’    }\n  1267â†’\n  1268â†’    func run() throws {\n  1269â†’        let vault = try VaultContext.require()\n  1270â†’\n  1271â†’        // Open mail database\n  1272â†’        let mailDbPath = (vault.dataFolderPath as NSString).appendingPathComponent(\"mail.db\")\n  1273â†’        let mailDatabase = MailDatabase(databasePath: mailDbPath)\n  1274â†’        try mailDatabase.initialize()\n  1275â†’        defer { mailDatabase.close() }\n  1276â†’\n  1277â†’        // Parse the query for structured filters\n  1278â†’        var filter = mailDatabase.parseQuery(query)\n  1279â†’\n  1280â†’        // Apply --status option if provided\n  1281â†’        if let statusValue = status {\n  1282â†’            filter.mailboxStatus = MailboxStatus(rawValue: statusValue.lowercased())\n  1283â†’        }\n  1284â†’\n  1285â†’        // Use structured search if we have filters, otherwise fall back to basic FTS\n  1286â†’        let results: [MailMessage]\n  1287â†’        if filter.hasFilters || filter.hasFreeText {\n  1288â†’            results = try mailDatabase.searchMessagesWithFilters(filter, limit: limit)\n  1289â†’        } else {\n  1290â†’            // Empty query - show recent messages\n  1291â†’            results = try mailDatabase.getAllMessages(limit: limit)\n  1292â†’        }\n  1293â†’\n  1294â†’        if results.isEmpty {\n  1295â†’            printError(\"No messages found for: \\(query)\")\n  1296â†’            return\n  1297â†’        }\n  1298â†’\n  1299â†’        if json {\n  1300â†’            // Output as JSON with filter info\n  1301â†’            var output: [[String: Any]] = []\n  1302â†’            for msg in results {\n  1303â†’                let msgDict: [String: Any] = [\n  1304â†’                    \"id\": msg.id,\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"2259e661-f264-447b-bdec-5ac6509fad20","tool_use_result":{"type":"text","file":{"filePath":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEACLI/Commands/MailCommand.swift","content":"        }\n    }\n\n    func run() throws {\n        let vault = try VaultContext.require()\n\n        // Open mail database\n        let mailDbPath = (vault.dataFolderPath as NSString).appendingPathComponent(\"mail.db\")\n        let mailDatabase = MailDatabase(databasePath: mailDbPath)\n        try mailDatabase.initialize()\n        defer { mailDatabase.close() }\n\n        // Parse the query for structured filters\n        var filter = mailDatabase.parseQuery(query)\n\n        // Apply --status option if provided\n        if let statusValue = status {\n            filter.mailboxStatus = MailboxStatus(rawValue: statusValue.lowercased())\n        }\n\n        // Use structured search if we have filters, otherwise fall back to basic FTS\n        let results: [MailMessage]\n        if filter.hasFilters || filter.hasFreeText {\n            results = try mailDatabase.searchMessagesWithFilters(filter, limit: limit)\n        } else {\n            // Empty query - show recent messages\n            results = try mailDatabase.getAllMessages(limit: limit)\n        }\n\n        if results.isEmpty {\n            printError(\"No messages found for: \\(query)\")\n            return\n        }\n\n        if json {\n            // Output as JSON with filter info\n            var output: [[String: Any]] = []\n            for msg in results {\n                let msgDict: [String: Any] = [\n                    \"id\": msg.id,","numLines":40,"startLine":1265,"totalLines":3605}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Pbg7LnPfcgpkPGkMcQrHMT","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to add the check for unknown filters after parsing the query. Let me look for the `printError` function to understand how to output errors:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":965,"cache_read_input_tokens":53890,"cache_creation":{"ephemeral_5m_input_tokens":965,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"7d3f979a-b948-41c0-be2f-6a0bd39d8cc3"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Pbg7LnPfcgpkPGkMcQrHMT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018q6ELDAsVCfescbbf9spmK","name":"Grep","input":{"pattern":"func printError|printError\\(","path":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEACLI","output_mode":"content","-n":true,"head_limit":20}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":965,"cache_read_input_tokens":53890,"cache_creation":{"ephemeral_5m_input_tokens":965,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"f70af00d-656f-499a-9d70-15c7c0affcf6"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018q6ELDAsVCfescbbf9spmK","type":"tool_result","content":"Sources/SwiftEACLI/Commands/MailCommand.swift:21:private func printError(_ message: String) {\nSources/SwiftEACLI/Commands/MailCommand.swift:541:            printError(\"Last Error: \\(error)\")\nSources/SwiftEACLI/Commands/MailCommand.swift:664:            printError(\"Warning: Initial sync failed: \\(error.localizedDescription)\")\nSources/SwiftEACLI/Commands/MailCommand.swift:665:            printError(\"The daemon will retry on its first run.\")\nSources/SwiftEACLI/Commands/MailCommand.swift:739:            printError(\"Failed to load LaunchAgent: \\(errorOutput)\")\nSources/SwiftEACLI/Commands/MailCommand.swift:777:                printError(\"Warning: \\(errorOutput.trimmingCharacters(in: .whitespacesAndNewlines))\")\nSources/SwiftEACLI/Commands/MailCommand.swift:1295:            printError(\"No messages found for: \\(query)\")\nSources/SwiftEACLI/Commands/MailCommand.swift:1394:            printError(\"Message not found: \\(id)\")\nSources/SwiftEACLI/Commands/MailCommand.swift:1401:                printError(\"No .emlx path available for this message\")\nSources/SwiftEACLI/Commands/MailCommand.swift:1408:                printError(\"Raw .emlx viewing is not available for Exchange (EWS) mailboxes.\")\nSources/SwiftEACLI/Commands/MailCommand.swift:1409:                printError(\"Exchange messages are stored on the server, not as local .emlx files.\")\nSources/SwiftEACLI/Commands/MailCommand.swift:1410:                printError(\"Use 'mail show \\(id)' without --raw to view the message content.\")\nSources/SwiftEACLI/Commands/MailCommand.swift:1415:                printError(\"Could not read .emlx file: \\(emlxPath)\")\nSources/SwiftEACLI/Commands/MailCommand.swift:1549:            printError(\"Thread not found: \\(id)\")\nSources/SwiftEACLI/Commands/MailCommand.swift:1550:            printError(\"\")\nSources/SwiftEACLI/Commands/MailCommand.swift:1551:            printError(\"To find available threads, try:\")\nSources/SwiftEACLI/Commands/MailCommand.swift:1552:            printError(\"  swea mail export-threads --limit 10   # Export recent threads\")\nSources/SwiftEACLI/Commands/MailCommand.swift:1553:            printError(\"  swea mail search <query>              # Search for messages\")\nSources/SwiftEACLI/Commands/MailCommand.swift:2284:                printError(\"Message not found: \\(id)\")\nSources/SwiftEACLI/Commands/MailCommand.swift:2296:            printError(\"No messages to export\")\n\n[Showing results with pagination = limit: 20, offset: 0]"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"e2bd7af6-ef67-492a-99f0-9451ded56e83","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"Sources/SwiftEACLI/Commands/MailCommand.swift:21:private func printError(_ message: String) {\nSources/SwiftEACLI/Commands/MailCommand.swift:541:            printError(\"Last Error: \\(error)\")\nSources/SwiftEACLI/Commands/MailCommand.swift:664:            printError(\"Warning: Initial sync failed: \\(error.localizedDescription)\")\nSources/SwiftEACLI/Commands/MailCommand.swift:665:            printError(\"The daemon will retry on its first run.\")\nSources/SwiftEACLI/Commands/MailCommand.swift:739:            printError(\"Failed to load LaunchAgent: \\(errorOutput)\")\nSources/SwiftEACLI/Commands/MailCommand.swift:777:                printError(\"Warning: \\(errorOutput.trimmingCharacters(in: .whitespacesAndNewlines))\")\nSources/SwiftEACLI/Commands/MailCommand.swift:1295:            printError(\"No messages found for: \\(query)\")\nSources/SwiftEACLI/Commands/MailCommand.swift:1394:            printError(\"Message not found: \\(id)\")\nSources/SwiftEACLI/Commands/MailCommand.swift:1401:                printError(\"No .emlx path available for this message\")\nSources/SwiftEACLI/Commands/MailCommand.swift:1408:                printError(\"Raw .emlx viewing is not available for Exchange (EWS) mailboxes.\")\nSources/SwiftEACLI/Commands/MailCommand.swift:1409:                printError(\"Exchange messages are stored on the server, not as local .emlx files.\")\nSources/SwiftEACLI/Commands/MailCommand.swift:1410:                printError(\"Use 'mail show \\(id)' without --raw to view the message content.\")\nSources/SwiftEACLI/Commands/MailCommand.swift:1415:                printError(\"Could not read .emlx file: \\(emlxPath)\")\nSources/SwiftEACLI/Commands/MailCommand.swift:1549:            printError(\"Thread not found: \\(id)\")\nSources/SwiftEACLI/Commands/MailCommand.swift:1550:            printError(\"\")\nSources/SwiftEACLI/Commands/MailCommand.swift:1551:            printError(\"To find available threads, try:\")\nSources/SwiftEACLI/Commands/MailCommand.swift:1552:            printError(\"  swea mail export-threads --limit 10   # Export recent threads\")\nSources/SwiftEACLI/Commands/MailCommand.swift:1553:            printError(\"  swea mail search <query>              # Search for messages\")\nSources/SwiftEACLI/Commands/MailCommand.swift:2284:                printError(\"Message not found: \\(id)\")\nSources/SwiftEACLI/Commands/MailCommand.swift:2296:            printError(\"No messages to export\")","numLines":20,"appliedLimit":20}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Xv1Kv1pUBRtBYpJtoNJqe6","type":"message","role":"assistant","content":[{"type":"text","text":"I see the `printError` function at line 21. Now let me look at how ArgumentParser commands typically exit with error codes. Let me see how other commands handle fatal errors:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":946,"cache_read_input_tokens":54855,"cache_creation":{"ephemeral_5m_input_tokens":946,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"7bad7039-ee32-40c2-bdb4-a505135b69a9"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Xv1Kv1pUBRtBYpJtoNJqe6","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01K5LakiDyzzeogPceLbbeRM","name":"Grep","input":{"pattern":"throw|ValidationError|ExitCode","path":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEACLI/Commands/MailCommand.swift","output_mode":"content","-n":true,"head_limit":30}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":946,"cache_read_input_tokens":54855,"cache_creation":{"ephemeral_5m_input_tokens":946,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"d0a36e49-ba97-4bbf-bdf4-7b91545205be"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01K5LakiDyzzeogPceLbbeRM","type":"tool_result","content":"238:    func validate() throws {\n241:            throw MailValidationError.watchAndStopMutuallyExclusive\n247:                throw MailValidationError.invalidInterval(minimum: Self.minIntervalSeconds)\n252:    func run() throws {\n268:                throw error\n274:    private func executeSyncWithRetry() throws {\n313:            throw error\n317:    private func executeSync() throws {\n424:            throw ExitCode.failure\n432:    private func performAutoExport(mailDatabase: MailDatabase, vault: VaultContext) throws {\n467:    private func performBackwardSync(mailDatabase: MailDatabase) throws {\n497:    private func showSyncStatus(mailDatabase: MailDatabase, vault: VaultContext) throws {\n620:    private func installWatchDaemon(vault: VaultContext, verbose: Bool) throws {\n740:            throw ExitCode.failure\n752:    private func stopWatchDaemon(verbose: Bool) throws {\n795:    private func runPersistentDaemon(mailDatabase: MailDatabase, vault: VaultContext) throws {\n1253:    func validate() throws {\n1256:            throw MailValidationError.invalidLimit\n1263:                throw MailValidationError.invalidStatus(value: status)\n1268:    func run() throws {\n1384:    func run() throws {\n1395:            throw ExitCode.failure\n1402:                throw ExitCode.failure\n1411:                throw ExitCode.failure\n1416:                throw ExitCode.failure\n1538:    func run() throws {\n1554:            throw ExitCode.failure\n1886:    func run() throws {\n2235:    func validate() throws {\n2238:            throw MailValidationError.invalidLimit\n\n[Showing results with pagination = limit: 30, offset: 0]"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"6a80457f-b6bb-451f-9a3c-86f13afa0cec","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"238:    func validate() throws {\n241:            throw MailValidationError.watchAndStopMutuallyExclusive\n247:                throw MailValidationError.invalidInterval(minimum: Self.minIntervalSeconds)\n252:    func run() throws {\n268:                throw error\n274:    private func executeSyncWithRetry() throws {\n313:            throw error\n317:    private func executeSync() throws {\n424:            throw ExitCode.failure\n432:    private func performAutoExport(mailDatabase: MailDatabase, vault: VaultContext) throws {\n467:    private func performBackwardSync(mailDatabase: MailDatabase) throws {\n497:    private func showSyncStatus(mailDatabase: MailDatabase, vault: VaultContext) throws {\n620:    private func installWatchDaemon(vault: VaultContext, verbose: Bool) throws {\n740:            throw ExitCode.failure\n752:    private func stopWatchDaemon(verbose: Bool) throws {\n795:    private func runPersistentDaemon(mailDatabase: MailDatabase, vault: VaultContext) throws {\n1253:    func validate() throws {\n1256:            throw MailValidationError.invalidLimit\n1263:                throw MailValidationError.invalidStatus(value: status)\n1268:    func run() throws {\n1384:    func run() throws {\n1395:            throw ExitCode.failure\n1402:                throw ExitCode.failure\n1411:                throw ExitCode.failure\n1416:                throw ExitCode.failure\n1538:    func run() throws {\n1554:            throw ExitCode.failure\n1886:    func run() throws {\n2235:    func validate() throws {\n2238:            throw MailValidationError.invalidLimit","numLines":30,"appliedLimit":30}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018r1cAMjC1QXXiz2v58qJhV","type":"message","role":"assistant","content":[{"type":"text","text":"I see that `throw ExitCode.failure` is used for error exits. I need to add the unknown filter check and use that. Let me also look at the validation error enum:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":668,"cache_read_input_tokens":55801,"cache_creation":{"ephemeral_5m_input_tokens":668,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"a62d3678-a7f9-4512-8ea0-5d8754de312f"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018r1cAMjC1QXXiz2v58qJhV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UKqs7vtfxJ1FcMh1ukGaY2","name":"Grep","input":{"pattern":"enum MailValidationError|case invalid","path":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEACLI/Commands/MailCommand.swift","output_mode":"content","-n":true,"-C":5}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":668,"cache_read_input_tokens":55801,"cache_creation":{"ephemeral_5m_input_tokens":668,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"53703657-e4e3-4e13-9d08-7d975a4231ac"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UKqs7vtfxJ1FcMh1ukGaY2","type":"tool_result","content":"2792-}\n2793-\n2794-/ MARK: - Mail Validation Errors\n2795-\n2796-/// Error thrown when CLI input validation fails\n2797:public enum MailValidationError: Error, LocalizedError, Equatable {\n2798:    case invalidLimit\n2799-    case emptyRecipient\n2800-    case watchAndStopMutuallyExclusive\n2801:    case invalidInterval(minimum: Int)\n2802:    case invalidStatus(value: String)\n2803-\n2804-    public var errorDescription: String? {\n2805-        switch self {\n2806-        case .invalidLimit:\n2807-            return \"--limit must be a positive integer\"\n--\n2822-/// Error thrown when action validation fails\n2823-enum MailActionError: Error, LocalizedError {\n2824-    case messageNotFound(String)\n2825-    case mailboxRequired\n2826-    case confirmationRequired(action: String)\n2827:    case invalidFlagOperation\n2828:    case invalidMarkOperation\n2829-\n2830-    var errorDescription: String? {\n2831-        switch self {\n2832-        case .messageNotFound(let id):\n2833-            return \"Message not found: \\(id)\""}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"c9638ae9-e8ef-4fed-bbe2-122a9d97dc91","tool_use_result":{"mode":"content","numFiles":0,"filenames":[],"content":"2792-}\n2793-\n2794-/ MARK: - Mail Validation Errors\n2795-\n2796-/// Error thrown when CLI input validation fails\n2797:public enum MailValidationError: Error, LocalizedError, Equatable {\n2798:    case invalidLimit\n2799-    case emptyRecipient\n2800-    case watchAndStopMutuallyExclusive\n2801:    case invalidInterval(minimum: Int)\n2802:    case invalidStatus(value: String)\n2803-\n2804-    public var errorDescription: String? {\n2805-        switch self {\n2806-        case .invalidLimit:\n2807-            return \"--limit must be a positive integer\"\n--\n2822-/// Error thrown when action validation fails\n2823-enum MailActionError: Error, LocalizedError {\n2824-    case messageNotFound(String)\n2825-    case mailboxRequired\n2826-    case confirmationRequired(action: String)\n2827:    case invalidFlagOperation\n2828:    case invalidMarkOperation\n2829-\n2830-    var errorDescription: String? {\n2831-        switch self {\n2832-        case .messageNotFound(let id):\n2833-            return \"Message not found: \\(id)\"","numLines":29}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_016TZHCwawnyS5zdHKkDuytR","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HppJfqvcgxGLm8nA9f4PsH","name":"TodoWrite","input":{"todos":[{"content":"Find and analyze the mail search code","status":"completed","activeForm":"Finding and analyzing the mail search code"},{"content":"Add test for unknown filter names to verify current behavior","status":"completed","activeForm":"Adding test for unknown filter names"},{"content":"Implement validation of filter names in parseQuery","status":"completed","activeForm":"Implementing validation of filter names in parseQuery"},{"content":"Add user-friendly error message with valid filter list","status":"in_progress","activeForm":"Adding user-friendly error message with valid filter list"},{"content":"Run swift build and swift test","status":"pending","activeForm":"Running swift build and swift test"},{"content":"Commit and close the bead","status":"pending","activeForm":"Committing and closing the bead"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":530,"cache_read_input_tokens":56469,"cache_creation":{"ephemeral_5m_input_tokens":530,"ephemeral_1h_input_tokens":0},"output_tokens":257,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"b23b4e70-f71e-484d-ade8-7c33b3ac3b8b"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HppJfqvcgxGLm8nA9f4PsH","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"bdc9d8f0-eda2-40ce-9ce8-c4eb60383ab7","tool_use_result":{"oldTodos":[{"content":"Find and analyze the mail search code","status":"completed","activeForm":"Finding and analyzing the mail search code"},{"content":"Add test for unknown filter names to verify current behavior","status":"completed","activeForm":"Adding test for unknown filter names"},{"content":"Implement validation of filter names in parseQuery","status":"in_progress","activeForm":"Implementing validation of filter names in parseQuery"},{"content":"Add user-friendly error message with valid filter list","status":"pending","activeForm":"Adding user-friendly error message with valid filter list"},{"content":"Run swift build and swift test","status":"pending","activeForm":"Running swift build and swift test"},{"content":"Commit and close the bead","status":"pending","activeForm":"Committing and closing the bead"}],"newTodos":[{"content":"Find and analyze the mail search code","status":"completed","activeForm":"Finding and analyzing the mail search code"},{"content":"Add test for unknown filter names to verify current behavior","status":"completed","activeForm":"Adding test for unknown filter names"},{"content":"Implement validation of filter names in parseQuery","status":"completed","activeForm":"Implementing validation of filter names in parseQuery"},{"content":"Add user-friendly error message with valid filter list","status":"in_progress","activeForm":"Adding user-friendly error message with valid filter list"},{"content":"Run swift build and swift test","status":"pending","activeForm":"Running swift build and swift test"},{"content":"Commit and close the bead","status":"pending","activeForm":"Committing and closing the bead"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_012WSfNK8ZZiv4rw71ho3L6b","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me add the unknown filter validation case and update the search command:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":299,"cache_read_input_tokens":56999,"cache_creation":{"ephemeral_5m_input_tokens":299,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"70b9b2ac-2676-451a-94db-932449e6c634"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_012WSfNK8ZZiv4rw71ho3L6b","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01557y5nWrXhzP5yTyRo7okN","name":"Read","input":{"file_path":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEACLI/Commands/MailCommand.swift","offset":2797,"limit":30}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":299,"cache_read_input_tokens":56999,"cache_creation":{"ephemeral_5m_input_tokens":299,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"65ac94d3-6919-44f3-b14d-effd7e4c4df2"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01557y5nWrXhzP5yTyRo7okN","type":"tool_result","content":"  2797â†’public enum MailValidationError: Error, LocalizedError, Equatable {\n  2798â†’    case invalidLimit\n  2799â†’    case emptyRecipient\n  2800â†’    case watchAndStopMutuallyExclusive\n  2801â†’    case invalidInterval(minimum: Int)\n  2802â†’    case invalidStatus(value: String)\n  2803â†’\n  2804â†’    public var errorDescription: String? {\n  2805â†’        switch self {\n  2806â†’        case .invalidLimit:\n  2807â†’            return \"--limit must be a positive integer\"\n  2808â†’        case .emptyRecipient:\n  2809â†’            return \"--to requires a non-empty email address\"\n  2810â†’        case .watchAndStopMutuallyExclusive:\n  2811â†’            return \"--watch and --stop cannot be used together\"\n  2812â†’        case .invalidInterval(let minimum):\n  2813â†’            return \"--interval must be at least \\(minimum) seconds\"\n  2814â†’        case .invalidStatus(let value):\n  2815â†’            return \"Invalid status '\\(value)'. Valid options: inbox, archived, deleted\"\n  2816â†’        }\n  2817â†’    }\n  2818â†’}\n  2819â†’\n  2820â†’// MARK: - Mail Action Commands\n  2821â†’\n  2822â†’/// Error thrown when action validation fails\n  2823â†’enum MailActionError: Error, LocalizedError {\n  2824â†’    case messageNotFound(String)\n  2825â†’    case mailboxRequired\n  2826â†’    case confirmationRequired(action: String)\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"83619e69-0b2c-4714-a861-35e2d127938b","tool_use_result":{"type":"text","file":{"filePath":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEACLI/Commands/MailCommand.swift","content":"public enum MailValidationError: Error, LocalizedError, Equatable {\n    case invalidLimit\n    case emptyRecipient\n    case watchAndStopMutuallyExclusive\n    case invalidInterval(minimum: Int)\n    case invalidStatus(value: String)\n\n    public var errorDescription: String? {\n        switch self {\n        case .invalidLimit:\n            return \"--limit must be a positive integer\"\n        case .emptyRecipient:\n            return \"--to requires a non-empty email address\"\n        case .watchAndStopMutuallyExclusive:\n            return \"--watch and --stop cannot be used together\"\n        case .invalidInterval(let minimum):\n            return \"--interval must be at least \\(minimum) seconds\"\n        case .invalidStatus(let value):\n            return \"Invalid status '\\(value)'. Valid options: inbox, archived, deleted\"\n        }\n    }\n}\n\n// MARK: - Mail Action Commands\n\n/// Error thrown when action validation fails\nenum MailActionError: Error, LocalizedError {\n    case messageNotFound(String)\n    case mailboxRequired\n    case confirmationRequired(action: String)","numLines":30,"startLine":2797,"totalLines":3605}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BCzL9Q1QsbPfP9PHtQ5VQG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01C2d2UavKrHqzWriJi3KRV6","name":"Edit","input":{"replace_all":false,"file_path":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEACLI/Commands/MailCommand.swift","old_string":"public enum MailValidationError: Error, LocalizedError, Equatable {\n    case invalidLimit\n    case emptyRecipient\n    case watchAndStopMutuallyExclusive\n    case invalidInterval(minimum: Int)\n    case invalidStatus(value: String)\n\n    public var errorDescription: String? {\n        switch self {\n        case .invalidLimit:\n            return \"--limit must be a positive integer\"\n        case .emptyRecipient:\n            return \"--to requires a non-empty email address\"\n        case .watchAndStopMutuallyExclusive:\n            return \"--watch and --stop cannot be used together\"\n        case .invalidInterval(let minimum):\n            return \"--interval must be at least \\(minimum) seconds\"\n        case .invalidStatus(let value):\n            return \"Invalid status '\\(value)'. Valid options: inbox, archived, deleted\"\n        }\n    }\n}","new_string":"public enum MailValidationError: Error, LocalizedError, Equatable {\n    case invalidLimit\n    case emptyRecipient\n    case watchAndStopMutuallyExclusive\n    case invalidInterval(minimum: Int)\n    case invalidStatus(value: String)\n    case unknownFilter(names: [String], validFilters: [String])\n\n    public var errorDescription: String? {\n        switch self {\n        case .invalidLimit:\n            return \"--limit must be a positive integer\"\n        case .emptyRecipient:\n            return \"--to requires a non-empty email address\"\n        case .watchAndStopMutuallyExclusive:\n            return \"--watch and --stop cannot be used together\"\n        case .invalidInterval(let minimum):\n            return \"--interval must be at least \\(minimum) seconds\"\n        case .invalidStatus(let value):\n            return \"Invalid status '\\(value)'. Valid options: inbox, archived, deleted\"\n        case .unknownFilter(let names, let validFilters):\n            let unknownList = names.map { \"'\\($0)'\" }.joined(separator: \", \")\n            let validList = validFilters.joined(separator: \", \")\n            if names.count == 1 {\n                return \"Unknown filter \\(unknownList). Valid filters: \\(validList)\"\n            } else {\n                return \"Unknown filters \\(unknownList). Valid filters: \\(validList)\"\n            }\n        }\n    }\n}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":627,"cache_read_input_tokens":57298,"cache_creation":{"ephemeral_5m_input_tokens":627,"ephemeral_1h_input_tokens":0},"output_tokens":705,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"e7c90d09-7aa0-45d6-b0e9-cff792b9d6e3"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01C2d2UavKrHqzWriJi3KRV6","type":"tool_result","content":"The file /Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEACLI/Commands/MailCommand.swift has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  2793â†’\n  2794â†’// MARK: - Mail Validation Errors\n  2795â†’\n  2796â†’/// Error thrown when CLI input validation fails\n  2797â†’public enum MailValidationError: Error, LocalizedError, Equatable {\n  2798â†’    case invalidLimit\n  2799â†’    case emptyRecipient\n  2800â†’    case watchAndStopMutuallyExclusive\n  2801â†’    case invalidInterval(minimum: Int)\n  2802â†’    case invalidStatus(value: String)\n  2803â†’    case unknownFilter(names: [String], validFilters: [String])\n  2804â†’\n  2805â†’    public var errorDescription: String? {\n  2806â†’        switch self {\n  2807â†’        case .invalidLimit:\n  2808â†’            return \"--limit must be a positive integer\"\n  2809â†’        case .emptyRecipient:\n  2810â†’            return \"--to requires a non-empty email address\"\n  2811â†’        case .watchAndStopMutuallyExclusive:\n  2812â†’            return \"--watch and --stop cannot be used together\"\n  2813â†’        case .invalidInterval(let minimum):\n  2814â†’            return \"--interval must be at least \\(minimum) seconds\"\n  2815â†’        case .invalidStatus(let value):\n  2816â†’            return \"Invalid status '\\(value)'. Valid options: inbox, archived, deleted\"\n  2817â†’        case .unknownFilter(let names, let validFilters):\n  2818â†’            let unknownList = names.map { \"'\\($0)'\" }.joined(separator: \", \")\n  2819â†’            let validList = validFilters.joined(separator: \", \")\n  2820â†’            if names.count == 1 {\n  2821â†’                return \"Unknown filter \\(unknownList). Valid filters: \\(validList)\"\n  2822â†’            } else {\n  2823â†’                return \"Unknown filters \\(unknownList). Valid filters: \\(validList)\"\n  2824â†’            }\n  2825â†’        }\n  2826â†’    }\n  2827â†’}\n  2828â†’\n  2829â†’// MARK: - Mail Action Commands\n  2830â†’\n  2831â†’/// Error thrown when action validation fails"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"b414547e-8c96-40d7-9409-10ad14388ce9","tool_use_result":{"filePath":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEACLI/Commands/MailCommand.swift","oldString":"public enum MailValidationError: Error, LocalizedError, Equatable {\n    case invalidLimit\n    case emptyRecipient\n    case watchAndStopMutuallyExclusive\n    case invalidInterval(minimum: Int)\n    case invalidStatus(value: String)\n\n    public var errorDescription: String? {\n        switch self {\n        case .invalidLimit:\n            return \"--limit must be a positive integer\"\n        case .emptyRecipient:\n            return \"--to requires a non-empty email address\"\n        case .watchAndStopMutuallyExclusive:\n            return \"--watch and --stop cannot be used together\"\n        case .invalidInterval(let minimum):\n            return \"--interval must be at least \\(minimum) seconds\"\n        case .invalidStatus(let value):\n            return \"Invalid status '\\(value)'. Valid options: inbox, archived, deleted\"\n        }\n    }\n}","newString":"public enum MailValidationError: Error, LocalizedError, Equatable {\n    case invalidLimit\n    case emptyRecipient\n    case watchAndStopMutuallyExclusive\n    case invalidInterval(minimum: Int)\n    case invalidStatus(value: String)\n    case unknownFilter(names: [String], validFilters: [String])\n\n    public var errorDescription: String? {\n        switch self {\n        case .invalidLimit:\n            return \"--limit must be a positive integer\"\n        case .emptyRecipient:\n            return \"--to requires a non-empty email address\"\n        case .watchAndStopMutuallyExclusive:\n            return \"--watch and --stop cannot be used together\"\n        case .invalidInterval(let minimum):\n            return \"--interval must be at least \\(minimum) seconds\"\n        case .invalidStatus(let value):\n            return \"Invalid status '\\(value)'. Valid options: inbox, archived, deleted\"\n        case .unknownFilter(let names, let validFilters):\n            let unknownList = names.map { \"'\\($0)'\" }.joined(separator: \", \")\n            let validList = validFilters.joined(separator: \", \")\n            if names.count == 1 {\n                return \"Unknown filter \\(unknownList). Valid filters: \\(validList)\"\n            } else {\n                return \"Unknown filters \\(unknownList). Valid filters: \\(validList)\"\n            }\n        }\n    }\n}","originalFile":"import AppKit\nimport ArgumentParser\nimport Foundation\nimport SwiftEAKit\n\n\n// MARK: - Date Extension for ISO 8601 formatting\n\nextension Date {\n    var iso8601String: String {\n        let formatter = ISO8601DateFormatter()\n        formatter.formatOptions = [.withInternetDateTime]\n        return formatter.string(from: self)\n    }\n}\n\n// MARK: - Standard Error Output Helper\n\n/// Write a message to stderr for error/warning output.\n/// This ensures errors dont corrupt stdout when piping (e.g., JSON output to jq).\nprivate func printError(_ message: String) {\n    fputs(\"\\(message)\\n\", stderr)\n}\n\npublic struct Mail: ParsableCommand {\n    public static let configuration = CommandConfiguration(\n        commandName: \"mail\",\n        abstract: \"Mail operations (sync, search, show, export, actions)\",\n        discussion: \"\"\"\n            swea mail commands interact with Apple Mail.app to sync, search,\n            and perform actions on your email.\n\n            GETTING STARTED\n            The typical workflow is: sync -> search/show -> export\n\n              swea mail sync              # Sync mail to local database\n              swea mail sync --watch      # Start automatic background sync\n              swea mail search \"query\"    # Search synced messages\n              swea mail export            # Export to markdown files\n\n            QUICK WORKFLOW\n              # First time: sync all mail\n              swea mail sync\n\n              # For ongoing use: start automatic sync\n              swea mail sync --watch\n\n              # Search and export as needed\n              swea mail search \"from:alice@example.com\"\n              swea mail export --query \"from:alice\"\n\n            NOTE: 'sync' populates the database. 'export' creates .md files.\n            Run both if you want files you can open in Obsidian.\n\n            AUTOMATION PERMISSION\n            Action commands (archive, delete, move, flag, mark, reply, compose)\n            require macOS Automation permission for Mail.app. On first run, macOS\n            will prompt you to grant permission. To grant permission manually:\n\n              1. Open System Settings > Privacy & Security > Automation\n              2. Find swea (or Terminal if running from terminal)\n              3. Enable the toggle for Mail.app\n\n            SAFETY FLAGS\n            Destructive actions (archive, delete, move) require explicit confirmation:\n\n              --dry-run    Preview what would happen without making changes\n              --yes        Confirm the action and execute it\n\n            Running a destructive action without --yes or --dry-run will show an\n            error explaining the requirement.\n\n            EXAMPLES\n              # Sync mail from Apple Mail\n              swea mail sync\n\n              # Start automatic sync (recommended for regular use)\n              swea mail sync --watch\n\n              # Force a full resync if needed\n              swea mail sync --full\n\n              # Search for emails from a specific sender\n              swea mail search \"from:alice@example.com\"\n\n              # Export all mail to markdown files\n              swea mail export\n\n              # Export filtered mail to custom location\n              swea mail export --query \"from:alice\" --output ~/Documents/Mail\n\n              # Preview archiving a message (no changes made)\n              swea mail archive --id mail-abc123 --dry-run\n\n              # Archive a message (requires confirmation)\n              swea mail archive --id mail-abc123 --yes\n\n              # Flag a message\n              swea mail flag --id mail-abc123 --set\n\n              # Compose a new email draft\n              swea mail compose --to bob@example.com --subject \"Hello\"\n            \"\"\",\n        subcommands: [\n            MailSyncCommand.self,\n            MailSearchCommand.self,\n            MailShowCommand.self,\n            MailThreadCommand.self,\n            MailThreadsCommand.self,\n            MailExportCommand.self,\n            MailExportThreadsCommand.self,\n            // Action commands\n            MailArchiveCommand.self,\n            MailDeleteCommand.self,\n            MailMoveCommand.self,\n            MailFlagCommand.self,\n            MailMarkCommand.self,\n            MailReplyCommand.self,\n            MailComposeCommand.self,\n            // Database maintenance\n            MailMigrateCommand.self\n        ]\n    )\n\n    public init() {}\n}\n\nstruct MailSyncCommand: ParsableCommand {\n    static let configuration = CommandConfiguration(\n        commandName: \"sync\",\n        abstract: \"Sync mail data from Apple Mail and export to Swiftea/Mail/\",\n        discussion: \"\"\"\n            Syncs mail data from Apple Mail to a local SQLite database for fast\n            searching. By default, performs an incremental sync (only new/changed\n            messages). Use --full to resync everything.\n\n            After sync, new messages are automatically exported as markdown files\n            to Swiftea/Mail/ for use with Obsidian or other markdown tools.\n            Use --no-export to disable automatic export.\n\n            For automatic sync, use --watch to start a background daemon that\n            keeps your mail database and markdown exports up to date.\n\n            EXAMPLES\n              swea mail sync              # Incremental sync + auto-export\n              swea mail sync --full       # Full resync + export all\n              swea mail sync --no-export  # Sync only, skip markdown export\n              swea mail sync --watch      # Start automatic sync daemon\n              swea mail sync --status     # Check sync/daemon status\n              swea mail sync --stop       # Stop the daemon\n            \"\"\"\n    )\n\n    @Flag(name: .long, help: \"Install and start watch daemon for continuous sync\")\n    var watch: Bool = false\n\n    @Flag(name: .long, help: \"Stop the watch daemon\")\n    var stop: Bool = false\n\n    @Flag(name: .long, help: \"Show sync status and watch daemon state\")\n    var status: Bool = false\n\n    @Flag(name: .long, help: \"Force a full sync, ignoring previous sync state\")\n    var full: Bool = false\n\n    @Flag(name: .long, help: \"Show detailed progress\")\n    var verbose: Bool = false\n\n    @Flag(name: .long, help: \"Run as persistent daemon with sleep/wake detection (internal use)\")\n    var daemon: Bool = false\n\n    @Flag(name: .long, help: \"Disable automatic export to Swiftea/Mail/ after sync\")\n    var noExport: Bool = false\n\n    @Option(name: .long, help: \"Sync interval in seconds for watch mode (default: 300, minimum: 30)\")\n    var interval: Int?\n\n    // MARK: - Retry Configuration (for daemon mode)\n\n    /// Maximum number of retry attempts for transient errors\n    private static let maxRetryAttempts = 5\n\n    /// Base delay in seconds for exponential backoff\n    private static let baseRetryDelay: TimeInterval = 2.0\n\n    /// Maximum delay in seconds between retries\n    private static let maxRetryDelay: TimeInterval = 60.0\n\n    /// Errors that are considered transient and worth retrying\n    private func isTransientError(_ error: Error) -> Bool {\n        let description = error.localizedDescription.lowercased()\n        // Database lock errors, network timeouts, permission issues that may be temporary\n        return description.contains(\"locked\") ||\n               description.contains(\"busy\") ||\n               description.contains(\"timeout\") ||\n               description.contains(\"temporarily\") ||\n               description.contains(\"try again\")\n    }\n\n    // MARK: - Daemon-safe Logging\n\n    /// Detect if running as a LaunchAgent daemon (no TTY attached)\n    private var isDaemonMode: Bool {\n        // When run by launchd, there's no TTY and stdout is not interactive\n        // isatty() returns non-zero if stdout is connected to a terminal, 0 otherwise\n        return isatty(STDOUT_FILENO) == 0\n    }\n\n    /// Log a message with optional timestamp prefix for daemon mode.\n    /// Ensures output is flushed immediately so logs are captured.\n    private func log(_ message: String) {\n        if isDaemonMode {\n            let timestamp = ISO8601DateFormatter().string(from: Date())\n            fputs(\"[\\(timestamp)] \\(message)\\n\", stdout)\n            fflush(stdout)\n        } else {\n            print(message)\n        }\n    }\n\n    /// Log an error message to stderr, ensuring it's flushed for daemon mode.\n    private func logError(_ message: String) {\n        if isDaemonMode {\n            let timestamp = ISO8601DateFormatter().string(from: Date())\n            fputs(\"[\\(timestamp)] ERROR: \\(message)\\n\", stderr)\n            fflush(stderr)\n        } else {\n            fputs(\"Error: \\(message)\\n\", stderr)\n        }\n    }\n\n    /// Minimum allowed sync interval in seconds\n    private static let minIntervalSeconds = 30\n\n    /// Default sync interval in seconds (1 minute)\n    private static let defaultIntervalSeconds = 60\n\n    func validate() throws {\n        // --watch and --stop are mutually exclusive\n        if watch && stop {\n            throw MailValidationError.watchAndStopMutuallyExclusive\n        }\n\n        // Validate --interval if provided\n        if let interval = interval {\n            if interval < Self.minIntervalSeconds {\n                throw MailValidationError.invalidInterval(minimum: Self.minIntervalSeconds)\n            }\n        }\n    }\n\n    func run() throws {\n        // Log startup for daemon mode debugging\n        if isDaemonMode {\n            log(\"mail sync started (daemon mode, pid=\\(ProcessInfo.processInfo.processIdentifier))\")\n            log(\"working directory: \\(FileManager.default.currentDirectoryPath)\")\n        }\n\n        // In daemon mode, use retry with exponential backoff for transient errors\n        if isDaemonMode {\n            try executeSyncWithRetry()\n        } else {\n            // Interactive mode: no retry, immediate failure feedback\n            do {\n                try executeSync()\n            } catch {\n                logError(\"\\(error.localizedDescription)\")\n                throw error\n            }\n        }\n    }\n\n    /// Execute sync with exponential backoff retry for transient errors (daemon mode)\n    private func executeSyncWithRetry() throws {\n        var lastError: Error?\n        var attempt = 0\n\n        while attempt < Self.maxRetryAttempts {\n            do {\n                try executeSync()\n                log(\"mail sync completed successfully\")\n                return\n            } catch {\n                lastError = error\n                attempt += 1\n\n                // Check if error is transient and worth retrying\n                if isTransientError(error) && attempt < Self.maxRetryAttempts {\n                    // Calculate exponential backoff delay with jitter\n                    let delay = min(\n                        Self.baseRetryDelay * pow(2.0, Double(attempt - 1)),\n                        Self.maxRetryDelay\n                    )\n                    // Add 10-20% random jitter to prevent thundering herd\n                    let jitter = delay * Double.random(in: 0.1...0.2)\n                    let totalDelay = delay + jitter\n\n                    log(\"Transient error (attempt \\(attempt)/\\(Self.maxRetryAttempts)): \\(error.localizedDescription)\")\n                    log(\"Retrying in \\(String(format: \"%.1f\", totalDelay)) seconds...\")\n\n                    Thread.sleep(forTimeInterval: totalDelay)\n                } else {\n                    // Non-transient error or max retries reached\n                    break\n                }\n            }\n        }\n\n        // All retries exhausted or non-transient error\n        if let error = lastError {\n            logError(\"Sync failed after \\(attempt) attempt(s): \\(error.localizedDescription)\")\n            log(\"mail sync failed\")\n            throw error\n        }\n    }\n\n    private func executeSync() throws {\n        let vault = try VaultContext.require()\n\n        // Create mail database in vault's data folder\n        let mailDbPath = (vault.dataFolderPath as NSString).appendingPathComponent(\"mail.db\")\n        let mailDatabase = MailDatabase(databasePath: mailDbPath)\n        try mailDatabase.initialize()\n        defer { mailDatabase.close() }\n\n        if verbose || isDaemonMode {\n            log(\"Mail database: \\(mailDbPath)\")\n        }\n\n        // Handle --status flag\n        if status {\n            try showSyncStatus(mailDatabase: mailDatabase, vault: vault)\n            return\n        }\n\n        // Handle --watch flag\n        if watch {\n            try installWatchDaemon(vault: vault, verbose: verbose)\n            return\n        }\n\n        // Handle --stop flag\n        if stop {\n            try stopWatchDaemon(verbose: verbose)\n            return\n        }\n\n        // Handle --daemon flag: run as persistent daemon with sleep/wake detection\n        if daemon {\n            try runPersistentDaemon(mailDatabase: mailDatabase, vault: vault)\n            return\n        }\n\n        // Create sync engine\n        let sync = MailSync(mailDatabase: mailDatabase)\n\n        // Wire up progress callback for verbose mode\n        if verbose {\n            var lastPhase: String = \"\"\n            var lastProgressTime = Date()\n            sync.onProgress = { progress in\n                // Always show phase changes\n                if progress.phase.rawValue != lastPhase {\n                    if !lastPhase.isEmpty {\n                        print(\"\") // newline after previous phase\n                    }\n                    lastPhase = progress.phase.rawValue\n                    lastProgressTime = Date()\n                }\n\n                // For message sync, show periodic updates (every 0.5s or phase change)\n                let now = Date()\n                let elapsed = now.timeIntervalSince(lastProgressTime)\n                if elapsed >= 0.5 || progress.current == progress.total {\n                    lastProgressTime = now\n                    if progress.total > 0 {\n                        let pct = Int(progress.percentage)\n                        // Use carriage return to update in place\n                        print(\"\\r  [\\(progress.phase.rawValue)] \\(progress.current)/\\(progress.total) (\\(pct)%) - \\(progress.message)\", terminator: \"\")\n                        fflush(stdout)\n                    } else {\n                        print(\"\\r  [\\(progress.phase.rawValue)] \\(progress.message)\", terminator: \"\")\n                        fflush(stdout)\n                    }\n                }\n            }\n        }\n\n        log(\"Syncing mail from Apple Mail...\")\n\n        do {\n            let result = try sync.sync(forceFullSync: full)\n\n            if verbose {\n                print(\"\") // Final newline after progress\n            }\n\n            log(\"Sync complete:\")\n            log(\"  Messages processed: \\(result.messagesProcessed)\")\n            log(\"  Messages added: \\(result.messagesAdded)\")\n            log(\"  Messages updated: \\(result.messagesUpdated)\")\n            log(\"  Mailboxes: \\(result.mailboxesProcessed)\")\n            log(\"  Duration: \\(String(format: \"%.2f\", result.duration))s\")\n\n            if !result.errors.isEmpty {\n                log(\"\\nWarnings/Errors:\")\n                for error in result.errors.prefix(10) {\n                    log(\"  - \\(error)\")\n                }\n                if result.errors.count > 10 {\n                    log(\"  ... and \\(result.errors.count - 10) more\")\n                }\n            }\n\n            // Auto-export new messages to Swiftea/Mail/ unless disabled\n            if !noExport {\n                try performAutoExport(mailDatabase: mailDatabase, vault: vault)\n            }\n\n            // Process pending backward sync actions (archive/delete from SwiftEA to Apple Mail)\n            try performBackwardSync(mailDatabase: mailDatabase)\n        } catch let error as MailSyncError {\n            logError(\"Sync failed: \\(error.localizedDescription)\")\n            throw ExitCode.failure\n        }\n    }\n\n    // MARK: - Auto-Export\n\n    /// Export newly synced messages to Swiftea/Mail/ as markdown files\n    /// Messages are grouped by conversation/thread for better organization.\n    private func performAutoExport(mailDatabase: MailDatabase, vault: VaultContext) throws {\n        let exportDir = (vault.dataFolderPath as NSString).appendingPathComponent(\"Mail\")\n        let exporter = MailExporter(mailDatabase: mailDatabase)\n\n        do {\n            let exportResult = try exporter.exportNewMessages(to: exportDir)\n\n            if exportResult.exported > 0 {\n                log(\"Auto-export:\")\n                log(\"  Exported \\(exportResult.exported) message(s) to Swiftea/Mail/\")\n                if exportResult.threadsExported > 0 {\n                    log(\"  Threads updated: \\(exportResult.threadsExported) (in threads/)\")\n                }\n                if exportResult.unthreadedExported > 0 {\n                    log(\"  Unthreaded: \\(exportResult.unthreadedExported) (in unthreaded/)\")\n                }\n            }\n\n            if !exportResult.errors.isEmpty && verbose {\n                for error in exportResult.errors.prefix(5) {\n                    log(\"  Warning: \\(error)\")\n                }\n                if exportResult.errors.count > 5 {\n                    log(\"  ... and \\(exportResult.errors.count - 5) more export errors\")\n                }\n            }\n        } catch {\n            // Log but don't fail sync if export has issues\n            logError(\"Auto-export failed: \\(error.localizedDescription)\")\n        }\n    }\n\n    // MARK: - Backward Sync\n\n    /// Process pending backward sync actions (archive/delete from SwiftEA to Apple Mail)\n    private func performBackwardSync(mailDatabase: MailDatabase) throws {\n        let backwardSync = MailSyncBackward(mailDatabase: mailDatabase)\n\n        do {\n            let result = try backwardSync.processPendingActions()\n\n            // Log results if any actions were processed\n            if result.archived > 0 || result.deleted > 0 {\n                log(\"Backward sync:\")\n                log(\"  Archived: \\(result.archived), Deleted: \\(result.deleted)\")\n            }\n\n            // Log warnings for failed actions\n            if result.failed > 0 {\n                logError(\"Backward sync failed for \\(result.failed) message(s)\")\n                for error in result.errors.prefix(5) {\n                    logError(\"  - \\(error)\")\n                }\n                if result.errors.count > 5 {\n                    logError(\"  ... and \\(result.errors.count - 5) more errors\")\n                }\n            }\n        } catch {\n            // Log but don't fail sync if backward sync has issues\n            logError(\"Backward sync failed: \\(error.localizedDescription)\")\n        }\n    }\n\n    // MARK: - Status\n\n    private func showSyncStatus(mailDatabase: MailDatabase, vault: VaultContext) throws {\n        let summary = try mailDatabase.getSyncStatusSummary()\n        let daemonStatus = getDaemonStatus()\n\n        print(\"Mail Sync Status\")\n        print(\"================\")\n        print(\"\")\n\n        // Daemon status\n        print(\"Watch Daemon: \\(daemonStatus.isRunning ? \"running\" : \"stopped\")\")\n        if let pid = daemonStatus.pid {\n            print(\"  PID: \\(pid)\")\n        }\n        print(\"\")\n\n        // Sync state\n        print(\"Last Sync:\")\n        print(\"  State: \\(summary.state.rawValue)\")\n\n        if let lastSync = summary.lastSyncTime {\n            let formatter = DateFormatter()\n            formatter.dateStyle = .medium\n            formatter.timeStyle = .medium\n            print(\"  Time: \\(formatter.string(from: lastSync))\")\n        } else {\n            print(\"  Time: Never\")\n        }\n\n        if let duration = summary.duration {\n            print(\"  Duration: \\(String(format: \"%.2f\", duration))s\")\n        }\n\n        if let isIncremental = summary.isIncremental {\n            print(\"  Type: \\(isIncremental ? \"incremental\" : \"full\")\")\n        }\n\n        // Message counts\n        if summary.messagesAdded > 0 || summary.messagesUpdated > 0 || summary.messagesDeleted > 0 {\n            print(\"  Messages: +\\(summary.messagesAdded) ~\\(summary.messagesUpdated) -\\(summary.messagesDeleted)\")\n        }\n\n        // Error if any\n        if let error = summary.lastSyncError {\n            print(\"\")\n            printError(\"Last Error: \\(error)\")\n        }\n\n        // Database location\n        print(\"\")\n        print(\"Database: \\(vault.dataFolderPath)/mail.db\")\n    }\n\n    private struct DaemonStatus {\n        let isRunning: Bool\n        let pid: Int?\n    }\n\n    private func getDaemonStatus() -> DaemonStatus {\n        // Use `launchctl list` (all services) to get tab-separated format\n        // Note: `launchctl list SERVICE_NAME` returns dictionary format, not tabular\n        let process = Process()\n        process.executableURL = URL(fileURLWithPath: \"/bin/launchctl\")\n        process.arguments = [\"list\"]\n\n        let pipe = Pipe()\n        process.standardOutput = pipe\n        process.standardError = FileHandle.nullDevice\n\n        do {\n            try process.run()\n            process.waitUntilExit()\n\n            if process.terminationStatus == 0 {\n                let data = pipe.fileHandleForReading.readDataToEndOfFile()\n                if let output = String(data: data, encoding: .utf8) {\n                    // Find the line containing our service label\n                    // Format: \"PID\\tStatus\\tLabel\" where PID is \"-\" if not running\n                    for line in output.split(separator: \"\\n\") {\n                        if line.contains(\"com.swiftea.mail.sync\") {\n                            let components = line.split(separator: \"\\t\")\n                            if components.count >= 3 {\n                                let pidStr = String(components[0])\n                                if pidStr != \"-\", let pid = Int(pidStr), pid > 0 {\n                                    return DaemonStatus(isRunning: true, pid: pid)\n                                }\n                                // Job exists but not running (PID is \"-\")\n                                return DaemonStatus(isRunning: false, pid: nil)\n                            }\n                        }\n                    }\n                }\n            }\n        } catch {\n            // launchctl failed, daemon not loaded\n        }\n\n        return DaemonStatus(isRunning: false, pid: nil)\n    }\n\n    // MARK: - Watch Daemon\n\n    private static let launchAgentLabel = \"com.swiftea.mail.sync\"\n\n    /// Get the effective sync interval (user-specified or default)\n    private var effectiveSyncInterval: Int {\n        interval ?? Self.defaultIntervalSeconds\n    }\n\n    private func getLaunchAgentPath() -> String {\n        let homeDir = FileManager.default.homeDirectoryForCurrentUser.path\n        return \"\\(homeDir)/Library/LaunchAgents/\\(Self.launchAgentLabel).plist\"\n    }\n\n    /// Format interval for human-readable output\n    private func formatInterval(_ seconds: Int) -> String {\n        if seconds >= 60 && seconds % 60 == 0 {\n            let minutes = seconds / 60\n            return \"\\(minutes) minute\\(minutes == 1 ? \"\" : \"s\")\"\n        } else {\n            return \"\\(seconds) seconds\"\n        }\n    }\n\n    private func installWatchDaemon(vault: VaultContext, verbose: Bool) throws {\n        let launchAgentPath = getLaunchAgentPath()\n        let executablePath = ProcessInfo.processInfo.arguments[0]\n\n        // Resolve to absolute path if needed\n        let absoluteExecutablePath: String\n        if executablePath.hasPrefix(\"/\") {\n            absoluteExecutablePath = executablePath\n        } else {\n            let currentDir = FileManager.default.currentDirectoryPath\n            absoluteExecutablePath = (currentDir as NSString).appendingPathComponent(executablePath)\n        }\n\n        // Create LaunchAgents directory if needed\n        let launchAgentsDir = (getLaunchAgentPath() as NSString).deletingLastPathComponent\n        if !FileManager.default.fileExists(atPath: launchAgentsDir) {\n            try FileManager.default.createDirectory(atPath: launchAgentsDir, withIntermediateDirectories: true)\n        }\n\n        // Create log directory\n        let logDir = \"\\(vault.dataFolderPath)/logs\"\n        if !FileManager.default.fileExists(atPath: logDir) {\n            try FileManager.default.createDirectory(atPath: logDir, withIntermediateDirectories: true)\n        }\n\n        // Run initial sync before starting watch daemon (swiftea-7im.12)\n        // This ensures the database is populated before the daemon starts incremental syncs\n        print(\"Running initial sync before starting watch daemon...\")\n        let mailDbPath = (vault.dataFolderPath as NSString).appendingPathComponent(\"mail.db\")\n        let mailDatabase = MailDatabase(databasePath: mailDbPath)\n        try mailDatabase.initialize()\n\n        // Sync will auto-detect incremental mode based on last_sync_time in database\n        let sync = MailSync(mailDatabase: mailDatabase)\n\n        do {\n            let result = try sync.sync()\n            print(\"Initial sync complete:\")\n            print(\"  Messages: +\\(result.messagesAdded) ~\\(result.messagesUpdated)\")\n            print(\"  Duration: \\(String(format: \"%.2f\", result.duration))s\")\n            if !result.errors.isEmpty {\n                print(\"  Warnings: \\(result.errors.count)\")\n            }\n        } catch {\n            printError(\"Warning: Initial sync failed: \\(error.localizedDescription)\")\n            printError(\"The daemon will retry on its first run.\")\n        }\n\n        mailDatabase.close()\n\n        // Generate plist content\n        // Uses --daemon mode for a persistent process with sleep/wake detection.\n        // KeepAlive ensures the daemon is restarted if it exits.\n        let syncInterval = effectiveSyncInterval\n        let plist = \"\"\"\n            <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n            <!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n            <plist version=\"1.0\">\n            <dict>\n                <key>Label</key>\n                <string>\\(Self.launchAgentLabel)</string>\n                <key>ProgramArguments</key>\n                <array>\n                    <string>\\(absoluteExecutablePath)</string>\n                    <string>mail</string>\n                    <string>sync</string>\n                    <string>--daemon</string>\n                    <string>--interval</string>\n                    <string>\\(syncInterval)</string>\n                </array>\n                <key>RunAtLoad</key>\n                <true/>\n                <key>KeepAlive</key>\n                <true/>\n                <key>StandardOutPath</key>\n                <string>\\(logDir)/mail-sync.log</string>\n                <key>StandardErrorPath</key>\n                <string>\\(logDir)/mail-sync.log</string>\n                <key>WorkingDirectory</key>\n                <string>\\(vault.rootPath)</string>\n                <key>EnvironmentVariables</key>\n                <dict>\n                    <key>PATH</key>\n                    <string>/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin</string>\n                </dict>\n            </dict>\n            </plist>\n            \"\"\"\n\n        // Write plist file\n        try plist.write(toFile: launchAgentPath, atomically: true, encoding: .utf8)\n\n        if verbose {\n            print(\"Created LaunchAgent: \\(launchAgentPath)\")\n        }\n\n        // Unload if already loaded (ignore errors)\n        let unloadProcess = Process()\n        unloadProcess.executableURL = URL(fileURLWithPath: \"/bin/launchctl\")\n        unloadProcess.arguments = [\"unload\", launchAgentPath]\n        unloadProcess.standardOutput = FileHandle.nullDevice\n        unloadProcess.standardError = FileHandle.nullDevice\n        try? unloadProcess.run()\n        unloadProcess.waitUntilExit()\n\n        // Load the LaunchAgent\n        let loadProcess = Process()\n        loadProcess.executableURL = URL(fileURLWithPath: \"/bin/launchctl\")\n        loadProcess.arguments = [\"load\", launchAgentPath]\n\n        let errorPipe = Pipe()\n        loadProcess.standardError = errorPipe\n\n        try loadProcess.run()\n        loadProcess.waitUntilExit()\n\n        if loadProcess.terminationStatus != 0 {\n            let errorData = errorPipe.fileHandleForReading.readDataToEndOfFile()\n            let errorOutput = String(data: errorData, encoding: .utf8) ?? \"Unknown error\"\n            printError(\"Failed to load LaunchAgent: \\(errorOutput)\")\n            throw ExitCode.failure\n        }\n\n        print(\"Watch daemon installed and started\")\n        print(\"  Mode: Persistent daemon with sleep/wake detection\")\n        print(\"  Interval: \\(formatInterval(syncInterval))\")\n        print(\"  Logs: \\(logDir)/mail-sync.log\")\n        print(\"\")\n        print(\"Use 'swea mail sync --status' to check status\")\n        print(\"Use 'swea mail sync --stop' to stop the daemon\")\n    }\n\n    private func stopWatchDaemon(verbose: Bool) throws {\n        let launchAgentPath = getLaunchAgentPath()\n\n        // Check if plist exists\n        guard FileManager.default.fileExists(atPath: launchAgentPath) else {\n            print(\"Watch daemon is not installed\")\n            return\n        }\n\n        // Unload the LaunchAgent\n        let process = Process()\n        process.executableURL = URL(fileURLWithPath: \"/bin/launchctl\")\n        process.arguments = [\"unload\", launchAgentPath]\n\n        let errorPipe = Pipe()\n        process.standardError = errorPipe\n\n        try process.run()\n        process.waitUntilExit()\n\n        if process.terminationStatus != 0 {\n            let errorData = errorPipe.fileHandleForReading.readDataToEndOfFile()\n            let errorOutput = String(data: errorData, encoding: .utf8) ?? \"Unknown error\"\n            // Check if it was already unloaded\n            if !errorOutput.contains(\"Could not find specified service\") {\n                printError(\"Warning: \\(errorOutput.trimmingCharacters(in: .whitespacesAndNewlines))\")\n            }\n        }\n\n        // Remove the plist file\n        try? FileManager.default.removeItem(atPath: launchAgentPath)\n\n        if verbose {\n            print(\"Removed LaunchAgent: \\(launchAgentPath)\")\n        }\n\n        print(\"Watch daemon stopped and uninstalled\")\n    }\n\n    // MARK: - Persistent Daemon with Sleep/Wake Detection\n\n    /// Run as a persistent daemon that syncs on startup, on a schedule, and on system wake.\n    /// This mode is used internally by the LaunchAgent for sleep/wake-aware syncing.\n    private func runPersistentDaemon(mailDatabase: MailDatabase, vault: VaultContext) throws {\n        let syncInterval = effectiveSyncInterval\n        let exportDir = (vault.dataFolderPath as NSString).appendingPathComponent(\"Mail\")\n\n        log(\"Starting persistent mail sync daemon (pid=\\(ProcessInfo.processInfo.processIdentifier))\")\n        log(\"Sync interval: \\(formatInterval(syncInterval))\")\n        log(\"Export directory: \\(exportDir)\")\n\n        // Run initial incremental sync on startup\n        log(\"Running initial sync...\")\n        performDaemonSync(mailDatabase: mailDatabase, exportDir: exportDir)\n\n        // Create a daemon controller to handle sleep/wake events\n        let controller = MailSyncDaemonController(\n            mailDatabase: mailDatabase,\n            exportDir: exportDir,\n            syncIntervalSeconds: TimeInterval(syncInterval),\n            logger: log\n        )\n\n        // Start the run loop - this blocks until the daemon is terminated\n        controller.startRunLoop()\n\n        log(\"Daemon shutting down\")\n    }\n}\n\n// MARK: - Mail Sync Daemon Controller\n\n/// Controls the mail sync daemon with sleep/wake detection.\n/// Uses NSWorkspace notifications to detect system wake and trigger incremental sync.\nfinal class MailSyncDaemonController: NSObject {\n    private let mailDatabase: MailDatabase\n    private let exportDir: String\n    private let logger: (String) -> Void\n    private var isSyncing = false\n    private let syncQueue = DispatchQueue(label: \"com.swiftea.mail.sync.daemon\")\n    private var syncTimer: Timer?\n    private let backwardSync: MailSyncBackward\n\n    /// Interval between scheduled syncs (configurable, default 1 minute)\n    private let syncIntervalSeconds: TimeInterval\n\n    /// Minimum interval between syncs to prevent rapid-fire syncing\n    private static let minSyncIntervalSeconds: TimeInterval = 30\n\n    /// Track last sync time to debounce wake events\n    private var lastSyncTime: Date?\n\n    init(mailDatabase: MailDatabase, exportDir: String, syncIntervalSeconds: TimeInterval = 60, logger: @escaping (String) -> Void) {\n        self.mailDatabase = mailDatabase\n        self.exportDir = exportDir\n        self.syncIntervalSeconds = syncIntervalSeconds\n        self.logger = logger\n        self.backwardSync = MailSyncBackward(mailDatabase: mailDatabase)\n        super.init()\n\n        // Register for sleep/wake notifications\n        registerForPowerNotifications()\n    }\n\n    deinit {\n        unregisterForPowerNotifications()\n        syncTimer?.invalidate()\n    }\n\n    /// Start the run loop. Blocks until the daemon is terminated.\n    func startRunLoop() {\n        // Schedule periodic sync timer\n        scheduleSyncTimer()\n\n        // Run the main run loop to receive notifications\n        // This blocks until the process is terminated\n        RunLoop.current.run()\n    }\n\n    // MARK: - Power Notifications\n\n    private func registerForPowerNotifications() {\n        let workspace = NSWorkspace.shared\n        let center = workspace.notificationCenter\n\n        // System woke from sleep\n        center.addObserver(\n            self,\n            selector: #selector(systemDidWake(_:)),\n            name: NSWorkspace.didWakeNotification,\n            object: nil\n        )\n\n        // System is about to sleep\n        center.addObserver(\n            self,\n            selector: #selector(systemWillSleep(_:)),\n            name: NSWorkspace.willSleepNotification,\n            object: nil\n        )\n\n        logger(\"Registered for sleep/wake notifications\")\n    }\n\n    private func unregisterForPowerNotifications() {\n        NSWorkspace.shared.notificationCenter.removeObserver(self)\n    }\n\n    @objc private func systemDidWake(_ notification: Notification) {\n        logger(\"System woke from sleep - triggering catch-up sync\")\n        triggerSync(reason: \"wake\")\n    }\n\n    @objc private func systemWillSleep(_ notification: Notification) {\n        logger(\"System going to sleep\")\n        // Cancel any pending sync timer - we'll sync on wake instead\n        syncTimer?.invalidate()\n        syncTimer = nil\n    }\n\n    // MARK: - Sync Timer\n\n    private func scheduleSyncTimer() {\n        // Invalidate existing timer\n        syncTimer?.invalidate()\n\n        // Schedule new timer on the main run loop\n        syncTimer = Timer.scheduledTimer(withTimeInterval: syncIntervalSeconds, repeats: true) { [weak self] _ in\n            self?.triggerSync(reason: \"scheduled\")\n        }\n\n        logger(\"Scheduled sync timer (every \\(Int(syncIntervalSeconds))s)\")\n    }\n\n    // MARK: - Sync Execution\n\n    /// Trigger a sync, debouncing rapid-fire requests.\n    private func triggerSync(reason: String) {\n        // Debounce: don't sync if we synced very recently\n        if let lastSync = lastSyncTime {\n            let elapsed = Date().timeIntervalSince(lastSync)\n            if elapsed < Self.minSyncIntervalSeconds {\n                logger(\"Skipping \\(reason) sync (last sync was \\(Int(elapsed))s ago)\")\n                return\n            }\n        }\n\n        // Don't spawn duplicate syncs\n        syncQueue.async { [weak self] in\n            guard let self = self else { return }\n\n            if self.isSyncing {\n                self.logger(\"Sync already in progress, skipping \\(reason) sync\")\n                return\n            }\n\n            self.isSyncing = true\n            self.lastSyncTime = Date()\n\n            self.performSync(reason: reason)\n\n            self.isSyncing = false\n\n            // Re-schedule timer after wake (in case it was cancelled during sleep)\n            if reason == \"wake\" {\n                DispatchQueue.main.async {\n                    self.scheduleSyncTimer()\n                }\n            }\n        }\n    }\n\n    /// Perform the actual sync with retry logic.\n    private func performSync(reason: String) {\n        logger(\"Starting \\(reason) sync...\")\n\n        let maxRetryAttempts = 5\n        let baseRetryDelay: TimeInterval = 2.0\n        let maxRetryDelay: TimeInterval = 60.0\n\n        var attempt = 0\n        var lastError: Error?\n\n        while attempt < maxRetryAttempts {\n            do {\n                let sync = MailSync(mailDatabase: mailDatabase)\n                let result = try sync.sync()\n\n                logger(\"Sync complete: +\\(result.messagesAdded) ~\\(result.messagesUpdated) (\\(String(format: \"%.2f\", result.duration))s)\")\n\n                if !result.errors.isEmpty {\n                    logger(\"  \\(result.errors.count) warning(s)\")\n                }\n\n                // Auto-export new messages after successful sync\n                performAutoExport()\n\n                // Process pending backward sync actions (archive/delete from SwiftEA to Apple Mail)\n                performBackwardSync()\n                return\n\n            } catch {\n                lastError = error\n                attempt += 1\n\n                // Check if error is transient\n                let description = error.localizedDescription.lowercased()\n                let isTransient = description.contains(\"locked\") ||\n                                  description.contains(\"busy\") ||\n                                  description.contains(\"timeout\") ||\n                                  description.contains(\"temporarily\") ||\n                                  description.contains(\"try again\")\n\n                if isTransient && attempt < maxRetryAttempts {\n                    let delay = min(baseRetryDelay * pow(2.0, Double(attempt - 1)), maxRetryDelay)\n                    let jitter = delay * Double.random(in: 0.1...0.2)\n                    let totalDelay = delay + jitter\n\n                    logger(\"Transient error (attempt \\(attempt)/\\(maxRetryAttempts)): \\(error.localizedDescription)\")\n                    logger(\"Retrying in \\(String(format: \"%.1f\", totalDelay))s...\")\n\n                    Thread.sleep(forTimeInterval: totalDelay)\n                } else {\n                    break\n                }\n            }\n        }\n\n        if let error = lastError {\n            logger(\"ERROR: Sync failed after \\(attempt) attempt(s): \\(error.localizedDescription)\")\n        }\n    }\n\n    /// Export newly synced messages to Swiftea/Mail/ as markdown files\n    /// Messages are grouped by conversation/thread for better organization.\n    private func performAutoExport() {\n        let exporter = MailExporter(mailDatabase: mailDatabase)\n\n        do {\n            let exportResult = try exporter.exportNewMessages(to: exportDir)\n\n            if exportResult.exported > 0 {\n                var details: [String] = []\n                if exportResult.threadsExported > 0 {\n                    details.append(\"\\(exportResult.threadsExported) threads\")\n                }\n                if exportResult.unthreadedExported > 0 {\n                    details.append(\"\\(exportResult.unthreadedExported) unthreaded\")\n                }\n                let detailStr = details.isEmpty ? \"\" : \" (\\(details.joined(separator: \", \")))\"\n                logger(\"Auto-export: \\(exportResult.exported) message(s) to Swiftea/Mail/\\(detailStr)\")\n            }\n\n            if !exportResult.errors.isEmpty {\n                logger(\"  \\(exportResult.errors.count) export warning(s)\")\n            }\n        } catch {\n            logger(\"ERROR: Auto-export failed: \\(error.localizedDescription)\")\n        }\n    }\n\n    /// Process pending backward sync actions (archive/delete from SwiftEA to Apple Mail)\n    private func performBackwardSync() {\n        do {\n            let result = try backwardSync.processPendingActions()\n\n            // Log results if any actions were processed\n            if result.archived > 0 || result.deleted > 0 {\n                logger(\"Backward sync: \\(result.archived) archived, \\(result.deleted) deleted\")\n            }\n\n            // Log warnings for failed actions\n            if result.failed > 0 {\n                logger(\"WARNING: Backward sync failed for \\(result.failed) message(s)\")\n                for error in result.errors.prefix(3) {\n                    logger(\"  - \\(error)\")\n                }\n                if result.errors.count > 3 {\n                    logger(\"  ... and \\(result.errors.count - 3) more errors\")\n                }\n            }\n        } catch {\n            logger(\"ERROR: Backward sync failed: \\(error.localizedDescription)\")\n        }\n    }\n}\n\n/// Perform a sync in daemon mode with retry logic.\n/// This is a standalone function for use during daemon startup.\nprivate func performDaemonSync(mailDatabase: MailDatabase, exportDir: String) {\n    let maxRetryAttempts = 5\n    let baseRetryDelay: TimeInterval = 2.0\n    let maxRetryDelay: TimeInterval = 60.0\n\n    var attempt = 0\n\n    while attempt < maxRetryAttempts {\n        do {\n            let sync = MailSync(mailDatabase: mailDatabase)\n            let result = try sync.sync()\n\n            let timestamp = ISO8601DateFormatter().string(from: Date())\n            fputs(\"[\\(timestamp)] Sync complete: +\\(result.messagesAdded) ~\\(result.messagesUpdated) (\\(String(format: \"%.2f\", result.duration))s)\\n\", stdout)\n            fflush(stdout)\n\n            // Auto-export new messages after successful sync\n            performDaemonAutoExport(mailDatabase: mailDatabase, exportDir: exportDir)\n\n            // Process pending backward sync actions (archive/delete from SwiftEA to Apple Mail)\n            performDaemonBackwardSync(mailDatabase: mailDatabase)\n            return\n\n        } catch {\n            attempt += 1\n\n            let description = error.localizedDescription.lowercased()\n            let isTransient = description.contains(\"locked\") ||\n                              description.contains(\"busy\") ||\n                              description.contains(\"timeout\") ||\n                              description.contains(\"temporarily\") ||\n                              description.contains(\"try again\")\n\n            if isTransient && attempt < maxRetryAttempts {\n                let delay = min(baseRetryDelay * pow(2.0, Double(attempt - 1)), maxRetryDelay)\n                let jitter = delay * Double.random(in: 0.1...0.2)\n                let totalDelay = delay + jitter\n\n                let timestamp = ISO8601DateFormatter().string(from: Date())\n                fputs(\"[\\(timestamp)] Transient error (attempt \\(attempt)/\\(maxRetryAttempts)): \\(error.localizedDescription)\\n\", stdout)\n                fputs(\"[\\(timestamp)] Retrying in \\(String(format: \"%.1f\", totalDelay))s...\\n\", stdout)\n                fflush(stdout)\n\n                Thread.sleep(forTimeInterval: totalDelay)\n            } else {\n                let timestamp = ISO8601DateFormatter().string(from: Date())\n                fputs(\"[\\(timestamp)] ERROR: Initial sync failed: \\(error.localizedDescription)\\n\", stderr)\n                fflush(stderr)\n                return\n            }\n        }\n    }\n}\n\n/// Perform auto-export in daemon mode\n/// Messages are grouped by conversation/thread for better organization.\nprivate func performDaemonAutoExport(mailDatabase: MailDatabase, exportDir: String) {\n    let exporter = MailExporter(mailDatabase: mailDatabase)\n\n    do {\n        let exportResult = try exporter.exportNewMessages(to: exportDir)\n\n        if exportResult.exported > 0 {\n            let timestamp = ISO8601DateFormatter().string(from: Date())\n            var details: [String] = []\n            if exportResult.threadsExported > 0 {\n                details.append(\"\\(exportResult.threadsExported) threads\")\n            }\n            if exportResult.unthreadedExported > 0 {\n                details.append(\"\\(exportResult.unthreadedExported) unthreaded\")\n            }\n            let detailStr = details.isEmpty ? \"\" : \" (\\(details.joined(separator: \", \")))\"\n            fputs(\"[\\(timestamp)] Auto-export: \\(exportResult.exported) message(s) to Swiftea/Mail/\\(detailStr)\\n\", stdout)\n            fflush(stdout)\n        }\n\n        if !exportResult.errors.isEmpty {\n            let timestamp = ISO8601DateFormatter().string(from: Date())\n            fputs(\"[\\(timestamp)]   \\(exportResult.errors.count) export warning(s)\\n\", stdout)\n            fflush(stdout)\n        }\n    } catch {\n        let timestamp = ISO8601DateFormatter().string(from: Date())\n        fputs(\"[\\(timestamp)] ERROR: Auto-export failed: \\(error.localizedDescription)\\n\", stderr)\n        fflush(stderr)\n    }\n}\n\n/// Process pending backward sync actions in daemon mode (archive/delete from SwiftEA to Apple Mail)\nprivate func performDaemonBackwardSync(mailDatabase: MailDatabase) {\n    let backwardSync = MailSyncBackward(mailDatabase: mailDatabase)\n\n    do {\n        let result = try backwardSync.processPendingActions()\n\n        // Log results if any actions were processed\n        if result.archived > 0 || result.deleted > 0 {\n            let timestamp = ISO8601DateFormatter().string(from: Date())\n            fputs(\"[\\(timestamp)] Backward sync: \\(result.archived) archived, \\(result.deleted) deleted\\n\", stdout)\n            fflush(stdout)\n        }\n\n        // Log warnings for failed actions\n        if result.failed > 0 {\n            let timestamp = ISO8601DateFormatter().string(from: Date())\n            fputs(\"[\\(timestamp)] WARNING: Backward sync failed for \\(result.failed) message(s)\\n\", stdout)\n            fflush(stdout)\n            for error in result.errors.prefix(3) {\n                fputs(\"[\\(timestamp)]   - \\(error)\\n\", stdout)\n            }\n            if result.errors.count > 3 {\n                fputs(\"[\\(timestamp)]   ... and \\(result.errors.count - 3) more errors\\n\", stdout)\n            }\n            fflush(stdout)\n        }\n    } catch {\n        let timestamp = ISO8601DateFormatter().string(from: Date())\n        fputs(\"[\\(timestamp)] ERROR: Backward sync failed: \\(error.localizedDescription)\\n\", stderr)\n        fflush(stderr)\n    }\n}\n\nstruct MailSearchCommand: ParsableCommand {\n    static let configuration = CommandConfiguration(\n        commandName: \"search\",\n        abstract: \"Search mail using full-text search with structured filters\",\n        discussion: \"\"\"\n            Search for mail messages using full-text search and/or structured filters.\n\n            STRUCTURED FILTERS:\n              from:email       - Filter by sender email or name\n              to:email         - Filter by recipient email or name\n              subject:text     - Filter by subject containing text\n              mailbox:name     - Filter by mailbox name\n              is:read          - Show only read messages\n              is:unread        - Show only unread messages\n              is:flagged       - Show only flagged messages\n              is:unflagged     - Show only unflagged messages\n              has:attachments  - Show only messages with attachments\n              after:YYYY-MM-DD - Messages received after date\n              before:YYYY-MM-DD - Messages received before date\n              date:YYYY-MM-DD  - Messages received on specific date\n\n            STATUS FILTER (--status):\n              inbox    - Messages in your inbox\n              archived - Messages you've archived\n              deleted  - Messages you've deleted\n\n            EXAMPLES:\n              swea mail search \"from:alice@example.com project\"\n              swea mail search \"is:unread is:flagged\"\n              swea mail search \"after:2024-01-01 before:2024-02-01\"\n              swea mail search \"mailbox:INBOX from:support\"\n              swea mail search --status inbox \"from:support\"\n              swea mail search --status archived \"\"\n\n            Use quotes around values with spaces: from:\"Alice Smith\"\n            \"\"\"\n    )\n\n    @Argument(help: \"Search query with optional structured filters\")\n    var query: String\n\n    @Option(name: .long, help: \"Filter by mailbox status: inbox, archived, deleted\")\n    var status: String?\n\n    @Option(name: .long, help: \"Maximum results to return\")\n    var limit: Int = 20\n\n    @Flag(name: .long, help: \"Output as JSON\")\n    var json: Bool = false\n\n    func validate() throws {\n        // --limit must be a positive integer\n        if limit <= 0 {\n            throw MailValidationError.invalidLimit\n        }\n\n        // --status must be a valid value if provided\n        if let status = status {\n            let validStatuses = [\"inbox\", \"archived\", \"deleted\"]\n            if !validStatuses.contains(status.lowercased()) {\n                throw MailValidationError.invalidStatus(value: status)\n            }\n        }\n    }\n\n    func run() throws {\n        let vault = try VaultContext.require()\n\n        // Open mail database\n        let mailDbPath = (vault.dataFolderPath as NSString).appendingPathComponent(\"mail.db\")\n        let mailDatabase = MailDatabase(databasePath: mailDbPath)\n        try mailDatabase.initialize()\n        defer { mailDatabase.close() }\n\n        // Parse the query for structured filters\n        var filter = mailDatabase.parseQuery(query)\n\n        // Apply --status option if provided\n        if let statusValue = status {\n            filter.mailboxStatus = MailboxStatus(rawValue: statusValue.lowercased())\n        }\n\n        // Use structured search if we have filters, otherwise fall back to basic FTS\n        let results: [MailMessage]\n        if filter.hasFilters || filter.hasFreeText {\n            results = try mailDatabase.searchMessagesWithFilters(filter, limit: limit)\n        } else {\n            // Empty query - show recent messages\n            results = try mailDatabase.getAllMessages(limit: limit)\n        }\n\n        if results.isEmpty {\n            printError(\"No messages found for: \\(query)\")\n            return\n        }\n\n        if json {\n            // Output as JSON with filter info\n            var output: [[String: Any]] = []\n            for msg in results {\n                let msgDict: [String: Any] = [\n                    \"id\": msg.id,\n                    \"subject\": msg.subject,\n                    \"sender\": msg.senderEmail ?? \"\",\n                    \"senderName\": msg.senderName ?? \"\",\n                    \"date\": msg.dateSent?.description ?? \"\",\n                    \"mailbox\": msg.mailboxName ?? \"\",\n                    \"isRead\": msg.isRead,\n                    \"isFlagged\": msg.isFlagged,\n                    \"hasAttachments\": msg.hasAttachments\n                ]\n                output.append(msgDict)\n            }\n            if let data = try? JSONSerialization.data(withJSONObject: output, options: .prettyPrinted),\n               let jsonString = String(data: data, encoding: .utf8) {\n                print(jsonString)\n            }\n        } else {\n            // Show filter summary if structured filters were used\n            if filter.hasFilters {\n                var filterDesc: [String] = []\n                if let from = filter.from { filterDesc.append(\"from:\\(from)\") }\n                if let to = filter.to { filterDesc.append(\"to:\\(to)\") }\n                if let subject = filter.subject { filterDesc.append(\"subject:\\(subject)\") }\n                if let mailbox = filter.mailbox { filterDesc.append(\"mailbox:\\(mailbox)\") }\n                if let mailboxStatus = filter.mailboxStatus { filterDesc.append(\"status:\\(mailboxStatus.rawValue)\") }\n                if let isRead = filter.isRead { filterDesc.append(isRead ? \"is:read\" : \"is:unread\") }\n                if let isFlagged = filter.isFlagged { filterDesc.append(isFlagged ? \"is:flagged\" : \"is:unflagged\") }\n                if filter.hasAttachments == true { filterDesc.append(\"has:attachments\") }\n                if filter.dateAfter != nil || filter.dateBefore != nil {\n                    let df = DateFormatter()\n                    df.dateFormat = \"yyyy-MM-dd\"\n                    if let after = filter.dateAfter { filterDesc.append(\"after:\\(df.string(from: after))\") }\n                    if let before = filter.dateBefore { filterDesc.append(\"before:\\(df.string(from: before))\") }\n                }\n                print(\"Filters: \\(filterDesc.joined(separator: \" \"))\")\n                if let freeText = filter.freeText {\n                    print(\"Search: \\(freeText)\")\n                }\n                print(\"\")\n            }\n\n            print(\"Found \\(results.count) message(s):\\n\")\n            for msg in results {\n                let date = msg.dateSent.map { DateFormatter.localizedString(from: $0, dateStyle: .short, timeStyle: .short) } ?? \"Unknown\"\n                let sender = msg.senderName ?? msg.senderEmail ?? \"Unknown\"\n                var flags: [String] = []\n                if !msg.isRead { flags.append(\"UNREAD\") }\n                if msg.isFlagged { flags.append(\"FLAGGED\") }\n                if msg.hasAttachments { flags.append(\"ATTACH\") }\n                let flagStr = flags.isEmpty ? \"\" : \" [\\(flags.joined(separator: \", \"))]\"\n\n                print(\"[\\(msg.id)]\\(flagStr)\")\n                print(\"  Subject: \\(msg.subject)\")\n                print(\"  From: \\(sender)\")\n                print(\"  Date: \\(date)\")\n                print(\"  Mailbox: \\(msg.mailboxName ?? \"Unknown\")\")\n                print(\"\")\n            }\n        }\n    }\n}\n\nstruct MailShowCommand: ParsableCommand {\n    static let configuration = CommandConfiguration(\n        commandName: \"show\",\n        abstract: \"Display a single email message\"\n    )\n\n    @Argument(help: \"Message ID to display\")\n    var id: String\n\n    @Flag(name: .long, help: \"Show HTML body instead of plain text\")\n    var html: Bool = false\n\n    @Flag(name: .long, help: \"Show raw .emlx content\")\n    var raw: Bool = false\n\n    @Flag(name: .long, help: \"Output as JSON\")\n    var json: Bool = false\n\n    func run() throws {\n        let vault = try VaultContext.require()\n\n        // Open mail database\n        let mailDbPath = (vault.dataFolderPath as NSString).appendingPathComponent(\"mail.db\")\n        let mailDatabase = MailDatabase(databasePath: mailDbPath)\n        try mailDatabase.initialize()\n        defer { mailDatabase.close() }\n\n        guard let message = try mailDatabase.getMessage(id: id) else {\n            printError(\"Message not found: \\(id)\")\n            throw ExitCode.failure\n        }\n\n        // Handle --raw flag: read original .emlx file\n        if raw {\n            guard let emlxPath = message.emlxPath else {\n                printError(\"No .emlx path available for this message\")\n                throw ExitCode.failure\n            }\n\n            // Check for EWS (Exchange) mailbox paths which contain \"ews:\" prefix\n            // These are cloud-based mailboxes that don't have local .emlx files\n            if emlxPath.contains(\"ews:\") || emlxPath.contains(\"/ews:/\") {\n                printError(\"Raw .emlx viewing is not available for Exchange (EWS) mailboxes.\")\n                printError(\"Exchange messages are stored on the server, not as local .emlx files.\")\n                printError(\"Use 'mail show \\(id)' without --raw to view the message content.\")\n                throw ExitCode.failure\n            }\n\n            guard let content = try? String(contentsOfFile: emlxPath, encoding: .utf8) else {\n                printError(\"Could not read .emlx file: \\(emlxPath)\")\n                throw ExitCode.failure\n            }\n            print(content)\n            return\n        }\n\n        // Handle --json flag\n        if json {\n            let output: [String: Any] = [\n                \"id\": message.id,\n                \"messageId\": message.messageId ?? \"\",\n                \"subject\": message.subject,\n                \"from\": formatSender(message),\n                \"date\": message.dateSent?.iso8601String ?? \"\",\n                \"mailbox\": message.mailboxName ?? \"\",\n                \"isRead\": message.isRead,\n                \"isFlagged\": message.isFlagged,\n                \"hasAttachments\": message.hasAttachments,\n                \"body\": html ? (message.bodyHtml ?? \"\") : (message.bodyText ?? \"\")\n            ]\n            if let data = try? JSONSerialization.data(withJSONObject: output, options: .prettyPrinted),\n               let jsonString = String(data: data, encoding: .utf8) {\n                print(jsonString)\n            }\n            return\n        }\n\n        // Default: formatted text output\n        let date = message.dateSent.map { DateFormatter.localizedString(from: $0, dateStyle: .long, timeStyle: .long) } ?? \"Unknown\"\n        let sender = formatSender(message)\n\n        print(\"Subject: \\(message.subject)\")\n        print(\"From: \\(sender)\")\n        print(\"Date: \\(date)\")\n        print(\"Mailbox: \\(message.mailboxName ?? \"Unknown\")\")\n        if message.hasAttachments {\n            print(\"Attachments: Yes\")\n        }\n        print(\"\")\n        print(String(repeating: \"-\", count: 60))\n        print(\"\")\n\n        // Show body content\n        if html {\n            if let htmlBody = message.bodyHtml {\n                print(htmlBody)\n            } else {\n                print(\"(No HTML body available)\")\n            }\n        } else {\n            if let textBody = message.bodyText {\n                print(textBody)\n            } else if let htmlBody = message.bodyHtml {\n                // Fallback: strip HTML tags for plain text display\n                print(stripHtml(htmlBody))\n            } else {\n                print(\"(No message body available)\")\n            }\n        }\n    }\n\n    private func formatSender(_ message: MailMessage) -> String {\n        if let name = message.senderName, let email = message.senderEmail {\n            return \"\\(name) <\\(email)>\"\n        } else if let email = message.senderEmail {\n            return email\n        } else if let name = message.senderName {\n            return name\n        }\n        return \"Unknown\"\n    }\n\n    private func stripHtml(_ html: String) -> String {\n        // Simple HTML tag stripping\n        var result = html\n        // Remove script and style blocks\n        result = result.replacingOccurrences(of: \"<script[^>]*>.*?</script>\", with: \"\", options: .regularExpression)\n        result = result.replacingOccurrences(of: \"<style[^>]*>.*?</style>\", with: \"\", options: .regularExpression)\n        // Replace common entities\n        result = result.replacingOccurrences(of: \"&nbsp;\", with: \" \")\n        result = result.replacingOccurrences(of: \"&amp;\", with: \"&\")\n        result = result.replacingOccurrences(of: \"&lt;\", with: \"<\")\n        result = result.replacingOccurrences(of: \"&gt;\", with: \">\")\n        result = result.replacingOccurrences(of: \"&quot;\", with: \"\\\"\")\n        // Replace <br> and </p> with newlines\n        result = result.replacingOccurrences(of: \"<br[^>]*>\", with: \"\\n\", options: .regularExpression)\n        result = result.replacingOccurrences(of: \"</p>\", with: \"\\n\\n\")\n        // Remove all remaining tags\n        result = result.replacingOccurrences(of: \"<[^>]+>\", with: \"\", options: .regularExpression)\n        // Collapse multiple newlines\n        result = result.replacingOccurrences(of: \"\\n{3,}\", with: \"\\n\\n\", options: .regularExpression)\n        return result.trimmingCharacters(in: .whitespacesAndNewlines)\n    }\n}\n\n// MARK: - Thread Command\n\nstruct MailThreadCommand: ParsableCommand {\n    static let configuration = CommandConfiguration(\n        commandName: \"thread\",\n        abstract: \"Display all messages in an email thread\",\n        discussion: \"\"\"\n            Shows all messages in a conversation thread, ordered chronologically.\n            Displays thread metadata including subject, participants, and date range.\n\n            EXAMPLES\n              swea mail thread abc123                    # Display thread (default: text)\n              swea mail thread abc123 --format json      # Output as JSON for scripting\n              swea mail thread abc123 --format markdown  # Output as Markdown\n              swea mail thread abc123 --html             # Show HTML bodies instead of plain text\n            \"\"\"\n    )\n\n    @Argument(help: \"Thread ID to display\")\n    var id: String\n\n    @Flag(name: .long, help: \"Show HTML body instead of plain text\")\n    var html: Bool = false\n\n    @Option(name: .long, help: \"Output format: text (default), json, or markdown\")\n    var format: ThreadOutputFormat = .text\n\n    func run() throws {\n        let vault = try VaultContext.require()\n\n        // Open mail database\n        let mailDbPath = (vault.dataFolderPath as NSString).appendingPathComponent(\"mail.db\")\n        let mailDatabase = MailDatabase(databasePath: mailDbPath)\n        try mailDatabase.initialize()\n        defer { mailDatabase.close() }\n\n        // Get thread by ID\n        guard let thread = try mailDatabase.getThread(id: id) else {\n            printError(\"Thread not found: \\(id)\")\n            printError(\"\")\n            printError(\"To find available threads, try:\")\n            printError(\"  swea mail export-threads --limit 10   # Export recent threads\")\n            printError(\"  swea mail search <query>              # Search for messages\")\n            throw ExitCode.failure\n        }\n\n        // Get all messages in the thread, sorted chronologically\n        let messages = try mailDatabase.getMessagesInThreadViaJunction(threadId: thread.id, limit: 10000)\n\n        // Extract thread properties to avoid type ambiguity with Foundation.Thread\n        let threadId = thread.id\n        let threadSubject = thread.subject\n        let participantCount = thread.participantCount\n        let messageCount = thread.messageCount\n        let firstDate = thread.firstDate\n        let lastDate = thread.lastDate\n\n        switch format {\n        case .json:\n            outputAsJson(\n                threadId: threadId,\n                subject: threadSubject,\n                participantCount: participantCount,\n                messageCount: messageCount,\n                firstDate: firstDate,\n                lastDate: lastDate,\n                messages: messages\n            )\n        case .markdown, .md:\n            outputAsMarkdown(\n                threadId: threadId,\n                subject: threadSubject,\n                participantCount: participantCount,\n                messageCount: messageCount,\n                firstDate: firstDate,\n                lastDate: lastDate,\n                messages: messages\n            )\n        case .text:\n            outputAsText(\n                threadId: threadId,\n                subject: threadSubject,\n                participantCount: participantCount,\n                messageCount: messageCount,\n                firstDate: firstDate,\n                lastDate: lastDate,\n                messages: messages\n            )\n        }\n    }\n\n    private func outputAsJson(\n        threadId: String,\n        subject: String?,\n        participantCount: Int,\n        messageCount: Int,\n        firstDate: Date?,\n        lastDate: Date?,\n        messages: [MailMessage]\n    ) {\n        let threadTotal = messages.count\n\n        // Build messages array with thread position\n        var messagesArray: [[String: Any]] = []\n        for (index, message) in messages.enumerated() {\n            let position = index + 1\n            messagesArray.append([\n                \"id\": message.id,\n                \"messageId\": message.messageId ?? \"\",\n                \"subject\": message.subject,\n                \"from\": [\n                    \"name\": message.senderName ?? \"\",\n                    \"email\": message.senderEmail ?? \"\"\n                ],\n                \"date\": message.dateSent?.iso8601String ?? \"\",\n                \"mailbox\": message.mailboxName ?? \"\",\n                \"isRead\": message.isRead,\n                \"isFlagged\": message.isFlagged,\n                \"hasAttachments\": message.hasAttachments,\n                \"body\": html ? (message.bodyHtml ?? \"\") : (message.bodyText ?? message.bodyHtml.map { stripHtml($0) } ?? \"\"),\n                \"thread_position\": position,\n                \"thread_total\": threadTotal\n            ])\n        }\n\n        // Build thread structure\n        let output: [String: Any] = [\n            \"thread_id\": threadId,\n            \"subject\": subject ?? \"\",\n            \"participant_count\": participantCount,\n            \"message_count\": messageCount,\n            \"first_date\": firstDate?.iso8601String ?? \"\",\n            \"last_date\": lastDate?.iso8601String ?? \"\",\n            \"messages\": messagesArray\n        ]\n\n        if let data = try? JSONSerialization.data(withJSONObject: output, options: [.prettyPrinted, .sortedKeys]),\n           let jsonString = String(data: data, encoding: .utf8) {\n            print(jsonString)\n        }\n    }\n\n    private func outputAsMarkdown(\n        threadId: String,\n        subject: String?,\n        participantCount: Int,\n        messageCount: Int,\n        firstDate: Date?,\n        lastDate: Date?,\n        messages: [MailMessage]\n    ) {\n        let threadTotal = messages.count\n        let dateFormatter = ISO8601DateFormatter()\n        dateFormatter.formatOptions = [.withInternetDateTime]\n\n        // YAML frontmatter\n        print(\"---\")\n        print(\"thread_id: \\(threadId)\")\n        print(\"subject: \\\"\\(escapeYaml(subject ?? \"(No Subject)\"))\\\"\")\n        print(\"participant_count: \\(participantCount)\")\n        print(\"message_count: \\(messageCount)\")\n        if let firstDate = firstDate {\n            print(\"first_date: \\(dateFormatter.string(from: firstDate))\")\n        }\n        if let lastDate = lastDate {\n            print(\"last_date: \\(dateFormatter.string(from: lastDate))\")\n        }\n        print(\"---\")\n        print(\"\")\n\n        // Thread header\n        print(\"# \\(subject ?? \"(No Subject)\")\")\n        print(\"\")\n        print(\"**Thread ID:** `\\(threadId)`  \")\n        print(\"**Participants:** \\(participantCount)  \")\n        print(\"**Messages:** \\(messageCount)\")\n        print(\"\")\n\n        if let firstDate = firstDate, let lastDate = lastDate {\n            let firstFormatted = DateFormatter.localizedString(from: firstDate, dateStyle: .long, timeStyle: .short)\n            let lastFormatted = DateFormatter.localizedString(from: lastDate, dateStyle: .long, timeStyle: .short)\n            print(\"**Date Range:** \\(firstFormatted) â†’ \\(lastFormatted)\")\n            print(\"\")\n        }\n\n        print(\"---\")\n        print(\"\")\n\n        // Display each message\n        for (index, message) in messages.enumerated() {\n            let position = index + 1\n\n            print(\"## [\\(position)/\\(threadTotal)] \\(message.subject)\")\n            print(\"\")\n            print(\"**From:** \\(formatSender(message))  \")\n            if let date = message.dateSent {\n                let dateFormatted = DateFormatter.localizedString(from: date, dateStyle: .long, timeStyle: .long)\n                print(\"**Date:** \\(dateFormatted)  \")\n            }\n            if let mailbox = message.mailboxName {\n                print(\"**Mailbox:** \\(mailbox)  \")\n            }\n            if message.hasAttachments {\n                print(\"**Attachments:** Yes\")\n            }\n            print(\"\")\n\n            // Body content in a blockquote for better formatting\n            let body: String\n            if html {\n                body = message.bodyHtml ?? \"(No HTML body available)\"\n            } else if let textBody = message.bodyText, !textBody.isEmpty {\n                body = textBody\n            } else if let htmlBody = message.bodyHtml {\n                body = stripHtml(htmlBody)\n            } else {\n                body = \"(No message body available)\"\n            }\n\n            // Output body - preserve line breaks for readability\n            print(body)\n            print(\"\")\n\n            // Separator between messages\n            if index < messages.count - 1 {\n                print(\"---\")\n                print(\"\")\n            }\n        }\n\n        // Footer\n        print(\"\")\n        print(\"---\")\n        print(\"\")\n        print(\"*End of thread (\\(threadTotal) message(s))*\")\n    }\n\n    private func escapeYaml(_ string: String) -> String {\n        return string.replacingOccurrences(of: \"\\\"\", with: \"\\\\\\\"\")\n    }\n\n    private func outputAsText(\n        threadId: String,\n        subject: String?,\n        participantCount: Int,\n        messageCount: Int,\n        firstDate: Date?,\n        lastDate: Date?,\n        messages: [MailMessage]\n    ) {\n        let threadTotal = messages.count\n\n        // Thread header with metadata\n        print(\"Thread: \\(subject ?? \"(No Subject)\")\")\n        print(String(repeating: \"=\", count: 70))\n        print(\"\")\n        print(\"Thread ID: \\(threadId)\")\n        print(\"Participants: \\(participantCount)\")\n        print(\"Messages: \\(messageCount)\")\n        if let firstDate = firstDate, let lastDate = lastDate {\n            let firstFormatted = DateFormatter.localizedString(from: firstDate, dateStyle: .long, timeStyle: .short)\n            let lastFormatted = DateFormatter.localizedString(from: lastDate, dateStyle: .long, timeStyle: .short)\n            print(\"Date Range: \\(firstFormatted) â†’ \\(lastFormatted)\")\n        }\n        print(\"\")\n        print(String(repeating: \"=\", count: 70))\n\n        // Display each message chronologically\n        for (index, message) in messages.enumerated() {\n            let position = index + 1\n            print(\"\")\n            print(\"[\\(position)/\\(threadTotal)] \\(message.subject)\")\n            print(String(repeating: \"-\", count: 60))\n            print(\"From: \\(formatSender(message))\")\n            if let date = message.dateSent {\n                let dateFormatted = DateFormatter.localizedString(from: date, dateStyle: .long, timeStyle: .long)\n                print(\"Date: \\(dateFormatted)\")\n            }\n            if let mailbox = message.mailboxName {\n                print(\"Mailbox: \\(mailbox)\")\n            }\n            if message.hasAttachments {\n                print(\"Attachments: Yes\")\n            }\n            print(\"\")\n\n            // Body content\n            if html {\n                if let htmlBody = message.bodyHtml {\n                    print(htmlBody)\n                } else {\n                    print(\"(No HTML body available)\")\n                }\n            } else {\n                if let textBody = message.bodyText, !textBody.isEmpty {\n                    print(textBody)\n                } else if let htmlBody = message.bodyHtml {\n                    print(stripHtml(htmlBody))\n                } else {\n                    print(\"(No message body available)\")\n                }\n            }\n        }\n\n        // Footer\n        print(\"\")\n        print(String(repeating: \"=\", count: 70))\n        print(\"End of thread (\\(threadTotal) message(s))\")\n    }\n\n    private func formatSender(_ message: MailMessage) -> String {\n        if let name = message.senderName, let email = message.senderEmail {\n            return \"\\(name) <\\(email)>\"\n        } else if let email = message.senderEmail {\n            return email\n        } else if let name = message.senderName {\n            return name\n        }\n        return \"Unknown\"\n    }\n\n    private func stripHtml(_ html: String) -> String {\n        var result = html\n        result = result.replacingOccurrences(of: \"<script[^>]*>.*?</script>\", with: \"\", options: .regularExpression)\n        result = result.replacingOccurrences(of: \"<style[^>]*>.*?</style>\", with: \"\", options: .regularExpression)\n        result = result.replacingOccurrences(of: \"&nbsp;\", with: \" \")\n        result = result.replacingOccurrences(of: \"&amp;\", with: \"&\")\n        result = result.replacingOccurrences(of: \"&lt;\", with: \"<\")\n        result = result.replacingOccurrences(of: \"&gt;\", with: \">\")\n        result = result.replacingOccurrences(of: \"&quot;\", with: \"\\\"\")\n        result = result.replacingOccurrences(of: \"<br[^>]*>\", with: \"\\n\", options: .regularExpression)\n        result = result.replacingOccurrences(of: \"</p>\", with: \"\\n\\n\")\n        result = result.replacingOccurrences(of: \"<[^>]+>\", with: \"\", options: .regularExpression)\n        result = result.replacingOccurrences(of: \"\\n{3,}\", with: \"\\n\\n\", options: .regularExpression)\n        return result.trimmingCharacters(in: .whitespacesAndNewlines)\n    }\n}\n\n// MARK: - Threads Command (List all threads)\n\nstruct MailThreadsCommand: ParsableCommand {\n    static let configuration = CommandConfiguration(\n        commandName: \"threads\",\n        abstract: \"List all email threads\",\n        discussion: \"\"\"\n            Lists all email threads (conversations) with their metadata including\n            thread ID, subject, participants, message count, and date range.\n            Threads are ordered by most recent activity by default.\n\n            EXAMPLES\n              swea mail threads                         # List threads (default: text)\n              swea mail threads --limit 100             # List more threads\n              swea mail threads --sort subject          # Sort by subject alphabetically\n              swea mail threads --sort message_count    # Sort by number of messages\n              swea mail threads --participant john@     # Filter by participant email\n              swea mail threads --format json           # Output as JSON for scripting\n              swea mail threads --format markdown       # Output as Markdown\n            \"\"\"\n    )\n\n    @Option(name: .shortAndLong, help: \"Maximum number of threads to display (default: 50)\")\n    var limit: Int = 50\n\n    @Option(name: .shortAndLong, help: \"Number of threads to skip (for pagination)\")\n    var offset: Int = 0\n\n    @Option(name: .shortAndLong, help: \"Sort by: date (default), subject, or message_count\")\n    var sort: ThreadSortOption = .date\n\n    @Option(name: .shortAndLong, help: \"Filter threads by participant email (partial match)\")\n    var participant: String?\n\n    @Option(name: .long, help: \"Output format: text (default), json, or markdown\")\n    var format: ThreadOutputFormat = .text\n\n    func run() throws {\n        let vault = try VaultContext.require()\n\n        // Open mail database\n        let mailDbPath = (vault.dataFolderPath as NSString).appendingPathComponent(\"mail.db\")\n        let mailDatabase = MailDatabase(databasePath: mailDbPath)\n        try mailDatabase.initialize()\n        defer { mailDatabase.close() }\n\n        // Get threads with filtering and sorting options\n        let threads = try mailDatabase.getThreads(\n            limit: limit,\n            offset: offset,\n            sortBy: sort.toDbSortOrder(),\n            participant: participant\n        )\n\n        if threads.isEmpty {\n            if format.isJson {\n                let message = participant != nil\n                    ? \"No threads found matching participant '\\(participant!)'\"\n                    : \"No threads found\"\n                print(\"{\\\"threads\\\": [], \\\"count\\\": 0, \\\"message\\\": \\\"\\(message)\\\"}\")\n            } else {\n                if let participant = participant {\n                    print(\"No email threads found with participant '\\(participant)'.\")\n                } else {\n                    print(\"No email threads found.\")\n                }\n                print(\"\")\n                print(\"To build threads from your synced messages, run:\")\n                print(\"  swea mail sync\")\n                print(\"\")\n                print(\"Threads are automatically created during sync based on\")\n                print(\"email headers (In-Reply-To, References) and subject matching.\")\n            }\n            return\n        }\n\n        let totalCount = try mailDatabase.getThreadCount(participant: participant)\n\n        switch format {\n        case .json:\n            outputAsJson(threads: threads, totalCount: totalCount)\n        case .markdown, .md:\n            outputAsMarkdown(threads: threads, totalCount: totalCount)\n        case .text:\n            outputAsText(threads: threads, totalCount: totalCount)\n        }\n    }\n\n    private func outputAsJson<T: ThreadLike>(threads: [T], totalCount: Int) {\n        var threadsArray: [[String: Any]] = []\n        for thread in threads {\n            var threadDict: [String: Any] = [\n                \"id\": thread.id,\n                \"subject\": thread.subject ?? \"\",\n                \"participant_count\": thread.participantCount,\n                \"message_count\": thread.messageCount\n            ]\n            if let firstDate = thread.firstDate {\n                threadDict[\"first_date\"] = firstDate.iso8601String\n            }\n            if let lastDate = thread.lastDate {\n                threadDict[\"last_date\"] = lastDate.iso8601String\n            }\n            threadsArray.append(threadDict)\n        }\n\n        var output: [String: Any] = [\n            \"threads\": threadsArray,\n            \"count\": threads.count,\n            \"total\": totalCount,\n            \"offset\": offset,\n            \"limit\": limit,\n            \"sort\": sort.rawValue\n        ]\n        if let participant = participant {\n            output[\"participant_filter\"] = participant\n        }\n\n        if let data = try? JSONSerialization.data(withJSONObject: output, options: [.prettyPrinted, .sortedKeys]),\n           let jsonString = String(data: data, encoding: .utf8) {\n            print(jsonString)\n        }\n    }\n\n    private func outputAsMarkdown<T: ThreadLike>(threads: [T], totalCount: Int) {\n        let dateFormatter = ISO8601DateFormatter()\n        dateFormatter.formatOptions = [.withInternetDateTime]\n\n        // YAML frontmatter\n        print(\"---\")\n        print(\"type: thread_list\")\n        print(\"count: \\(threads.count)\")\n        print(\"total: \\(totalCount)\")\n        print(\"offset: \\(offset)\")\n        print(\"limit: \\(limit)\")\n        print(\"sort: \\(sort.rawValue)\")\n        if let participant = participant {\n            print(\"participant_filter: \\(participant)\")\n        }\n        print(\"---\")\n        print(\"\")\n\n        // Header\n        print(\"# Email Threads\")\n        print(\"\")\n        var summaryLine = \"Showing \\(threads.count) of \\(totalCount) threads\"\n        if let participant = participant {\n            summaryLine += \" (filtered by: \\(participant))\"\n        }\n        if sort != .date {\n            summaryLine += \" (sorted by: \\(sort.rawValue))\"\n        }\n        print(summaryLine)\n        print(\"\")\n\n        // Date formatter for display\n        let displayFormatter = DateFormatter()\n        displayFormatter.dateStyle = .medium\n        displayFormatter.timeStyle = .short\n\n        // Table header\n        print(\"| Thread ID | Subject | Participants | Messages | Last Activity |\")\n        print(\"|-----------|---------|--------------|----------|---------------|\")\n\n        for thread in threads {\n            let subject = thread.subject ?? \"(No Subject)\"\n            let truncatedSubject = subject.count > 40 ? String(subject.prefix(37)) + \"...\" : subject\n            let escapedSubject = truncatedSubject.replacingOccurrences(of: \"|\", with: \"\\\\|\")\n            let lastActivity = thread.lastDate.map { displayFormatter.string(from: $0) } ?? \"-\"\n\n            print(\"| `\\(thread.id)` | \\(escapedSubject) | \\(thread.participantCount) | \\(thread.messageCount) | \\(lastActivity) |\")\n        }\n\n        print(\"\")\n\n        // Footer\n        if totalCount > threads.count + offset {\n            print(\"---\")\n            print(\"\")\n            print(\"*Showing \\(offset + 1)-\\(offset + threads.count) of \\(totalCount) threads*\")\n            print(\"\")\n            print(\"To see more threads:\")\n            print(\"```\")\n            print(\"swea mail threads --limit \\(limit) --offset \\(offset + threads.count)\")\n            print(\"```\")\n        }\n\n        print(\"\")\n        print(\"To view a specific thread:\")\n        print(\"```\")\n        print(\"swea mail thread <thread-id>\")\n        print(\"```\")\n    }\n\n    private func outputAsText<T: ThreadLike>(threads: [T], totalCount: Int) {\n        var headerLine = \"Email Threads\"\n        if let participant = participant {\n            headerLine += \" (filtered by: \\(participant))\"\n        }\n        if sort != .date {\n            headerLine += \" (sorted by: \\(sort.rawValue))\"\n        }\n        print(headerLine)\n        print(String(repeating: \"=\", count: 70))\n        print(\"\")\n\n        // Date formatter for consistent display\n        let dateFormatter = DateFormatter()\n        dateFormatter.dateStyle = .medium\n        dateFormatter.timeStyle = .short\n\n        for thread in threads {\n            // Thread ID and subject\n            let subject = thread.subject ?? \"(No Subject)\"\n            print(\"[\\(thread.id)] \\(subject)\")\n\n            // Participants and message count\n            print(\"  Participants: \\(thread.participantCount)  |  Messages: \\(thread.messageCount)\")\n\n            // Date range\n            if let firstDate = thread.firstDate, let lastDate = thread.lastDate {\n                let firstFormatted = dateFormatter.string(from: firstDate)\n                let lastFormatted = dateFormatter.string(from: lastDate)\n                if firstDate == lastDate {\n                    print(\"  Date: \\(firstFormatted)\")\n                } else {\n                    print(\"  Date Range: \\(firstFormatted) â†’ \\(lastFormatted)\")\n                }\n            } else if let lastDate = thread.lastDate {\n                print(\"  Last Activity: \\(dateFormatter.string(from: lastDate))\")\n            }\n\n            print(\"\")\n        }\n\n        // Footer with pagination info\n        print(String(repeating: \"-\", count: 70))\n        if totalCount > threads.count + offset {\n            print(\"Showing \\(offset + 1)-\\(offset + threads.count) of \\(totalCount) threads\")\n            print(\"\")\n            print(\"To see more threads:\")\n            print(\"  swea mail threads --limit \\(limit) --offset \\(offset + threads.count)\")\n        } else {\n            print(\"Showing \\(threads.count) of \\(totalCount) threads\")\n        }\n        print(\"\")\n        print(\"To view a specific thread:\")\n        print(\"  swea mail thread <thread-id>\")\n    }\n}\n\n// Note: ThreadLike protocol is defined in SwiftEAKit.MailDatabase\n// and Thread already conforms to it\n\n/// Output format for mail export command.\n/// Conforms to ExpressibleByArgument for ArgumentParser integration,\n/// enabling type-safe parsing with automatic validation.\npublic enum OutputFormat: String, CaseIterable, ExpressibleByArgument {\n    case markdown\n    case md\n    case json\n\n    /// All valid format values for help text and error messages\n    public static var allValueStrings: [String] {\n        allCases.map { $0.rawValue }\n    }\n\n    /// Check if this format produces JSON output\n    var isJson: Bool {\n        self == .json\n    }\n\n    /// Check if this format produces Markdown output\n    var isMarkdown: Bool {\n        self == .markdown || self == .md\n    }\n\n    /// File extension for this format\n    var fileExtension: String {\n        isJson ? \"json\" : \"md\"\n    }\n}\n\n/// Output format for thread display commands.\n/// Supports text (human-readable), JSON (for scripting), and Markdown (for documentation).\npublic enum ThreadOutputFormat: String, CaseIterable, ExpressibleByArgument {\n    case text\n    case json\n    case markdown\n    case md\n\n    /// All valid format values for help text\n    public static var allValueStrings: [String] {\n        allCases.map { $0.rawValue }\n    }\n\n    /// Check if this format produces JSON output\n    var isJson: Bool {\n        self == .json\n    }\n\n    /// Check if this format produces Markdown output\n    var isMarkdown: Bool {\n        self == .markdown || self == .md\n    }\n\n    /// Check if this format produces plain text output\n    var isText: Bool {\n        self == .text\n    }\n}\n\n/// Sort options for thread listing commands.\n/// Allows sorting threads by date, subject, or message count.\npublic enum ThreadSortOption: String, CaseIterable, ExpressibleByArgument {\n    case date\n    case subject\n    case messageCount = \"message_count\"\n\n    /// All valid sort values for help text\n    public static var allValueStrings: [String] {\n        allCases.map { $0.rawValue }\n    }\n\n    /// Convert to database sort order enum\n    func toDbSortOrder() -> ThreadSortOrder {\n        switch self {\n        case .date:\n            return .date\n        case .subject:\n            return .subject\n        case .messageCount:\n            return .messageCount\n        }\n    }\n}\n\nstruct MailExportCommand: ParsableCommand {\n    static let configuration = CommandConfiguration(\n        commandName: \"export\",\n        abstract: \"Export synced messages to markdown or JSON files\",\n        discussion: \"\"\"\n            Creates .md or .json files from synced messages. Note: 'swea mail sync'\n            now auto-exports new messages, so manual export is usually not needed.\n\n            Default output: Swiftea/Mail/ (same as auto-export)\n            Markdown files include YAML frontmatter for Obsidian compatibility.\n\n            EXAMPLES\n              swea mail export                              # Export all (up to limit)\n              swea mail export --query \"from:alice\"         # Export matching messages\n              swea mail export --output ~/Obsidian/Mail     # Export to custom folder\n              swea mail export --format json                # Export as JSON\n              swea mail export --include-attachments        # Also save attachments\n\n            Use --include-attachments to also extract and save attachment files.\n            Attachments are saved in an 'attachments/<message-id>/' subdirectory.\n\n            THREAD EXPORT\n              swea mail export --format json --thread <thread-id>   # Export full thread structure\n\n            Thread exports include a nested messages array with thread_position for each message.\n            \"\"\"\n    )\n\n    @Option(name: .long, help: \"Export format: \\(OutputFormat.allValueStrings.joined(separator: \", \"))\")\n    var format: OutputFormat = .markdown\n\n    @Option(name: .long, help: \"Message ID to export (or 'all' for all synced messages)\")\n    var id: String = \"all\"\n\n    @Option(name: .shortAndLong, help: \"Output directory (default: Swiftea/Mail/)\")\n    var output: String?\n\n    @Option(name: .long, help: \"Search query to filter messages for export\")\n    var query: String?\n\n    @Option(name: .long, help: \"Maximum messages to export (default: 100)\")\n    var limit: Int = 100\n\n    @Flag(name: .long, help: \"Extract and save attachment files\")\n    var includeAttachments: Bool = false\n\n    @Option(name: .long, help: \"Thread ID to export as full thread structure (JSON only)\")\n    var thread: String?\n\n    func validate() throws {\n        // --limit must be a positive integer\n        if limit <= 0 {\n            throw MailValidationError.invalidLimit\n        }\n        // --thread requires --format json\n        if thread != nil && !format.isJson {\n            throw ValidationError(\"--thread requires --format json\")\n        }\n        // Note: --format validation is handled automatically by ArgumentParser via OutputFormat enum\n    }\n\n    func run() throws {\n        let vault = try VaultContext.require()\n\n        // Determine output directory (default: Swiftea/Mail/ for Obsidian compatibility)\n        let outputDir: String\n        if let specifiedOutput = output {\n            outputDir = specifiedOutput\n        } else {\n            outputDir = (vault.dataFolderPath as NSString).appendingPathComponent(\"Mail\")\n        }\n\n        // Create output directory if needed\n        let fileManager = FileManager.default\n        if !fileManager.fileExists(atPath: outputDir) {\n            try fileManager.createDirectory(atPath: outputDir, withIntermediateDirectories: true)\n        }\n\n        // Open mail database\n        let mailDbPath = (vault.dataFolderPath as NSString).appendingPathComponent(\"mail.db\")\n        let mailDatabase = MailDatabase(databasePath: mailDbPath)\n        try mailDatabase.initialize()\n        defer { mailDatabase.close() }\n\n        // Handle thread export mode\n        if let threadId = thread {\n            try exportThread(threadId: threadId, outputDir: outputDir, database: mailDatabase)\n            return\n        }\n\n        // Get messages to export\n        var messages: [MailMessage] = []\n\n        if id != \"all\" {\n            // Export single message\n            if let message = try mailDatabase.getMessage(id: id) {\n                messages = [message]\n            } else {\n                printError(\"Message not found: \\(id)\")\n                throw ExitCode.failure\n            }\n        } else if let searchQuery = query {\n            // Export messages matching query\n            messages = try mailDatabase.searchMessages(query: searchQuery, limit: limit)\n        } else {\n            // Export all messages (up to limit) - use direct query without FTS\n            messages = try mailDatabase.getAllMessages(limit: limit)\n        }\n\n        if messages.isEmpty {\n            printError(\"No messages to export\")\n            return\n        }\n\n        print(\"Exporting \\(messages.count) message(s) to \\(outputDir)...\")\n\n        var exportedCount = 0\n        var attachmentCount = 0\n        let emlxParser = EmlxParser()\n\n        for message in messages {\n            let filename = generateFilename(for: message)\n            let filePath = (outputDir as NSString).appendingPathComponent(filename)\n\n            let content: String\n            if format.isJson {\n                content = formatAsJson(message)\n            } else {\n                content = formatAsMarkdown(message)\n            }\n\n            try content.write(toFile: filePath, atomically: true, encoding: .utf8)\n\n            // Update export path in database\n            try mailDatabase.updateExportPath(id: message.id, path: filePath)\n            exportedCount += 1\n\n            // Extract attachments if requested\n            if includeAttachments, message.hasAttachments, let emlxPath = message.emlxPath {\n                // Skip EWS/Exchange messages (no local .emlx file)\n                if emlxPath.contains(\"ews:\") || emlxPath.contains(\"/ews:/\") {\n                    continue\n                }\n\n                let attachmentsDir = (outputDir as NSString).appendingPathComponent(\"attachments/\\(message.id)\")\n\n                do {\n                    let attachments = try emlxParser.extractAttachments(path: emlxPath)\n\n                    if !attachments.isEmpty {\n                        // Create attachments directory\n                        if !fileManager.fileExists(atPath: attachmentsDir) {\n                            try fileManager.createDirectory(atPath: attachmentsDir, withIntermediateDirectories: true)\n                        }\n\n                        for attachment in attachments {\n                            let attachmentPath = (attachmentsDir as NSString).appendingPathComponent(attachment.info.filename)\n                            try attachment.data.write(to: URL(fileURLWithPath: attachmentPath))\n                            attachmentCount += 1\n                        }\n                    }\n                } catch {\n                    // Log warning but continue exporting\n                    printError(\"  Warning: Could not extract attachments from \\(message.id): \\(error.localizedDescription)\")\n                }\n            }\n        }\n\n        print(\"Exported \\(exportedCount) message(s) to \\(outputDir)\")\n        if attachmentCount > 0 {\n            print(\"Extracted \\(attachmentCount) attachment(s)\")\n        }\n    }\n\n    private func generateFilename(for message: MailMessage) -> String {\n        // Flat filename using message ID for uniqueness and idempotent overwrites\n        return \"\\(message.id).\\(format.fileExtension)\"\n    }\n\n    private func formatAsMarkdown(_ message: MailMessage) -> String {\n        var lines: [String] = []\n\n        // Minimal YAML frontmatter: id, subject, from, date, aliases\n        lines.append(\"---\")\n        lines.append(\"id: \\\"\\(message.id)\\\"\")\n        lines.append(\"subject: \\\"\\(escapeYaml(message.subject))\\\"\")\n        lines.append(\"from: \\\"\\(escapeYaml(formatSender(message)))\\\"\")\n        if let date = message.dateSent {\n            lines.append(\"date: \\(date.iso8601String)\")\n        }\n        // aliases: use subject as an alias for linking by topic\n        lines.append(\"aliases:\")\n        lines.append(\"  - \\\"\\(escapeYaml(message.subject))\\\"\")\n        lines.append(\"---\")\n        lines.append(\"\")\n\n        // Subject as heading\n        lines.append(\"# \\(message.subject)\")\n        lines.append(\"\")\n\n        // Body content\n        if let textBody = message.bodyText, !textBody.isEmpty {\n            lines.append(textBody)\n        } else if let htmlBody = message.bodyHtml {\n            // Fall back to stripped HTML\n            lines.append(stripHtml(htmlBody))\n        } else {\n            lines.append(\"*(No message body)*\")\n        }\n\n        return lines.joined(separator: \"\\n\")\n    }\n\n    private func formatAsJson(_ message: MailMessage, threadPosition: Int? = nil, threadTotal: Int? = nil) -> String {\n        var output: [String: Any] = [\n            \"id\": message.id,\n            \"messageId\": message.messageId ?? \"\",\n            \"subject\": message.subject,\n            \"from\": [\n                \"name\": message.senderName ?? \"\",\n                \"email\": message.senderEmail ?? \"\"\n            ],\n            \"date\": message.dateSent?.iso8601String ?? \"\",\n            \"mailbox\": message.mailboxName ?? \"\",\n            \"isRead\": message.isRead,\n            \"isFlagged\": message.isFlagged,\n            \"hasAttachments\": message.hasAttachments,\n            \"bodyText\": message.bodyText ?? \"\",\n            \"bodyHtml\": message.bodyHtml ?? \"\"\n        ]\n\n        // Add thread fields if available\n        if let threadId = message.threadId {\n            output[\"thread_id\"] = threadId\n        }\n        if let position = threadPosition {\n            output[\"thread_position\"] = position\n        }\n        if let total = threadTotal {\n            output[\"thread_total\"] = total\n        }\n\n        if let data = try? JSONSerialization.data(withJSONObject: output, options: [.prettyPrinted, .sortedKeys]),\n           let jsonString = String(data: data, encoding: .utf8) {\n            return jsonString\n        }\n        return \"{}\"\n    }\n\n    /// Convert a MailMessage to a dictionary for JSON serialization (used in thread exports)\n    private func messageToDict(_ message: MailMessage, threadPosition: Int, threadTotal: Int) -> [String: Any] {\n        return [\n            \"id\": message.id,\n            \"messageId\": message.messageId ?? \"\",\n            \"subject\": message.subject,\n            \"from\": [\n                \"name\": message.senderName ?? \"\",\n                \"email\": message.senderEmail ?? \"\"\n            ],\n            \"date\": message.dateSent?.iso8601String ?? \"\",\n            \"mailbox\": message.mailboxName ?? \"\",\n            \"isRead\": message.isRead,\n            \"isFlagged\": message.isFlagged,\n            \"hasAttachments\": message.hasAttachments,\n            \"bodyText\": message.bodyText ?? \"\",\n            \"bodyHtml\": message.bodyHtml ?? \"\",\n            \"thread_id\": message.threadId ?? \"\",\n            \"thread_position\": threadPosition,\n            \"thread_total\": threadTotal\n        ]\n    }\n\n    /// Export a thread with full structure including nested messages array\n    private func exportThread(threadId: String, outputDir: String, database: MailDatabase) throws {\n        // Get thread metadata\n        guard let thread = try database.getThread(id: threadId) else {\n            printError(\"Thread not found: \\(threadId)\")\n            throw ExitCode.failure\n        }\n\n        // Get all messages in the thread, sorted by date\n        let messages = try database.getMessagesInThreadViaJunction(threadId: threadId, limit: 10000)\n\n        if messages.isEmpty {\n            printError(\"Thread has no messages: \\(threadId)\")\n            throw ExitCode.failure\n        }\n\n        let threadTotal = messages.count\n\n        // Build nested messages array with thread position\n        var messagesArray: [[String: Any]] = []\n        for (index, message) in messages.enumerated() {\n            let position = index + 1  // 1-indexed position\n            messagesArray.append(messageToDict(message, threadPosition: position, threadTotal: threadTotal))\n        }\n\n        // Build thread export structure\n        let threadExport: [String: Any] = [\n            \"thread_id\": threadId,\n            \"subject\": thread.subject ?? \"\",\n            \"participant_count\": thread.participantCount,\n            \"message_count\": thread.messageCount,\n            \"first_date\": thread.firstDate?.iso8601String ?? \"\",\n            \"last_date\": thread.lastDate?.iso8601String ?? \"\",\n            \"messages\": messagesArray\n        ]\n\n        // Write to file\n        let filename = \"thread-\\(threadId).json\"\n        let filePath = (outputDir as NSString).appendingPathComponent(filename)\n\n        if let data = try? JSONSerialization.data(withJSONObject: threadExport, options: [.prettyPrinted, .sortedKeys]),\n           let jsonString = String(data: data, encoding: .utf8) {\n            try jsonString.write(toFile: filePath, atomically: true, encoding: .utf8)\n            print(\"Exported thread with \\(threadTotal) message(s) to \\(filePath)\")\n        } else {\n            printError(\"Failed to serialize thread to JSON\")\n            throw ExitCode.failure\n        }\n    }\n\n    private func formatSender(_ message: MailMessage) -> String {\n        if let name = message.senderName, let email = message.senderEmail {\n            return \"\\(name) <\\(email)>\"\n        } else if let email = message.senderEmail {\n            return email\n        } else if let name = message.senderName {\n            return name\n        }\n        return \"Unknown\"\n    }\n\n    private func escapeYaml(_ text: String) -> String {\n        text.replacingOccurrences(of: \"\\\"\", with: \"\\\\\\\"\")\n    }\n\n    private func stripHtml(_ html: String) -> String {\n        var result = html\n        result = result.replacingOccurrences(of: \"<script[^>]*>.*?</script>\", with: \"\", options: .regularExpression)\n        result = result.replacingOccurrences(of: \"<style[^>]*>.*?</style>\", with: \"\", options: .regularExpression)\n        result = result.replacingOccurrences(of: \"&nbsp;\", with: \" \")\n        result = result.replacingOccurrences(of: \"&amp;\", with: \"&\")\n        result = result.replacingOccurrences(of: \"&lt;\", with: \"<\")\n        result = result.replacingOccurrences(of: \"&gt;\", with: \">\")\n        result = result.replacingOccurrences(of: \"&quot;\", with: \"\\\"\")\n        result = result.replacingOccurrences(of: \"<br[^>]*>\", with: \"\\n\", options: .regularExpression)\n        result = result.replacingOccurrences(of: \"</p>\", with: \"\\n\\n\")\n        result = result.replacingOccurrences(of: \"<[^>]+>\", with: \"\", options: .regularExpression)\n        result = result.replacingOccurrences(of: \"\\n{3,}\", with: \"\\n\\n\", options: .regularExpression)\n        return result.trimmingCharacters(in: .whitespacesAndNewlines)\n    }\n}\n\n// MARK: - Mail Export Threads Command\n\nstruct MailExportThreadsCommand: ParsableCommand {\n    static let configuration = CommandConfiguration(\n        commandName: \"export-threads\",\n        abstract: \"Export entire email threads as single units\",\n        discussion: \"\"\"\n            Exports complete email threads (conversations) to markdown or JSON files.\n            Each thread is exported as a single file containing all messages in the\n            conversation, ordered chronologically.\n\n            EXAMPLES\n              swea mail export-threads                          # Export all threads (up to limit)\n              swea mail export-threads --thread-id abc123       # Export specific thread\n              swea mail export-threads --format json            # Export as JSON\n              swea mail export-threads --output ~/Threads       # Export to custom folder\n              swea mail export-threads --limit 50               # Export up to 50 threads\n            \"\"\"\n    )\n\n    @Option(name: .long, help: \"Export format: \\(OutputFormat.allValueStrings.joined(separator: \", \"))\")\n    var format: OutputFormat = .markdown\n\n    @Option(name: .long, help: \"Specific thread ID to export\")\n    var threadId: String?\n\n    @Option(name: .shortAndLong, help: \"Output directory (default: Swiftea/Threads/)\")\n    var output: String?\n\n    @Option(name: .long, help: \"Maximum threads to export (default: 100)\")\n    var limit: Int = 100\n\n    func validate() throws {\n        if limit <= 0 {\n            throw MailValidationError.invalidLimit\n        }\n    }\n\n    func run() throws {\n        let vault = try VaultContext.require()\n\n        // Determine output directory (default: Swiftea/Threads/)\n        let outputDir: String\n        if let specifiedOutput = output {\n            outputDir = specifiedOutput\n        } else {\n            outputDir = (vault.dataFolderPath as NSString).appendingPathComponent(\"Threads\")\n        }\n\n        // Create output directory if needed\n        let fileManager = FileManager.default\n        if !fileManager.fileExists(atPath: outputDir) {\n            try fileManager.createDirectory(atPath: outputDir, withIntermediateDirectories: true)\n        }\n\n        // Open mail database\n        let mailDbPath = (vault.dataFolderPath as NSString).appendingPathComponent(\"mail.db\")\n        let mailDatabase = MailDatabase(databasePath: mailDbPath)\n        try mailDatabase.initialize()\n        defer { mailDatabase.close() }\n\n        // Get threads to export - handle single thread vs all threads differently\n        // to avoid type annotation issues with Thread shadowing\n        if let specificThreadId = threadId {\n            // Export single thread\n            guard let thread = try mailDatabase.getThread(id: specificThreadId) else {\n                printError(\"Thread not found: \\(specificThreadId)\")\n                throw ExitCode.failure\n            }\n\n            let filename = \"thread-\\(thread.id).\\(format.fileExtension)\"\n            let filePath = (outputDir as NSString).appendingPathComponent(filename)\n            let messages = try mailDatabase.getMessagesInThreadViaJunction(threadId: thread.id, limit: 10000)\n\n            let content: String\n            if format.isJson {\n                content = formatThreadAsJson(threadId: thread.id, subject: thread.subject, participantCount: thread.participantCount, messageCount: thread.messageCount, firstDate: thread.firstDate, lastDate: thread.lastDate, messages: messages)\n            } else {\n                content = formatThreadAsMarkdown(threadId: thread.id, subject: thread.subject, participantCount: thread.participantCount, messageCount: thread.messageCount, firstDate: thread.firstDate, lastDate: thread.lastDate, messages: messages)\n            }\n\n            try content.write(toFile: filePath, atomically: true, encoding: .utf8)\n            print(\"Exported 1 thread to \\(outputDir)\")\n            return\n        }\n\n        // Export all threads (up to limit)\n        let threads = try mailDatabase.getThreads(limit: limit)\n\n        if threads.isEmpty {\n            printError(\"No threads to export\")\n            return\n        }\n\n        print(\"Exporting \\(threads.count) thread(s) to \\(outputDir)...\")\n\n        var exportedCount = 0\n\n        for thread in threads {\n            let filename = \"thread-\\(thread.id).\\(format.fileExtension)\"\n            let filePath = (outputDir as NSString).appendingPathComponent(filename)\n\n            // Get all messages in the thread, sorted by date\n            let messages = try mailDatabase.getMessagesInThreadViaJunction(threadId: thread.id, limit: 10000)\n\n            let content: String\n            if format.isJson {\n                content = formatThreadAsJson(threadId: thread.id, subject: thread.subject, participantCount: thread.participantCount, messageCount: thread.messageCount, firstDate: thread.firstDate, lastDate: thread.lastDate, messages: messages)\n            } else {\n                content = formatThreadAsMarkdown(threadId: thread.id, subject: thread.subject, participantCount: thread.participantCount, messageCount: thread.messageCount, firstDate: thread.firstDate, lastDate: thread.lastDate, messages: messages)\n            }\n\n            try content.write(toFile: filePath, atomically: true, encoding: .utf8)\n            exportedCount += 1\n        }\n\n        print(\"Exported \\(exportedCount) thread(s) to \\(outputDir)\")\n    }\n\n    private func formatThreadAsJson(threadId: String, subject: String?, participantCount: Int, messageCount: Int, firstDate: Date?, lastDate: Date?, messages: [MailMessage]) -> String {\n        let threadTotal = messages.count\n\n        // Build nested messages array with thread position\n        var messagesArray: [[String: Any]] = []\n        for (index, message) in messages.enumerated() {\n            let position = index + 1  // 1-indexed position\n            messagesArray.append(messageToDict(message, threadPosition: position, threadTotal: threadTotal))\n        }\n\n        // Build thread export structure\n        let threadExport: [String: Any] = [\n            \"thread_id\": threadId,\n            \"subject\": subject ?? \"\",\n            \"participant_count\": participantCount,\n            \"message_count\": messageCount,\n            \"first_date\": firstDate?.iso8601String ?? \"\",\n            \"last_date\": lastDate?.iso8601String ?? \"\",\n            \"messages\": messagesArray\n        ]\n\n        if let data = try? JSONSerialization.data(withJSONObject: threadExport, options: [.prettyPrinted, .sortedKeys]),\n           let jsonString = String(data: data, encoding: .utf8) {\n            return jsonString\n        }\n        return \"{}\"\n    }\n\n    private func formatThreadAsMarkdown(threadId: String, subject: String?, participantCount: Int, messageCount: Int, firstDate: Date?, lastDate: Date?, messages: [MailMessage]) -> String {\n        var lines: [String] = []\n        let threadTotal = messages.count\n\n        // YAML frontmatter with thread metadata\n        lines.append(\"---\")\n        lines.append(\"thread_id: \\\"\\(threadId)\\\"\")\n        lines.append(\"subject: \\\"\\(escapeYaml(subject ?? \"\"))\\\"\")\n        lines.append(\"participant_count: \\(participantCount)\")\n        lines.append(\"message_count: \\(messageCount)\")\n        if let firstDate = firstDate {\n            lines.append(\"first_date: \\(firstDate.iso8601String)\")\n        }\n        if let lastDate = lastDate {\n            lines.append(\"last_date: \\(lastDate.iso8601String)\")\n        }\n        lines.append(\"---\")\n        lines.append(\"\")\n\n        // Thread heading\n        lines.append(\"# Thread: \\(subject ?? \"(No Subject)\")\")\n        lines.append(\"\")\n        lines.append(\"**\\(threadTotal) message(s) between \\(participantCount) participant(s)**\")\n        lines.append(\"\")\n\n        // Each message in the thread\n        for (index, message) in messages.enumerated() {\n            let position = index + 1\n            lines.append(\"---\")\n            lines.append(\"\")\n            lines.append(\"## Message \\(position) of \\(threadTotal)\")\n            lines.append(\"\")\n            lines.append(\"**From:** \\(formatSender(message))\")\n            if let date = message.dateSent {\n                lines.append(\"**Date:** \\(date.iso8601String)\")\n            }\n            lines.append(\"**Subject:** \\(message.subject)\")\n            lines.append(\"\")\n\n            // Body content\n            if let textBody = message.bodyText, !textBody.isEmpty {\n                lines.append(textBody)\n            } else if let htmlBody = message.bodyHtml {\n                lines.append(stripHtml(htmlBody))\n            } else {\n                lines.append(\"*(No message body)*\")\n            }\n            lines.append(\"\")\n        }\n\n        return lines.joined(separator: \"\\n\")\n    }\n\n    private func messageToDict(_ message: MailMessage, threadPosition: Int, threadTotal: Int) -> [String: Any] {\n        return [\n            \"id\": message.id,\n            \"messageId\": message.messageId ?? \"\",\n            \"subject\": message.subject,\n            \"from\": [\n                \"name\": message.senderName ?? \"\",\n                \"email\": message.senderEmail ?? \"\"\n            ],\n            \"date\": message.dateSent?.iso8601String ?? \"\",\n            \"mailbox\": message.mailboxName ?? \"\",\n            \"isRead\": message.isRead,\n            \"isFlagged\": message.isFlagged,\n            \"hasAttachments\": message.hasAttachments,\n            \"bodyText\": message.bodyText ?? \"\",\n            \"bodyHtml\": message.bodyHtml ?? \"\",\n            \"thread_id\": message.threadId ?? \"\",\n            \"thread_position\": threadPosition,\n            \"thread_total\": threadTotal\n        ]\n    }\n\n    private func formatSender(_ message: MailMessage) -> String {\n        if let name = message.senderName, let email = message.senderEmail {\n            return \"\\(name) <\\(email)>\"\n        } else if let email = message.senderEmail {\n            return email\n        } else if let name = message.senderName {\n            return name\n        }\n        return \"Unknown\"\n    }\n\n    private func escapeYaml(_ text: String) -> String {\n        text.replacingOccurrences(of: \"\\\"\", with: \"\\\\\\\"\")\n    }\n\n    private func stripHtml(_ html: String) -> String {\n        var result = html\n        result = result.replacingOccurrences(of: \"<script[^>]*>.*?</script>\", with: \"\", options: .regularExpression)\n        result = result.replacingOccurrences(of: \"<style[^>]*>.*?</style>\", with: \"\", options: .regularExpression)\n        result = result.replacingOccurrences(of: \"&nbsp;\", with: \" \")\n        result = result.replacingOccurrences(of: \"&amp;\", with: \"&\")\n        result = result.replacingOccurrences(of: \"&lt;\", with: \"<\")\n        result = result.replacingOccurrences(of: \"&gt;\", with: \">\")\n        result = result.replacingOccurrences(of: \"&quot;\", with: \"\\\"\")\n        result = result.replacingOccurrences(of: \"<br[^>]*>\", with: \"\\n\", options: .regularExpression)\n        result = result.replacingOccurrences(of: \"</p>\", with: \"\\n\\n\")\n        result = result.replacingOccurrences(of: \"<[^>]+>\", with: \"\", options: .regularExpression)\n        result = result.replacingOccurrences(of: \"\\n{3,}\", with: \"\\n\\n\", options: .regularExpression)\n        return result.trimmingCharacters(in: .whitespacesAndNewlines)\n    }\n}\n\n// MARK: - Mail Validation Errors\n\n/// Error thrown when CLI input validation fails\npublic enum MailValidationError: Error, LocalizedError, Equatable {\n    case invalidLimit\n    case emptyRecipient\n    case watchAndStopMutuallyExclusive\n    case invalidInterval(minimum: Int)\n    case invalidStatus(value: String)\n\n    public var errorDescription: String? {\n        switch self {\n        case .invalidLimit:\n            return \"--limit must be a positive integer\"\n        case .emptyRecipient:\n            return \"--to requires a non-empty email address\"\n        case .watchAndStopMutuallyExclusive:\n            return \"--watch and --stop cannot be used together\"\n        case .invalidInterval(let minimum):\n            return \"--interval must be at least \\(minimum) seconds\"\n        case .invalidStatus(let value):\n            return \"Invalid status '\\(value)'. Valid options: inbox, archived, deleted\"\n        }\n    }\n}\n\n// MARK: - Mail Action Commands\n\n/// Error thrown when action validation fails\nenum MailActionError: Error, LocalizedError {\n    case messageNotFound(String)\n    case mailboxRequired\n    case confirmationRequired(action: String)\n    case invalidFlagOperation\n    case invalidMarkOperation\n\n    var errorDescription: String? {\n        switch self {\n        case .messageNotFound(let id):\n            return \"Message not found: \\(id)\"\n        case .mailboxRequired:\n            return \"Target mailbox is required. Use --mailbox to specify destination.\"\n        case .confirmationRequired(let action):\n            return \"Destructive action '\\(action)' requires --yes to confirm or --dry-run to preview.\"\n        case .invalidFlagOperation:\n            return \"Specify either --set or --clear for flag operation.\"\n        case .invalidMarkOperation:\n            return \"Specify either --read or --unread for mark operation.\"\n        }\n    }\n}\n\nstruct MailArchiveCommand: ParsableCommand {\n    static let configuration = CommandConfiguration(\n        commandName: \"archive\",\n        abstract: \"Archive a mail message\",\n        discussion: \"\"\"\n            Moves the specified message to the Archive mailbox in Mail.app.\n\n            DESTRUCTIVE ACTION: This command modifies your mailbox.\n            Use --dry-run to preview the action without making changes.\n            Use --yes to confirm the action.\n            \"\"\"\n    )\n\n    @Option(name: .long, help: \"Message ID to archive (required)\")\n    var id: String\n\n    @Flag(name: .long, help: \"Confirm the destructive action\")\n    var yes: Bool = false\n\n    @Flag(name: .long, help: \"Preview the action without making changes\")\n    var dryRun: Bool = false\n\n    func validate() throws {\n        // Validate that either --yes or --dry-run is provided\n        if !yes && !dryRun {\n            throw MailActionError.confirmationRequired(action: \"archive\")\n        }\n    }\n\n    func run() throws {\n        let vault = try VaultContext.require()\n\n        // Open mail database\n        let mailDbPath = (vault.dataFolderPath as NSString).appendingPathComponent(\"mail.db\")\n        let mailDatabase = MailDatabase(databasePath: mailDbPath)\n        try mailDatabase.initialize()\n        defer { mailDatabase.close() }\n\n        // Resolve message to Mail.app reference\n        let resolver = MessageResolver(database: mailDatabase)\n        let resolved = try resolver.resolve(id: id)\n\n        if dryRun {\n            print(\"[DRY RUN] Would archive message:\")\n            print(\"  ID: \\(resolved.swiftEAId)\")\n            print(\"  Message-ID: \\(resolved.messageId)\")\n            print(\"  Subject: \\(resolved.message.subject)\")\n            print(\"  From: \\(resolved.message.senderEmail ?? \"Unknown\")\")\n            print(\"  Current mailbox: \\(resolved.message.mailboxName ?? \"Unknown\")\")\n            return\n        }\n\n        // Use MailSyncBackward for optimistic update pattern\n        let backwardSync = MailSyncBackward(mailDatabase: mailDatabase)\n        try backwardSync.archiveMessage(id: resolved.swiftEAId)\n\n        print(\"Archived message: \\(resolved.swiftEAId)\")\n        print(\"  Subject: \\(resolved.message.subject)\")\n    }\n}\n\nstruct MailDeleteCommand: ParsableCommand {\n    static let configuration = CommandConfiguration(\n        commandName: \"delete\",\n        abstract: \"Delete a mail message\",\n        discussion: \"\"\"\n            Moves the specified message to the Trash mailbox in Mail.app.\n\n            DESTRUCTIVE ACTION: This command modifies your mailbox.\n            Use --dry-run to preview the action without making changes.\n            Use --yes to confirm the action.\n            \"\"\"\n    )\n\n    @Option(name: .long, help: \"Message ID to delete (required)\")\n    var id: String\n\n    @Flag(name: .long, help: \"Confirm the destructive action\")\n    var yes: Bool = false\n\n    @Flag(name: .long, help: \"Preview the action without making changes\")\n    var dryRun: Bool = false\n\n    func validate() throws {\n        // Validate that either --yes or --dry-run is provided\n        if !yes && !dryRun {\n            throw MailActionError.confirmationRequired(action: \"delete\")\n        }\n    }\n\n    func run() throws {\n        let vault = try VaultContext.require()\n\n        // Open mail database\n        let mailDbPath = (vault.dataFolderPath as NSString).appendingPathComponent(\"mail.db\")\n        let mailDatabase = MailDatabase(databasePath: mailDbPath)\n        try mailDatabase.initialize()\n        defer { mailDatabase.close() }\n\n        // Resolve message to Mail.app reference\n        let resolver = MessageResolver(database: mailDatabase)\n        let resolved = try resolver.resolve(id: id)\n\n        if dryRun {\n            print(\"[DRY RUN] Would delete message:\")\n            print(\"  ID: \\(resolved.swiftEAId)\")\n            print(\"  Message-ID: \\(resolved.messageId)\")\n            print(\"  Subject: \\(resolved.message.subject)\")\n            print(\"  From: \\(resolved.message.senderEmail ?? \"Unknown\")\")\n            print(\"  Current mailbox: \\(resolved.message.mailboxName ?? \"Unknown\")\")\n            return\n        }\n\n        // Use MailSyncBackward for optimistic update pattern\n        let backwardSync = MailSyncBackward(mailDatabase: mailDatabase)\n        try backwardSync.deleteMessage(id: resolved.swiftEAId)\n\n        print(\"Deleted message: \\(resolved.swiftEAId)\")\n        print(\"  Subject: \\(resolved.message.subject)\")\n    }\n}\n\nstruct MailMoveCommand: ParsableCommand {\n    static let configuration = CommandConfiguration(\n        commandName: \"move\",\n        abstract: \"Move a mail message to a different mailbox\",\n        discussion: \"\"\"\n            Moves the specified message to the target mailbox in Mail.app.\n\n            DESTRUCTIVE ACTION: This command modifies your mailbox.\n            Use --dry-run to preview the action without making changes.\n            Use --yes to confirm the action.\n            \"\"\"\n    )\n\n    @Option(name: .long, help: \"Message ID to move (required)\")\n    var id: String\n\n    @Option(name: .long, help: \"Target mailbox name (required)\")\n    var mailbox: String?\n\n    @Flag(name: .long, help: \"Confirm the destructive action\")\n    var yes: Bool = false\n\n    @Flag(name: .long, help: \"Preview the action without making changes\")\n    var dryRun: Bool = false\n\n    func validate() throws {\n        // Validate mailbox is provided\n        guard mailbox != nil else {\n            throw MailActionError.mailboxRequired\n        }\n\n        // Validate that either --yes or --dry-run is provided\n        if !yes && !dryRun {\n            throw MailActionError.confirmationRequired(action: \"move\")\n        }\n    }\n\n    func run() throws {\n        let vault = try VaultContext.require()\n\n        // Open mail database\n        let mailDbPath = (vault.dataFolderPath as NSString).appendingPathComponent(\"mail.db\")\n        let mailDatabase = MailDatabase(databasePath: mailDbPath)\n        try mailDatabase.initialize()\n        defer { mailDatabase.close() }\n\n        // Resolve message to Mail.app reference\n        let resolver = MessageResolver(database: mailDatabase)\n        let resolved = try resolver.resolve(id: id)\n\n        let targetMailbox = mailbox!\n\n        if dryRun {\n            print(\"[DRY RUN] Would move message:\")\n            print(\"  ID: \\(resolved.swiftEAId)\")\n            print(\"  Message-ID: \\(resolved.messageId)\")\n            print(\"  Subject: \\(resolved.message.subject)\")\n            print(\"  From: \\(resolved.message.senderEmail ?? \"Unknown\")\")\n            print(\"  Current mailbox: \\(resolved.message.mailboxName ?? \"Unknown\")\")\n            print(\"  Target mailbox: \\(targetMailbox)\")\n            return\n        }\n\n        // Execute move via AppleScript\n        // Use the same account as the source message for the target mailbox\n        let script = MailActionScripts.moveMessage(byMessageId: resolved.messageId, toMailbox: targetMailbox)\n\n        let appleScriptService = AppleScriptService.shared\n        let result = try appleScriptService.executeMailScript(script)\n\n        if result.success {\n            print(\"Moved message: \\(resolved.swiftEAId)\")\n            print(\"  Subject: \\(resolved.message.subject)\")\n            print(\"  To mailbox: \\(targetMailbox)\")\n        }\n    }\n}\n\nstruct MailFlagCommand: ParsableCommand {\n    static let configuration = CommandConfiguration(\n        commandName: \"flag\",\n        abstract: \"Set or clear the flag on a mail message\",\n        discussion: \"\"\"\n            Sets or clears the flag (star) on the specified message in Mail.app.\n\n            Use --set to flag the message.\n            Use --clear to remove the flag.\n            Use --dry-run to preview the action without making changes.\n            \"\"\"\n    )\n\n    @Option(name: .long, help: \"Message ID to flag/unflag (required)\")\n    var id: String\n\n    @Flag(name: .long, help: \"Set the flag on the message\")\n    var set: Bool = false\n\n    @Flag(name: .long, help: \"Clear the flag from the message\")\n    var clear: Bool = false\n\n    @Flag(name: .long, help: \"Preview the action without making changes\")\n    var dryRun: Bool = false\n\n    func validate() throws {\n        // Exactly one of --set or --clear must be provided\n        if set == clear {\n            throw MailActionError.invalidFlagOperation\n        }\n    }\n\n    func run() throws {\n        let vault = try VaultContext.require()\n\n        // Open mail database\n        let mailDbPath = (vault.dataFolderPath as NSString).appendingPathComponent(\"mail.db\")\n        let mailDatabase = MailDatabase(databasePath: mailDbPath)\n        try mailDatabase.initialize()\n        defer { mailDatabase.close() }\n\n        // Resolve message to Mail.app reference\n        let resolver = MessageResolver(database: mailDatabase)\n        let resolved = try resolver.resolve(id: id)\n\n        let willFlag = set\n        let action = willFlag ? \"flag\" : \"unflag\"\n\n        if dryRun {\n            print(\"[DRY RUN] Would \\(action) message:\")\n            print(\"  ID: \\(resolved.swiftEAId)\")\n            print(\"  Message-ID: \\(resolved.messageId)\")\n            print(\"  Subject: \\(resolved.message.subject)\")\n            print(\"  Current flag status: \\(resolved.message.isFlagged ? \"flagged\" : \"not flagged\")\")\n            return\n        }\n\n        // Execute flag via AppleScript\n        let script = MailActionScripts.setFlag(byMessageId: resolved.messageId, flagged: willFlag)\n\n        let appleScriptService = AppleScriptService.shared\n        let result = try appleScriptService.executeMailScript(script)\n\n        if result.success {\n            print(\"\\(willFlag ? \"Flagged\" : \"Unflagged\") message: \\(resolved.swiftEAId)\")\n            print(\"  Subject: \\(resolved.message.subject)\")\n        }\n    }\n}\n\nstruct MailMarkCommand: ParsableCommand {\n    static let configuration = CommandConfiguration(\n        commandName: \"mark\",\n        abstract: \"Mark a mail message as read or unread\",\n        discussion: \"\"\"\n            Marks the specified message as read or unread in Mail.app.\n\n            Use --read to mark the message as read.\n            Use --unread to mark the message as unread.\n            Use --dry-run to preview the action without making changes.\n            \"\"\"\n    )\n\n    @Option(name: .long, help: \"Message ID to mark (required)\")\n    var id: String\n\n    @Flag(name: .long, help: \"Mark the message as read\")\n    var read: Bool = false\n\n    @Flag(name: .long, help: \"Mark the message as unread\")\n    var unread: Bool = false\n\n    @Flag(name: .long, help: \"Preview the action without making changes\")\n    var dryRun: Bool = false\n\n    func validate() throws {\n        // Exactly one of --read or --unread must be provided\n        if read == unread {\n            throw MailActionError.invalidMarkOperation\n        }\n    }\n\n    func run() throws {\n        let vault = try VaultContext.require()\n\n        // Open mail database\n        let mailDbPath = (vault.dataFolderPath as NSString).appendingPathComponent(\"mail.db\")\n        let mailDatabase = MailDatabase(databasePath: mailDbPath)\n        try mailDatabase.initialize()\n        defer { mailDatabase.close() }\n\n        // Resolve message to Mail.app reference\n        let resolver = MessageResolver(database: mailDatabase)\n        let resolved = try resolver.resolve(id: id)\n\n        let markAsRead = read\n        let action = markAsRead ? \"mark as read\" : \"mark as unread\"\n\n        if dryRun {\n            print(\"[DRY RUN] Would \\(action) message:\")\n            print(\"  ID: \\(resolved.swiftEAId)\")\n            print(\"  Message-ID: \\(resolved.messageId)\")\n            print(\"  Subject: \\(resolved.message.subject)\")\n            print(\"  Current status: \\(resolved.message.isRead ? \"read\" : \"unread\")\")\n            return\n        }\n\n        // Execute mark via AppleScript\n        let script = MailActionScripts.setReadStatus(byMessageId: resolved.messageId, read: markAsRead)\n\n        let appleScriptService = AppleScriptService.shared\n        let result = try appleScriptService.executeMailScript(script)\n\n        if result.success {\n            print(\"Marked message as \\(markAsRead ? \"read\" : \"unread\"): \\(resolved.swiftEAId)\")\n            print(\"  Subject: \\(resolved.message.subject)\")\n        }\n    }\n}\n\nstruct MailReplyCommand: ParsableCommand {\n    static let configuration = CommandConfiguration(\n        commandName: \"reply\",\n        abstract: \"Create a reply to a mail message\",\n        discussion: \"\"\"\n            Creates a reply draft for the specified message in Mail.app.\n\n            By default, opens the reply in Mail.app for editing.\n            Use --send to send the reply immediately (requires --body).\n            Use --dry-run to preview the action without making changes.\n\n            The reply will be addressed to the original sender and include\n            the original message as quoted text.\n            \"\"\"\n    )\n\n    @Option(name: .long, help: \"Message ID to reply to (required)\")\n    var id: String\n\n    @Option(name: .long, help: \"Reply body text (required if using --send)\")\n    var body: String?\n\n    @Flag(name: .long, help: \"Reply to all recipients\")\n    var all: Bool = false\n\n    @Flag(name: .long, help: \"Send the reply immediately instead of opening a draft\")\n    var send: Bool = false\n\n    @Flag(name: .long, help: \"Preview the action without making changes\")\n    var dryRun: Bool = false\n\n    func validate() throws {\n        // If --send is specified, --body is required\n        if send && body == nil {\n            throw ValidationError(\"--body is required when using --send\")\n        }\n    }\n\n    func run() throws {\n        let vault = try VaultContext.require()\n\n        // Open mail database\n        let mailDbPath = (vault.dataFolderPath as NSString).appendingPathComponent(\"mail.db\")\n        let mailDatabase = MailDatabase(databasePath: mailDbPath)\n        try mailDatabase.initialize()\n        defer { mailDatabase.close() }\n\n        // Resolve message to Mail.app reference\n        let resolver = MessageResolver(database: mailDatabase)\n        let resolved = try resolver.resolve(id: id)\n\n        let replyType = all ? \"reply all\" : \"reply\"\n\n        if dryRun {\n            print(\"[DRY RUN] Would create \\(replyType) to message:\")\n            print(\"  ID: \\(resolved.swiftEAId)\")\n            print(\"  Message-ID: \\(resolved.messageId)\")\n            print(\"  Subject: \\(resolved.message.subject)\")\n            print(\"  Original sender: \\(resolved.message.senderEmail ?? \"Unknown\")\")\n            if let replyBody = body {\n                let preview = replyBody.prefix(100)\n                print(\"  Body: \\(preview)\\(replyBody.count > 100 ? \"...\" : \"\")\")\n            }\n            print(\"  Mode: \\(send ? \"Send immediately\" : \"Open draft in Mail.app\")\")\n            return\n        }\n\n        // Execute reply via AppleScript\n        let script = MailActionScripts.createReply(\n            byMessageId: resolved.messageId,\n            replyToAll: all,\n            body: body,\n            send: send\n        )\n\n        let appleScriptService = AppleScriptService.shared\n        let result = try appleScriptService.executeMailScript(script)\n\n        if result.success {\n            if send {\n                print(\"Sent \\(replyType) to: \\(resolved.message.senderEmail ?? \"Unknown\")\")\n            } else {\n                print(\"Created \\(replyType) draft in Mail.app\")\n            }\n            print(\"  Original subject: \\(resolved.message.subject)\")\n        }\n    }\n}\n\nstruct MailComposeCommand: ParsableCommand {\n    static let configuration = CommandConfiguration(\n        commandName: \"compose\",\n        abstract: \"Compose a new mail message\",\n        discussion: \"\"\"\n            Creates a new email draft in Mail.app.\n\n            By default, opens the compose window in Mail.app for editing.\n            Use --send to send the message immediately.\n            Use --dry-run to preview the action without making changes.\n            \"\"\"\n    )\n\n    @Option(name: .long, help: \"Recipient email address (required)\")\n    var to: String\n\n    @Option(name: .long, help: \"Email subject (required)\")\n    var subject: String\n\n    @Option(name: .long, help: \"Email body text\")\n    var body: String?\n\n    @Option(name: .long, help: \"CC recipients (comma-separated)\")\n    var cc: String?\n\n    @Option(name: .long, help: \"BCC recipients (comma-separated)\")\n    var bcc: String?\n\n    @Flag(name: .long, help: \"Send the message immediately instead of opening a draft\")\n    var send: Bool = false\n\n    @Flag(name: .long, help: \"Preview the action without making changes\")\n    var dryRun: Bool = false\n\n    func validate() throws {\n        // --to requires a non-empty email address\n        if to.trimmingCharacters(in: .whitespaces).isEmpty {\n            throw MailValidationError.emptyRecipient\n        }\n    }\n\n    func run() throws {\n        _ = try VaultContext.require()\n\n        if dryRun {\n            print(\"[DRY RUN] Would compose new message:\")\n            print(\"  To: \\(to)\")\n            print(\"  Subject: \\(subject)\")\n            if let ccRecipients = cc {\n                print(\"  CC: \\(ccRecipients)\")\n            }\n            if let bccRecipients = bcc {\n                print(\"  BCC: \\(bccRecipients)\")\n            }\n            if let messageBody = body {\n                let preview = messageBody.prefix(100)\n                print(\"  Body: \\(preview)\\(messageBody.count > 100 ? \"...\" : \"\")\")\n            }\n            print(\"  Mode: \\(send ? \"Send immediately\" : \"Open draft in Mail.app\")\")\n            return\n        }\n\n        // Execute compose via AppleScript\n        let script = MailActionScripts.compose(\n            to: to,\n            subject: subject,\n            body: body,\n            cc: cc,\n            bcc: bcc,\n            send: send\n        )\n\n        let appleScriptService = AppleScriptService.shared\n        let result = try appleScriptService.executeMailScript(script)\n\n        if result.success {\n            if send {\n                print(\"Sent message to: \\(to)\")\n            } else {\n                print(\"Created draft in Mail.app\")\n            }\n            print(\"  Subject: \\(subject)\")\n        }\n    }\n}\n\n// MARK: - Database Migration Command\n\nstruct MailMigrateCommand: ParsableCommand {\n    static let configuration = CommandConfiguration(\n        commandName: \"migrate\",\n        abstract: \"Run database migrations to upgrade schema\",\n        discussion: \"\"\"\n            Upgrades the mail database schema to the latest version. This command\n            is idempotent and safe to run multiple times - it only applies migrations\n            that haven't been applied yet.\n\n            The migration system handles:\n            - Adding new columns to existing tables (thread support)\n            - Creating new tables (threads, thread_messages)\n            - Adding indexes for query optimization\n            - Empty databases (creates all tables from scratch)\n\n            THREADING MIGRATIONS\n            Migrations V3-V7 add email threading support:\n              V3: Threading headers (in_reply_to, references)\n              V4: Threads table and thread_id reference\n              V5: Thread-messages junction table\n              V6: Thread position metadata (position, total)\n              V7: Large inbox optimization indexes\n\n            EXAMPLES\n              swea mail migrate              # Apply pending migrations\n              swea mail migrate --status     # Show migration status\n              swea mail migrate --verbose    # Show detailed migration info\n            \"\"\"\n    )\n\n    @Flag(name: .long, help: \"Show current schema version and migration history\")\n    var status: Bool = false\n\n    @Flag(name: .long, help: \"Show detailed information about each migration\")\n    var verbose: Bool = false\n\n    @Flag(name: .long, help: \"Output as JSON\")\n    var json: Bool = false\n\n    @Option(name: .long, help: \"Path to database file (defaults to vault's mail.db)\")\n    var database: String?\n\n    func run() throws {\n        let dbPath: String\n\n        if let customPath = database {\n            dbPath = customPath\n        } else {\n            let vault = try VaultContext.require()\n            dbPath = (vault.dataFolderPath as NSString).appendingPathComponent(\"mail.db\")\n        }\n\n        // Check if database file exists (before migration)\n        let fileManager = FileManager.default\n        let dbExists = fileManager.fileExists(atPath: dbPath)\n\n        // Create database instance without initializing (to check pre-migration state)\n        let mailDatabase = MailDatabase(databasePath: dbPath)\n\n        if status {\n            try showStatus(mailDatabase: mailDatabase, dbPath: dbPath, dbExists: dbExists)\n            return\n        }\n\n        // Run migrations\n        try runMigrations(mailDatabase: mailDatabase, dbPath: dbPath, dbExists: dbExists)\n    }\n\n    private func showStatus(mailDatabase: MailDatabase, dbPath: String, dbExists: Bool) throws {\n        // Initialize database to run migrations and get status\n        try mailDatabase.initialize()\n        defer { mailDatabase.close() }\n\n        let currentVersion = try mailDatabase.getSchemaVersion()\n        let latestVersion = MailDatabase.currentSchemaVersion\n        let history = try mailDatabase.getMigrationHistory()\n\n        if json {\n            var result: [String: Any] = [\n                \"database_path\": dbPath,\n                \"current_version\": currentVersion,\n                \"latest_version\": latestVersion,\n                \"up_to_date\": currentVersion >= latestVersion,\n                \"pending_migrations\": max(0, latestVersion - currentVersion)\n            ]\n\n            var migrations: [[String: Any]] = []\n            for (version, appliedAt) in history {\n                var migration: [String: Any] = [\n                    \"version\": version,\n                    \"applied_at\": appliedAt\n                ]\n                if let description = MailDatabase.migrationDescriptions[version] {\n                    migration[\"description\"] = description\n                }\n                migrations.append(migration)\n            }\n            result[\"migrations\"] = migrations\n\n            if let jsonData = try? JSONSerialization.data(withJSONObject: result, options: .prettyPrinted),\n               let jsonString = String(data: jsonData, encoding: .utf8) {\n                print(jsonString)\n            }\n        } else {\n            print(\"Mail Database Schema Status\")\n            print(\"===========================\")\n            print(\"Database: \\(dbPath)\")\n            print(\"Current version: V\\(currentVersion)\")\n            print(\"Latest version:  V\\(latestVersion)\")\n\n            if currentVersion >= latestVersion {\n                print(\"\\nâœ“ Database is up to date\")\n            } else {\n                let pending = latestVersion - currentVersion\n                print(\"\\nâš  \\(pending) migration(s) pending\")\n            }\n\n            if verbose || !history.isEmpty {\n                print(\"\\nMigration History:\")\n                if history.isEmpty {\n                    print(\"  No migrations applied yet\")\n                } else {\n                    for (version, appliedAt) in history {\n                        let description = MailDatabase.migrationDescriptions[version] ?? \"Unknown\"\n                        print(\"  V\\(version): \\(appliedAt)\")\n                        if verbose {\n                            print(\"       \\(description)\")\n                        }\n                    }\n                }\n            }\n\n            if verbose {\n                print(\"\\nAll Migrations:\")\n                for version in 1...latestVersion {\n                    let description = MailDatabase.migrationDescriptions[version] ?? \"Unknown\"\n                    let applied = history.contains { $0.version == version }\n                    let status = applied ? \"âœ“\" : \"â—‹\"\n                    print(\"  \\(status) V\\(version): \\(description)\")\n                }\n            }\n\n            // Show table status\n            print(\"\\nTable Status:\")\n            let tables = [\"messages\", \"threads\", \"thread_messages\", \"recipients\", \"attachments\", \"mailboxes\"]\n            for table in tables {\n                let exists = try mailDatabase.tableExists(table)\n                let status = exists ? \"âœ“\" : \"â—‹\"\n                print(\"  \\(status) \\(table)\")\n                if verbose && exists {\n                    let columns = try mailDatabase.getTableColumns(table)\n                    print(\"       Columns: \\(columns.count)\")\n                }\n            }\n        }\n    }\n\n    private func runMigrations(mailDatabase: MailDatabase, dbPath: String, dbExists: Bool) throws {\n        // Get pre-migration version if database exists\n        var preMigrationVersion = 0\n        if dbExists {\n            // Temporarily initialize just to check version, then close\n            let tempDb = MailDatabase(databasePath: dbPath)\n            try tempDb.initialize()\n            preMigrationVersion = try tempDb.getSchemaVersion()\n            tempDb.close()\n        }\n\n        if verbose {\n            print(\"Database: \\(dbPath)\")\n            if dbExists {\n                print(\"Pre-migration version: V\\(preMigrationVersion)\")\n            } else {\n                print(\"Creating new database...\")\n            }\n        }\n\n        // Initialize database (this runs migrations)\n        try mailDatabase.initialize()\n        defer { mailDatabase.close() }\n\n        let postMigrationVersion = try mailDatabase.getSchemaVersion()\n        let migrationsApplied = postMigrationVersion - preMigrationVersion\n\n        if json {\n            let result: [String: Any] = [\n                \"database_path\": dbPath,\n                \"was_new_database\": !dbExists,\n                \"pre_migration_version\": preMigrationVersion,\n                \"post_migration_version\": postMigrationVersion,\n                \"migrations_applied\": migrationsApplied,\n                \"success\": true\n            ]\n\n            if let jsonData = try? JSONSerialization.data(withJSONObject: result, options: .prettyPrinted),\n               let jsonString = String(data: jsonData, encoding: .utf8) {\n                print(jsonString)\n            }\n        } else {\n            if migrationsApplied == 0 {\n                print(\"âœ“ Database already at latest version (V\\(postMigrationVersion))\")\n            } else if !dbExists {\n                print(\"âœ“ Created new database at V\\(postMigrationVersion)\")\n                if verbose {\n                    print(\"  Applied \\(migrationsApplied) migration(s)\")\n                }\n            } else {\n                print(\"âœ“ Migrated from V\\(preMigrationVersion) to V\\(postMigrationVersion)\")\n                print(\"  Applied \\(migrationsApplied) migration(s):\")\n                for version in (preMigrationVersion + 1)...postMigrationVersion {\n                    if let description = MailDatabase.migrationDescriptions[version] {\n                        print(\"    V\\(version): \\(description)\")\n                    }\n                }\n            }\n\n            // Show threading table status\n            let threadsExist = try mailDatabase.tableExists(\"threads\")\n            let junctionExist = try mailDatabase.tableExists(\"thread_messages\")\n\n            if verbose {\n                print(\"\\nThreading Support:\")\n                print(\"  threads table: \\(threadsExist ? \"âœ“\" : \"â—‹\")\")\n                print(\"  thread_messages table: \\(junctionExist ? \"âœ“\" : \"â—‹\")\")\n\n                // Check for thread columns in messages table\n                let messageColumns = try mailDatabase.getTableColumns(\"messages\")\n                let hasThreadId = messageColumns.contains(\"thread_id\")\n                let hasThreadPosition = messageColumns.contains(\"thread_position\")\n                let hasThreadTotal = messageColumns.contains(\"thread_total\")\n                let hasInReplyTo = messageColumns.contains(\"in_reply_to\")\n                let hasReferences = messageColumns.contains(\"threading_references\")\n\n                print(\"  messages.thread_id: \\(hasThreadId ? \"âœ“\" : \"â—‹\")\")\n                print(\"  messages.thread_position: \\(hasThreadPosition ? \"âœ“\" : \"â—‹\")\")\n                print(\"  messages.thread_total: \\(hasThreadTotal ? \"âœ“\" : \"â—‹\")\")\n                print(\"  messages.in_reply_to: \\(hasInReplyTo ? \"âœ“\" : \"â—‹\")\")\n                print(\"  messages.threading_references: \\(hasReferences ? \"âœ“\" : \"â—‹\")\")\n            }\n        }\n    }\n}\n","structuredPatch":[{"oldStart":2800,"oldLines":6,"newStart":2800,"newLines":7,"lines":["     case watchAndStopMutuallyExclusive","     case invalidInterval(minimum: Int)","     case invalidStatus(value: String)","+    case unknownFilter(names: [String], validFilters: [String])"," ","     public var errorDescription: String? {","         switch self {"]},{"oldStart":2813,"oldLines":6,"newStart":2814,"newLines":14,"lines":["             return \"--interval must be at least \\(minimum) seconds\"","         case .invalidStatus(let value):","             return \"Invalid status '\\(value)'. Valid options: inbox, archived, deleted\"","+        case .unknownFilter(let names, let validFilters):","+            let unknownList = names.map { \"'\\($0)'\" }.joined(separator: \", \")","+            let validList = validFilters.joined(separator: \", \")","+            if names.count == 1 {","+                return \"Unknown filter \\(unknownList). Valid filters: \\(validList)\"","+            } else {","+                return \"Unknown filters \\(unknownList). Valid filters: \\(validList)\"","+            }","         }","     }"," }"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01CiRczBGmByX4NPGektkair","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to update the `MailSearchCommand.run()` function to check for unknown filters after parsing the query:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1328,"cache_read_input_tokens":57925,"cache_creation":{"ephemeral_5m_input_tokens":1328,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"49695e43-7113-44ce-bf5f-5bfb9dae40b8"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01CiRczBGmByX4NPGektkair","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KaD6HRkFLEJL8yZR3buebk","name":"Edit","input":{"replace_all":false,"file_path":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEACLI/Commands/MailCommand.swift","old_string":"        // Parse the query for structured filters\n        var filter = mailDatabase.parseQuery(query)\n\n        // Apply --status option if provided\n        if let statusValue = status {\n            filter.mailboxStatus = MailboxStatus(rawValue: statusValue.lowercased())\n        }\n\n        // Use structured search if we have filters, otherwise fall back to basic FTS\n        let results: [MailMessage]\n        if filter.hasFilters || filter.hasFreeText {\n            results = try mailDatabase.searchMessagesWithFilters(filter, limit: limit)\n        } else {","new_string":"        // Parse the query for structured filters\n        var filter = mailDatabase.parseQuery(query)\n\n        // Check for unknown filter names and fail with helpful error\n        if filter.hasUnknownFilters {\n            throw MailValidationError.unknownFilter(\n                names: filter.unknownFilters,\n                validFilters: MailDatabase.SearchFilter.validFilterNames\n            )\n        }\n\n        // Apply --status option if provided\n        if let statusValue = status {\n            filter.mailboxStatus = MailboxStatus(rawValue: statusValue.lowercased())\n        }\n\n        // Use structured search if we have filters, otherwise fall back to basic FTS\n        let results: [MailMessage]\n        if filter.hasFilters || filter.hasFreeText {\n            results = try mailDatabase.searchMessagesWithFilters(filter, limit: limit)\n        } else {"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1328,"cache_read_input_tokens":57925,"cache_creation":{"ephemeral_5m_input_tokens":1328,"ephemeral_1h_input_tokens":0},"output_tokens":515,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"b88f249c-1ac2-4a7a-b5c8-291ea2c95979"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KaD6HRkFLEJL8yZR3buebk","type":"tool_result","content":"The file /Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEACLI/Commands/MailCommand.swift has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n  1273â†’        let mailDatabase = MailDatabase(databasePath: mailDbPath)\n  1274â†’        try mailDatabase.initialize()\n  1275â†’        defer { mailDatabase.close() }\n  1276â†’\n  1277â†’        // Parse the query for structured filters\n  1278â†’        var filter = mailDatabase.parseQuery(query)\n  1279â†’\n  1280â†’        // Check for unknown filter names and fail with helpful error\n  1281â†’        if filter.hasUnknownFilters {\n  1282â†’            throw MailValidationError.unknownFilter(\n  1283â†’                names: filter.unknownFilters,\n  1284â†’                validFilters: MailDatabase.SearchFilter.validFilterNames\n  1285â†’            )\n  1286â†’        }\n  1287â†’\n  1288â†’        // Apply --status option if provided\n  1289â†’        if let statusValue = status {\n  1290â†’            filter.mailboxStatus = MailboxStatus(rawValue: statusValue.lowercased())\n  1291â†’        }\n  1292â†’\n  1293â†’        // Use structured search if we have filters, otherwise fall back to basic FTS\n  1294â†’        let results: [MailMessage]\n  1295â†’        if filter.hasFilters || filter.hasFreeText {\n  1296â†’            results = try mailDatabase.searchMessagesWithFilters(filter, limit: limit)\n  1297â†’        } else {\n  1298â†’            // Empty query - show recent messages\n  1299â†’            results = try mailDatabase.getAllMessages(limit: limit)\n  1300â†’        }\n  1301â†’"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"4a756c95-44f3-4a3e-8930-25fe87db489b","tool_use_result":{"filePath":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEACLI/Commands/MailCommand.swift","oldString":"        // Parse the query for structured filters\n        var filter = mailDatabase.parseQuery(query)\n\n        // Apply --status option if provided\n        if let statusValue = status {\n            filter.mailboxStatus = MailboxStatus(rawValue: statusValue.lowercased())\n        }\n\n        // Use structured search if we have filters, otherwise fall back to basic FTS\n        let results: [MailMessage]\n        if filter.hasFilters || filter.hasFreeText {\n            results = try mailDatabase.searchMessagesWithFilters(filter, limit: limit)\n        } else {","newString":"        // Parse the query for structured filters\n        var filter = mailDatabase.parseQuery(query)\n\n        // Check for unknown filter names and fail with helpful error\n        if filter.hasUnknownFilters {\n            throw MailValidationError.unknownFilter(\n                names: filter.unknownFilters,\n                validFilters: MailDatabase.SearchFilter.validFilterNames\n            )\n        }\n\n        // Apply --status option if provided\n        if let statusValue = status {\n            filter.mailboxStatus = MailboxStatus(rawValue: statusValue.lowercased())\n        }\n\n        // Use structured search if we have filters, otherwise fall back to basic FTS\n        let results: [MailMessage]\n        if filter.hasFilters || filter.hasFreeText {\n            results = try mailDatabase.searchMessagesWithFilters(filter, limit: limit)\n        } else {","originalFile":"import AppKit\nimport ArgumentParser\nimport Foundation\nimport SwiftEAKit\n\n\n// MARK: - Date Extension for ISO 8601 formatting\n\nextension Date {\n    var iso8601String: String {\n        let formatter = ISO8601DateFormatter()\n        formatter.formatOptions = [.withInternetDateTime]\n        return formatter.string(from: self)\n    }\n}\n\n// MARK: - Standard Error Output Helper\n\n/// Write a message to stderr for error/warning output.\n/// This ensures errors dont corrupt stdout when piping (e.g., JSON output to jq).\nprivate func printError(_ message: String) {\n    fputs(\"\\(message)\\n\", stderr)\n}\n\npublic struct Mail: ParsableCommand {\n    public static let configuration = CommandConfiguration(\n        commandName: \"mail\",\n        abstract: \"Mail operations (sync, search, show, export, actions)\",\n        discussion: \"\"\"\n            swea mail commands interact with Apple Mail.app to sync, search,\n            and perform actions on your email.\n\n            GETTING STARTED\n            The typical workflow is: sync -> search/show -> export\n\n              swea mail sync              # Sync mail to local database\n              swea mail sync --watch      # Start automatic background sync\n              swea mail search \"query\"    # Search synced messages\n              swea mail export            # Export to markdown files\n\n            QUICK WORKFLOW\n              # First time: sync all mail\n              swea mail sync\n\n              # For ongoing use: start automatic sync\n              swea mail sync --watch\n\n              # Search and export as needed\n              swea mail search \"from:alice@example.com\"\n              swea mail export --query \"from:alice\"\n\n            NOTE: 'sync' populates the database. 'export' creates .md files.\n            Run both if you want files you can open in Obsidian.\n\n            AUTOMATION PERMISSION\n            Action commands (archive, delete, move, flag, mark, reply, compose)\n            require macOS Automation permission for Mail.app. On first run, macOS\n            will prompt you to grant permission. To grant permission manually:\n\n              1. Open System Settings > Privacy & Security > Automation\n              2. Find swea (or Terminal if running from terminal)\n              3. Enable the toggle for Mail.app\n\n            SAFETY FLAGS\n            Destructive actions (archive, delete, move) require explicit confirmation:\n\n              --dry-run    Preview what would happen without making changes\n              --yes        Confirm the action and execute it\n\n            Running a destructive action without --yes or --dry-run will show an\n            error explaining the requirement.\n\n            EXAMPLES\n              # Sync mail from Apple Mail\n              swea mail sync\n\n              # Start automatic sync (recommended for regular use)\n              swea mail sync --watch\n\n              # Force a full resync if needed\n              swea mail sync --full\n\n              # Search for emails from a specific sender\n              swea mail search \"from:alice@example.com\"\n\n              # Export all mail to markdown files\n              swea mail export\n\n              # Export filtered mail to custom location\n              swea mail export --query \"from:alice\" --output ~/Documents/Mail\n\n              # Preview archiving a message (no changes made)\n              swea mail archive --id mail-abc123 --dry-run\n\n              # Archive a message (requires confirmation)\n              swea mail archive --id mail-abc123 --yes\n\n              # Flag a message\n              swea mail flag --id mail-abc123 --set\n\n              # Compose a new email draft\n              swea mail compose --to bob@example.com --subject \"Hello\"\n            \"\"\",\n        subcommands: [\n            MailSyncCommand.self,\n            MailSearchCommand.self,\n            MailShowCommand.self,\n            MailThreadCommand.self,\n            MailThreadsCommand.self,\n            MailExportCommand.self,\n            MailExportThreadsCommand.self,\n            // Action commands\n            MailArchiveCommand.self,\n            MailDeleteCommand.self,\n            MailMoveCommand.self,\n            MailFlagCommand.self,\n            MailMarkCommand.self,\n            MailReplyCommand.self,\n            MailComposeCommand.self,\n            // Database maintenance\n            MailMigrateCommand.self\n        ]\n    )\n\n    public init() {}\n}\n\nstruct MailSyncCommand: ParsableCommand {\n    static let configuration = CommandConfiguration(\n        commandName: \"sync\",\n        abstract: \"Sync mail data from Apple Mail and export to Swiftea/Mail/\",\n        discussion: \"\"\"\n            Syncs mail data from Apple Mail to a local SQLite database for fast\n            searching. By default, performs an incremental sync (only new/changed\n            messages). Use --full to resync everything.\n\n            After sync, new messages are automatically exported as markdown files\n            to Swiftea/Mail/ for use with Obsidian or other markdown tools.\n            Use --no-export to disable automatic export.\n\n            For automatic sync, use --watch to start a background daemon that\n            keeps your mail database and markdown exports up to date.\n\n            EXAMPLES\n              swea mail sync              # Incremental sync + auto-export\n              swea mail sync --full       # Full resync + export all\n              swea mail sync --no-export  # Sync only, skip markdown export\n              swea mail sync --watch      # Start automatic sync daemon\n              swea mail sync --status     # Check sync/daemon status\n              swea mail sync --stop       # Stop the daemon\n            \"\"\"\n    )\n\n    @Flag(name: .long, help: \"Install and start watch daemon for continuous sync\")\n    var watch: Bool = false\n\n    @Flag(name: .long, help: \"Stop the watch daemon\")\n    var stop: Bool = false\n\n    @Flag(name: .long, help: \"Show sync status and watch daemon state\")\n    var status: Bool = false\n\n    @Flag(name: .long, help: \"Force a full sync, ignoring previous sync state\")\n    var full: Bool = false\n\n    @Flag(name: .long, help: \"Show detailed progress\")\n    var verbose: Bool = false\n\n    @Flag(name: .long, help: \"Run as persistent daemon with sleep/wake detection (internal use)\")\n    var daemon: Bool = false\n\n    @Flag(name: .long, help: \"Disable automatic export to Swiftea/Mail/ after sync\")\n    var noExport: Bool = false\n\n    @Option(name: .long, help: \"Sync interval in seconds for watch mode (default: 300, minimum: 30)\")\n    var interval: Int?\n\n    // MARK: - Retry Configuration (for daemon mode)\n\n    /// Maximum number of retry attempts for transient errors\n    private static let maxRetryAttempts = 5\n\n    /// Base delay in seconds for exponential backoff\n    private static let baseRetryDelay: TimeInterval = 2.0\n\n    /// Maximum delay in seconds between retries\n    private static let maxRetryDelay: TimeInterval = 60.0\n\n    /// Errors that are considered transient and worth retrying\n    private func isTransientError(_ error: Error) -> Bool {\n        let description = error.localizedDescription.lowercased()\n        // Database lock errors, network timeouts, permission issues that may be temporary\n        return description.contains(\"locked\") ||\n               description.contains(\"busy\") ||\n               description.contains(\"timeout\") ||\n               description.contains(\"temporarily\") ||\n               description.contains(\"try again\")\n    }\n\n    // MARK: - Daemon-safe Logging\n\n    /// Detect if running as a LaunchAgent daemon (no TTY attached)\n    private var isDaemonMode: Bool {\n        // When run by launchd, there's no TTY and stdout is not interactive\n        // isatty() returns non-zero if stdout is connected to a terminal, 0 otherwise\n        return isatty(STDOUT_FILENO) == 0\n    }\n\n    /// Log a message with optional timestamp prefix for daemon mode.\n    /// Ensures output is flushed immediately so logs are captured.\n    private func log(_ message: String) {\n        if isDaemonMode {\n            let timestamp = ISO8601DateFormatter().string(from: Date())\n            fputs(\"[\\(timestamp)] \\(message)\\n\", stdout)\n            fflush(stdout)\n        } else {\n            print(message)\n        }\n    }\n\n    /// Log an error message to stderr, ensuring it's flushed for daemon mode.\n    private func logError(_ message: String) {\n        if isDaemonMode {\n            let timestamp = ISO8601DateFormatter().string(from: Date())\n            fputs(\"[\\(timestamp)] ERROR: \\(message)\\n\", stderr)\n            fflush(stderr)\n        } else {\n            fputs(\"Error: \\(message)\\n\", stderr)\n        }\n    }\n\n    /// Minimum allowed sync interval in seconds\n    private static let minIntervalSeconds = 30\n\n    /// Default sync interval in seconds (1 minute)\n    private static let defaultIntervalSeconds = 60\n\n    func validate() throws {\n        // --watch and --stop are mutually exclusive\n        if watch && stop {\n            throw MailValidationError.watchAndStopMutuallyExclusive\n        }\n\n        // Validate --interval if provided\n        if let interval = interval {\n            if interval < Self.minIntervalSeconds {\n                throw MailValidationError.invalidInterval(minimum: Self.minIntervalSeconds)\n            }\n        }\n    }\n\n    func run() throws {\n        // Log startup for daemon mode debugging\n        if isDaemonMode {\n            log(\"mail sync started (daemon mode, pid=\\(ProcessInfo.processInfo.processIdentifier))\")\n            log(\"working directory: \\(FileManager.default.currentDirectoryPath)\")\n        }\n\n        // In daemon mode, use retry with exponential backoff for transient errors\n        if isDaemonMode {\n            try executeSyncWithRetry()\n        } else {\n            // Interactive mode: no retry, immediate failure feedback\n            do {\n                try executeSync()\n            } catch {\n                logError(\"\\(error.localizedDescription)\")\n                throw error\n            }\n        }\n    }\n\n    /// Execute sync with exponential backoff retry for transient errors (daemon mode)\n    private func executeSyncWithRetry() throws {\n        var lastError: Error?\n        var attempt = 0\n\n        while attempt < Self.maxRetryAttempts {\n            do {\n                try executeSync()\n                log(\"mail sync completed successfully\")\n                return\n            } catch {\n                lastError = error\n                attempt += 1\n\n                // Check if error is transient and worth retrying\n                if isTransientError(error) && attempt < Self.maxRetryAttempts {\n                    // Calculate exponential backoff delay with jitter\n                    let delay = min(\n                        Self.baseRetryDelay * pow(2.0, Double(attempt - 1)),\n                        Self.maxRetryDelay\n                    )\n                    // Add 10-20% random jitter to prevent thundering herd\n                    let jitter = delay * Double.random(in: 0.1...0.2)\n                    let totalDelay = delay + jitter\n\n                    log(\"Transient error (attempt \\(attempt)/\\(Self.maxRetryAttempts)): \\(error.localizedDescription)\")\n                    log(\"Retrying in \\(String(format: \"%.1f\", totalDelay)) seconds...\")\n\n                    Thread.sleep(forTimeInterval: totalDelay)\n                } else {\n                    // Non-transient error or max retries reached\n                    break\n                }\n            }\n        }\n\n        // All retries exhausted or non-transient error\n        if let error = lastError {\n            logError(\"Sync failed after \\(attempt) attempt(s): \\(error.localizedDescription)\")\n            log(\"mail sync failed\")\n            throw error\n        }\n    }\n\n    private func executeSync() throws {\n        let vault = try VaultContext.require()\n\n        // Create mail database in vault's data folder\n        let mailDbPath = (vault.dataFolderPath as NSString).appendingPathComponent(\"mail.db\")\n        let mailDatabase = MailDatabase(databasePath: mailDbPath)\n        try mailDatabase.initialize()\n        defer { mailDatabase.close() }\n\n        if verbose || isDaemonMode {\n            log(\"Mail database: \\(mailDbPath)\")\n        }\n\n        // Handle --status flag\n        if status {\n            try showSyncStatus(mailDatabase: mailDatabase, vault: vault)\n            return\n        }\n\n        // Handle --watch flag\n        if watch {\n            try installWatchDaemon(vault: vault, verbose: verbose)\n            return\n        }\n\n        // Handle --stop flag\n        if stop {\n            try stopWatchDaemon(verbose: verbose)\n            return\n        }\n\n        // Handle --daemon flag: run as persistent daemon with sleep/wake detection\n        if daemon {\n            try runPersistentDaemon(mailDatabase: mailDatabase, vault: vault)\n            return\n        }\n\n        // Create sync engine\n        let sync = MailSync(mailDatabase: mailDatabase)\n\n        // Wire up progress callback for verbose mode\n        if verbose {\n            var lastPhase: String = \"\"\n            var lastProgressTime = Date()\n            sync.onProgress = { progress in\n                // Always show phase changes\n                if progress.phase.rawValue != lastPhase {\n                    if !lastPhase.isEmpty {\n                        print(\"\") // newline after previous phase\n                    }\n                    lastPhase = progress.phase.rawValue\n                    lastProgressTime = Date()\n                }\n\n                // For message sync, show periodic updates (every 0.5s or phase change)\n                let now = Date()\n                let elapsed = now.timeIntervalSince(lastProgressTime)\n                if elapsed >= 0.5 || progress.current == progress.total {\n                    lastProgressTime = now\n                    if progress.total > 0 {\n                        let pct = Int(progress.percentage)\n                        // Use carriage return to update in place\n                        print(\"\\r  [\\(progress.phase.rawValue)] \\(progress.current)/\\(progress.total) (\\(pct)%) - \\(progress.message)\", terminator: \"\")\n                        fflush(stdout)\n                    } else {\n                        print(\"\\r  [\\(progress.phase.rawValue)] \\(progress.message)\", terminator: \"\")\n                        fflush(stdout)\n                    }\n                }\n            }\n        }\n\n        log(\"Syncing mail from Apple Mail...\")\n\n        do {\n            let result = try sync.sync(forceFullSync: full)\n\n            if verbose {\n                print(\"\") // Final newline after progress\n            }\n\n            log(\"Sync complete:\")\n            log(\"  Messages processed: \\(result.messagesProcessed)\")\n            log(\"  Messages added: \\(result.messagesAdded)\")\n            log(\"  Messages updated: \\(result.messagesUpdated)\")\n            log(\"  Mailboxes: \\(result.mailboxesProcessed)\")\n            log(\"  Duration: \\(String(format: \"%.2f\", result.duration))s\")\n\n            if !result.errors.isEmpty {\n                log(\"\\nWarnings/Errors:\")\n                for error in result.errors.prefix(10) {\n                    log(\"  - \\(error)\")\n                }\n                if result.errors.count > 10 {\n                    log(\"  ... and \\(result.errors.count - 10) more\")\n                }\n            }\n\n            // Auto-export new messages to Swiftea/Mail/ unless disabled\n            if !noExport {\n                try performAutoExport(mailDatabase: mailDatabase, vault: vault)\n            }\n\n            // Process pending backward sync actions (archive/delete from SwiftEA to Apple Mail)\n            try performBackwardSync(mailDatabase: mailDatabase)\n        } catch let error as MailSyncError {\n            logError(\"Sync failed: \\(error.localizedDescription)\")\n            throw ExitCode.failure\n        }\n    }\n\n    // MARK: - Auto-Export\n\n    /// Export newly synced messages to Swiftea/Mail/ as markdown files\n    /// Messages are grouped by conversation/thread for better organization.\n    private func performAutoExport(mailDatabase: MailDatabase, vault: VaultContext) throws {\n        let exportDir = (vault.dataFolderPath as NSString).appendingPathComponent(\"Mail\")\n        let exporter = MailExporter(mailDatabase: mailDatabase)\n\n        do {\n            let exportResult = try exporter.exportNewMessages(to: exportDir)\n\n            if exportResult.exported > 0 {\n                log(\"Auto-export:\")\n                log(\"  Exported \\(exportResult.exported) message(s) to Swiftea/Mail/\")\n                if exportResult.threadsExported > 0 {\n                    log(\"  Threads updated: \\(exportResult.threadsExported) (in threads/)\")\n                }\n                if exportResult.unthreadedExported > 0 {\n                    log(\"  Unthreaded: \\(exportResult.unthreadedExported) (in unthreaded/)\")\n                }\n            }\n\n            if !exportResult.errors.isEmpty && verbose {\n                for error in exportResult.errors.prefix(5) {\n                    log(\"  Warning: \\(error)\")\n                }\n                if exportResult.errors.count > 5 {\n                    log(\"  ... and \\(exportResult.errors.count - 5) more export errors\")\n                }\n            }\n        } catch {\n            // Log but don't fail sync if export has issues\n            logError(\"Auto-export failed: \\(error.localizedDescription)\")\n        }\n    }\n\n    // MARK: - Backward Sync\n\n    /// Process pending backward sync actions (archive/delete from SwiftEA to Apple Mail)\n    private func performBackwardSync(mailDatabase: MailDatabase) throws {\n        let backwardSync = MailSyncBackward(mailDatabase: mailDatabase)\n\n        do {\n            let result = try backwardSync.processPendingActions()\n\n            // Log results if any actions were processed\n            if result.archived > 0 || result.deleted > 0 {\n                log(\"Backward sync:\")\n                log(\"  Archived: \\(result.archived), Deleted: \\(result.deleted)\")\n            }\n\n            // Log warnings for failed actions\n            if result.failed > 0 {\n                logError(\"Backward sync failed for \\(result.failed) message(s)\")\n                for error in result.errors.prefix(5) {\n                    logError(\"  - \\(error)\")\n                }\n                if result.errors.count > 5 {\n                    logError(\"  ... and \\(result.errors.count - 5) more errors\")\n                }\n            }\n        } catch {\n            // Log but don't fail sync if backward sync has issues\n            logError(\"Backward sync failed: \\(error.localizedDescription)\")\n        }\n    }\n\n    // MARK: - Status\n\n    private func showSyncStatus(mailDatabase: MailDatabase, vault: VaultContext) throws {\n        let summary = try mailDatabase.getSyncStatusSummary()\n        let daemonStatus = getDaemonStatus()\n\n        print(\"Mail Sync Status\")\n        print(\"================\")\n        print(\"\")\n\n        // Daemon status\n        print(\"Watch Daemon: \\(daemonStatus.isRunning ? \"running\" : \"stopped\")\")\n        if let pid = daemonStatus.pid {\n            print(\"  PID: \\(pid)\")\n        }\n        print(\"\")\n\n        // Sync state\n        print(\"Last Sync:\")\n        print(\"  State: \\(summary.state.rawValue)\")\n\n        if let lastSync = summary.lastSyncTime {\n            let formatter = DateFormatter()\n            formatter.dateStyle = .medium\n            formatter.timeStyle = .medium\n            print(\"  Time: \\(formatter.string(from: lastSync))\")\n        } else {\n            print(\"  Time: Never\")\n        }\n\n        if let duration = summary.duration {\n            print(\"  Duration: \\(String(format: \"%.2f\", duration))s\")\n        }\n\n        if let isIncremental = summary.isIncremental {\n            print(\"  Type: \\(isIncremental ? \"incremental\" : \"full\")\")\n        }\n\n        // Message counts\n        if summary.messagesAdded > 0 || summary.messagesUpdated > 0 || summary.messagesDeleted > 0 {\n            print(\"  Messages: +\\(summary.messagesAdded) ~\\(summary.messagesUpdated) -\\(summary.messagesDeleted)\")\n        }\n\n        // Error if any\n        if let error = summary.lastSyncError {\n            print(\"\")\n            printError(\"Last Error: \\(error)\")\n        }\n\n        // Database location\n        print(\"\")\n        print(\"Database: \\(vault.dataFolderPath)/mail.db\")\n    }\n\n    private struct DaemonStatus {\n        let isRunning: Bool\n        let pid: Int?\n    }\n\n    private func getDaemonStatus() -> DaemonStatus {\n        // Use `launchctl list` (all services) to get tab-separated format\n        // Note: `launchctl list SERVICE_NAME` returns dictionary format, not tabular\n        let process = Process()\n        process.executableURL = URL(fileURLWithPath: \"/bin/launchctl\")\n        process.arguments = [\"list\"]\n\n        let pipe = Pipe()\n        process.standardOutput = pipe\n        process.standardError = FileHandle.nullDevice\n\n        do {\n            try process.run()\n            process.waitUntilExit()\n\n            if process.terminationStatus == 0 {\n                let data = pipe.fileHandleForReading.readDataToEndOfFile()\n                if let output = String(data: data, encoding: .utf8) {\n                    // Find the line containing our service label\n                    // Format: \"PID\\tStatus\\tLabel\" where PID is \"-\" if not running\n                    for line in output.split(separator: \"\\n\") {\n                        if line.contains(\"com.swiftea.mail.sync\") {\n                            let components = line.split(separator: \"\\t\")\n                            if components.count >= 3 {\n                                let pidStr = String(components[0])\n                                if pidStr != \"-\", let pid = Int(pidStr), pid > 0 {\n                                    return DaemonStatus(isRunning: true, pid: pid)\n                                }\n                                // Job exists but not running (PID is \"-\")\n                                return DaemonStatus(isRunning: false, pid: nil)\n                            }\n                        }\n                    }\n                }\n            }\n        } catch {\n            // launchctl failed, daemon not loaded\n        }\n\n        return DaemonStatus(isRunning: false, pid: nil)\n    }\n\n    // MARK: - Watch Daemon\n\n    private static let launchAgentLabel = \"com.swiftea.mail.sync\"\n\n    /// Get the effective sync interval (user-specified or default)\n    private var effectiveSyncInterval: Int {\n        interval ?? Self.defaultIntervalSeconds\n    }\n\n    private func getLaunchAgentPath() -> String {\n        let homeDir = FileManager.default.homeDirectoryForCurrentUser.path\n        return \"\\(homeDir)/Library/LaunchAgents/\\(Self.launchAgentLabel).plist\"\n    }\n\n    /// Format interval for human-readable output\n    private func formatInterval(_ seconds: Int) -> String {\n        if seconds >= 60 && seconds % 60 == 0 {\n            let minutes = seconds / 60\n            return \"\\(minutes) minute\\(minutes == 1 ? \"\" : \"s\")\"\n        } else {\n            return \"\\(seconds) seconds\"\n        }\n    }\n\n    private func installWatchDaemon(vault: VaultContext, verbose: Bool) throws {\n        let launchAgentPath = getLaunchAgentPath()\n        let executablePath = ProcessInfo.processInfo.arguments[0]\n\n        // Resolve to absolute path if needed\n        let absoluteExecutablePath: String\n        if executablePath.hasPrefix(\"/\") {\n            absoluteExecutablePath = executablePath\n        } else {\n            let currentDir = FileManager.default.currentDirectoryPath\n            absoluteExecutablePath = (currentDir as NSString).appendingPathComponent(executablePath)\n        }\n\n        // Create LaunchAgents directory if needed\n        let launchAgentsDir = (getLaunchAgentPath() as NSString).deletingLastPathComponent\n        if !FileManager.default.fileExists(atPath: launchAgentsDir) {\n            try FileManager.default.createDirectory(atPath: launchAgentsDir, withIntermediateDirectories: true)\n        }\n\n        // Create log directory\n        let logDir = \"\\(vault.dataFolderPath)/logs\"\n        if !FileManager.default.fileExists(atPath: logDir) {\n            try FileManager.default.createDirectory(atPath: logDir, withIntermediateDirectories: true)\n        }\n\n        // Run initial sync before starting watch daemon (swiftea-7im.12)\n        // This ensures the database is populated before the daemon starts incremental syncs\n        print(\"Running initial sync before starting watch daemon...\")\n        let mailDbPath = (vault.dataFolderPath as NSString).appendingPathComponent(\"mail.db\")\n        let mailDatabase = MailDatabase(databasePath: mailDbPath)\n        try mailDatabase.initialize()\n\n        // Sync will auto-detect incremental mode based on last_sync_time in database\n        let sync = MailSync(mailDatabase: mailDatabase)\n\n        do {\n            let result = try sync.sync()\n            print(\"Initial sync complete:\")\n            print(\"  Messages: +\\(result.messagesAdded) ~\\(result.messagesUpdated)\")\n            print(\"  Duration: \\(String(format: \"%.2f\", result.duration))s\")\n            if !result.errors.isEmpty {\n                print(\"  Warnings: \\(result.errors.count)\")\n            }\n        } catch {\n            printError(\"Warning: Initial sync failed: \\(error.localizedDescription)\")\n            printError(\"The daemon will retry on its first run.\")\n        }\n\n        mailDatabase.close()\n\n        // Generate plist content\n        // Uses --daemon mode for a persistent process with sleep/wake detection.\n        // KeepAlive ensures the daemon is restarted if it exits.\n        let syncInterval = effectiveSyncInterval\n        let plist = \"\"\"\n            <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n            <!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n            <plist version=\"1.0\">\n            <dict>\n                <key>Label</key>\n                <string>\\(Self.launchAgentLabel)</string>\n                <key>ProgramArguments</key>\n                <array>\n                    <string>\\(absoluteExecutablePath)</string>\n                    <string>mail</string>\n                    <string>sync</string>\n                    <string>--daemon</string>\n                    <string>--interval</string>\n                    <string>\\(syncInterval)</string>\n                </array>\n                <key>RunAtLoad</key>\n                <true/>\n                <key>KeepAlive</key>\n                <true/>\n                <key>StandardOutPath</key>\n                <string>\\(logDir)/mail-sync.log</string>\n                <key>StandardErrorPath</key>\n                <string>\\(logDir)/mail-sync.log</string>\n                <key>WorkingDirectory</key>\n                <string>\\(vault.rootPath)</string>\n                <key>EnvironmentVariables</key>\n                <dict>\n                    <key>PATH</key>\n                    <string>/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin</string>\n                </dict>\n            </dict>\n            </plist>\n            \"\"\"\n\n        // Write plist file\n        try plist.write(toFile: launchAgentPath, atomically: true, encoding: .utf8)\n\n        if verbose {\n            print(\"Created LaunchAgent: \\(launchAgentPath)\")\n        }\n\n        // Unload if already loaded (ignore errors)\n        let unloadProcess = Process()\n        unloadProcess.executableURL = URL(fileURLWithPath: \"/bin/launchctl\")\n        unloadProcess.arguments = [\"unload\", launchAgentPath]\n        unloadProcess.standardOutput = FileHandle.nullDevice\n        unloadProcess.standardError = FileHandle.nullDevice\n        try? unloadProcess.run()\n        unloadProcess.waitUntilExit()\n\n        // Load the LaunchAgent\n        let loadProcess = Process()\n        loadProcess.executableURL = URL(fileURLWithPath: \"/bin/launchctl\")\n        loadProcess.arguments = [\"load\", launchAgentPath]\n\n        let errorPipe = Pipe()\n        loadProcess.standardError = errorPipe\n\n        try loadProcess.run()\n        loadProcess.waitUntilExit()\n\n        if loadProcess.terminationStatus != 0 {\n            let errorData = errorPipe.fileHandleForReading.readDataToEndOfFile()\n            let errorOutput = String(data: errorData, encoding: .utf8) ?? \"Unknown error\"\n            printError(\"Failed to load LaunchAgent: \\(errorOutput)\")\n            throw ExitCode.failure\n        }\n\n        print(\"Watch daemon installed and started\")\n        print(\"  Mode: Persistent daemon with sleep/wake detection\")\n        print(\"  Interval: \\(formatInterval(syncInterval))\")\n        print(\"  Logs: \\(logDir)/mail-sync.log\")\n        print(\"\")\n        print(\"Use 'swea mail sync --status' to check status\")\n        print(\"Use 'swea mail sync --stop' to stop the daemon\")\n    }\n\n    private func stopWatchDaemon(verbose: Bool) throws {\n        let launchAgentPath = getLaunchAgentPath()\n\n        // Check if plist exists\n        guard FileManager.default.fileExists(atPath: launchAgentPath) else {\n            print(\"Watch daemon is not installed\")\n            return\n        }\n\n        // Unload the LaunchAgent\n        let process = Process()\n        process.executableURL = URL(fileURLWithPath: \"/bin/launchctl\")\n        process.arguments = [\"unload\", launchAgentPath]\n\n        let errorPipe = Pipe()\n        process.standardError = errorPipe\n\n        try process.run()\n        process.waitUntilExit()\n\n        if process.terminationStatus != 0 {\n            let errorData = errorPipe.fileHandleForReading.readDataToEndOfFile()\n            let errorOutput = String(data: errorData, encoding: .utf8) ?? \"Unknown error\"\n            // Check if it was already unloaded\n            if !errorOutput.contains(\"Could not find specified service\") {\n                printError(\"Warning: \\(errorOutput.trimmingCharacters(in: .whitespacesAndNewlines))\")\n            }\n        }\n\n        // Remove the plist file\n        try? FileManager.default.removeItem(atPath: launchAgentPath)\n\n        if verbose {\n            print(\"Removed LaunchAgent: \\(launchAgentPath)\")\n        }\n\n        print(\"Watch daemon stopped and uninstalled\")\n    }\n\n    // MARK: - Persistent Daemon with Sleep/Wake Detection\n\n    /// Run as a persistent daemon that syncs on startup, on a schedule, and on system wake.\n    /// This mode is used internally by the LaunchAgent for sleep/wake-aware syncing.\n    private func runPersistentDaemon(mailDatabase: MailDatabase, vault: VaultContext) throws {\n        let syncInterval = effectiveSyncInterval\n        let exportDir = (vault.dataFolderPath as NSString).appendingPathComponent(\"Mail\")\n\n        log(\"Starting persistent mail sync daemon (pid=\\(ProcessInfo.processInfo.processIdentifier))\")\n        log(\"Sync interval: \\(formatInterval(syncInterval))\")\n        log(\"Export directory: \\(exportDir)\")\n\n        // Run initial incremental sync on startup\n        log(\"Running initial sync...\")\n        performDaemonSync(mailDatabase: mailDatabase, exportDir: exportDir)\n\n        // Create a daemon controller to handle sleep/wake events\n        let controller = MailSyncDaemonController(\n            mailDatabase: mailDatabase,\n            exportDir: exportDir,\n            syncIntervalSeconds: TimeInterval(syncInterval),\n            logger: log\n        )\n\n        // Start the run loop - this blocks until the daemon is terminated\n        controller.startRunLoop()\n\n        log(\"Daemon shutting down\")\n    }\n}\n\n// MARK: - Mail Sync Daemon Controller\n\n/// Controls the mail sync daemon with sleep/wake detection.\n/// Uses NSWorkspace notifications to detect system wake and trigger incremental sync.\nfinal class MailSyncDaemonController: NSObject {\n    private let mailDatabase: MailDatabase\n    private let exportDir: String\n    private let logger: (String) -> Void\n    private var isSyncing = false\n    private let syncQueue = DispatchQueue(label: \"com.swiftea.mail.sync.daemon\")\n    private var syncTimer: Timer?\n    private let backwardSync: MailSyncBackward\n\n    /// Interval between scheduled syncs (configurable, default 1 minute)\n    private let syncIntervalSeconds: TimeInterval\n\n    /// Minimum interval between syncs to prevent rapid-fire syncing\n    private static let minSyncIntervalSeconds: TimeInterval = 30\n\n    /// Track last sync time to debounce wake events\n    private var lastSyncTime: Date?\n\n    init(mailDatabase: MailDatabase, exportDir: String, syncIntervalSeconds: TimeInterval = 60, logger: @escaping (String) -> Void) {\n        self.mailDatabase = mailDatabase\n        self.exportDir = exportDir\n        self.syncIntervalSeconds = syncIntervalSeconds\n        self.logger = logger\n        self.backwardSync = MailSyncBackward(mailDatabase: mailDatabase)\n        super.init()\n\n        // Register for sleep/wake notifications\n        registerForPowerNotifications()\n    }\n\n    deinit {\n        unregisterForPowerNotifications()\n        syncTimer?.invalidate()\n    }\n\n    /// Start the run loop. Blocks until the daemon is terminated.\n    func startRunLoop() {\n        // Schedule periodic sync timer\n        scheduleSyncTimer()\n\n        // Run the main run loop to receive notifications\n        // This blocks until the process is terminated\n        RunLoop.current.run()\n    }\n\n    // MARK: - Power Notifications\n\n    private func registerForPowerNotifications() {\n        let workspace = NSWorkspace.shared\n        let center = workspace.notificationCenter\n\n        // System woke from sleep\n        center.addObserver(\n            self,\n            selector: #selector(systemDidWake(_:)),\n            name: NSWorkspace.didWakeNotification,\n            object: nil\n        )\n\n        // System is about to sleep\n        center.addObserver(\n            self,\n            selector: #selector(systemWillSleep(_:)),\n            name: NSWorkspace.willSleepNotification,\n            object: nil\n        )\n\n        logger(\"Registered for sleep/wake notifications\")\n    }\n\n    private func unregisterForPowerNotifications() {\n        NSWorkspace.shared.notificationCenter.removeObserver(self)\n    }\n\n    @objc private func systemDidWake(_ notification: Notification) {\n        logger(\"System woke from sleep - triggering catch-up sync\")\n        triggerSync(reason: \"wake\")\n    }\n\n    @objc private func systemWillSleep(_ notification: Notification) {\n        logger(\"System going to sleep\")\n        // Cancel any pending sync timer - we'll sync on wake instead\n        syncTimer?.invalidate()\n        syncTimer = nil\n    }\n\n    // MARK: - Sync Timer\n\n    private func scheduleSyncTimer() {\n        // Invalidate existing timer\n        syncTimer?.invalidate()\n\n        // Schedule new timer on the main run loop\n        syncTimer = Timer.scheduledTimer(withTimeInterval: syncIntervalSeconds, repeats: true) { [weak self] _ in\n            self?.triggerSync(reason: \"scheduled\")\n        }\n\n        logger(\"Scheduled sync timer (every \\(Int(syncIntervalSeconds))s)\")\n    }\n\n    // MARK: - Sync Execution\n\n    /// Trigger a sync, debouncing rapid-fire requests.\n    private func triggerSync(reason: String) {\n        // Debounce: don't sync if we synced very recently\n        if let lastSync = lastSyncTime {\n            let elapsed = Date().timeIntervalSince(lastSync)\n            if elapsed < Self.minSyncIntervalSeconds {\n                logger(\"Skipping \\(reason) sync (last sync was \\(Int(elapsed))s ago)\")\n                return\n            }\n        }\n\n        // Don't spawn duplicate syncs\n        syncQueue.async { [weak self] in\n            guard let self = self else { return }\n\n            if self.isSyncing {\n                self.logger(\"Sync already in progress, skipping \\(reason) sync\")\n                return\n            }\n\n            self.isSyncing = true\n            self.lastSyncTime = Date()\n\n            self.performSync(reason: reason)\n\n            self.isSyncing = false\n\n            // Re-schedule timer after wake (in case it was cancelled during sleep)\n            if reason == \"wake\" {\n                DispatchQueue.main.async {\n                    self.scheduleSyncTimer()\n                }\n            }\n        }\n    }\n\n    /// Perform the actual sync with retry logic.\n    private func performSync(reason: String) {\n        logger(\"Starting \\(reason) sync...\")\n\n        let maxRetryAttempts = 5\n        let baseRetryDelay: TimeInterval = 2.0\n        let maxRetryDelay: TimeInterval = 60.0\n\n        var attempt = 0\n        var lastError: Error?\n\n        while attempt < maxRetryAttempts {\n            do {\n                let sync = MailSync(mailDatabase: mailDatabase)\n                let result = try sync.sync()\n\n                logger(\"Sync complete: +\\(result.messagesAdded) ~\\(result.messagesUpdated) (\\(String(format: \"%.2f\", result.duration))s)\")\n\n                if !result.errors.isEmpty {\n                    logger(\"  \\(result.errors.count) warning(s)\")\n                }\n\n                // Auto-export new messages after successful sync\n                performAutoExport()\n\n                // Process pending backward sync actions (archive/delete from SwiftEA to Apple Mail)\n                performBackwardSync()\n                return\n\n            } catch {\n                lastError = error\n                attempt += 1\n\n                // Check if error is transient\n                let description = error.localizedDescription.lowercased()\n                let isTransient = description.contains(\"locked\") ||\n                                  description.contains(\"busy\") ||\n                                  description.contains(\"timeout\") ||\n                                  description.contains(\"temporarily\") ||\n                                  description.contains(\"try again\")\n\n                if isTransient && attempt < maxRetryAttempts {\n                    let delay = min(baseRetryDelay * pow(2.0, Double(attempt - 1)), maxRetryDelay)\n                    let jitter = delay * Double.random(in: 0.1...0.2)\n                    let totalDelay = delay + jitter\n\n                    logger(\"Transient error (attempt \\(attempt)/\\(maxRetryAttempts)): \\(error.localizedDescription)\")\n                    logger(\"Retrying in \\(String(format: \"%.1f\", totalDelay))s...\")\n\n                    Thread.sleep(forTimeInterval: totalDelay)\n                } else {\n                    break\n                }\n            }\n        }\n\n        if let error = lastError {\n            logger(\"ERROR: Sync failed after \\(attempt) attempt(s): \\(error.localizedDescription)\")\n        }\n    }\n\n    /// Export newly synced messages to Swiftea/Mail/ as markdown files\n    /// Messages are grouped by conversation/thread for better organization.\n    private func performAutoExport() {\n        let exporter = MailExporter(mailDatabase: mailDatabase)\n\n        do {\n            let exportResult = try exporter.exportNewMessages(to: exportDir)\n\n            if exportResult.exported > 0 {\n                var details: [String] = []\n                if exportResult.threadsExported > 0 {\n                    details.append(\"\\(exportResult.threadsExported) threads\")\n                }\n                if exportResult.unthreadedExported > 0 {\n                    details.append(\"\\(exportResult.unthreadedExported) unthreaded\")\n                }\n                let detailStr = details.isEmpty ? \"\" : \" (\\(details.joined(separator: \", \")))\"\n                logger(\"Auto-export: \\(exportResult.exported) message(s) to Swiftea/Mail/\\(detailStr)\")\n            }\n\n            if !exportResult.errors.isEmpty {\n                logger(\"  \\(exportResult.errors.count) export warning(s)\")\n            }\n        } catch {\n            logger(\"ERROR: Auto-export failed: \\(error.localizedDescription)\")\n        }\n    }\n\n    /// Process pending backward sync actions (archive/delete from SwiftEA to Apple Mail)\n    private func performBackwardSync() {\n        do {\n            let result = try backwardSync.processPendingActions()\n\n            // Log results if any actions were processed\n            if result.archived > 0 || result.deleted > 0 {\n                logger(\"Backward sync: \\(result.archived) archived, \\(result.deleted) deleted\")\n            }\n\n            // Log warnings for failed actions\n            if result.failed > 0 {\n                logger(\"WARNING: Backward sync failed for \\(result.failed) message(s)\")\n                for error in result.errors.prefix(3) {\n                    logger(\"  - \\(error)\")\n                }\n                if result.errors.count > 3 {\n                    logger(\"  ... and \\(result.errors.count - 3) more errors\")\n                }\n            }\n        } catch {\n            logger(\"ERROR: Backward sync failed: \\(error.localizedDescription)\")\n        }\n    }\n}\n\n/// Perform a sync in daemon mode with retry logic.\n/// This is a standalone function for use during daemon startup.\nprivate func performDaemonSync(mailDatabase: MailDatabase, exportDir: String) {\n    let maxRetryAttempts = 5\n    let baseRetryDelay: TimeInterval = 2.0\n    let maxRetryDelay: TimeInterval = 60.0\n\n    var attempt = 0\n\n    while attempt < maxRetryAttempts {\n        do {\n            let sync = MailSync(mailDatabase: mailDatabase)\n            let result = try sync.sync()\n\n            let timestamp = ISO8601DateFormatter().string(from: Date())\n            fputs(\"[\\(timestamp)] Sync complete: +\\(result.messagesAdded) ~\\(result.messagesUpdated) (\\(String(format: \"%.2f\", result.duration))s)\\n\", stdout)\n            fflush(stdout)\n\n            // Auto-export new messages after successful sync\n            performDaemonAutoExport(mailDatabase: mailDatabase, exportDir: exportDir)\n\n            // Process pending backward sync actions (archive/delete from SwiftEA to Apple Mail)\n            performDaemonBackwardSync(mailDatabase: mailDatabase)\n            return\n\n        } catch {\n            attempt += 1\n\n            let description = error.localizedDescription.lowercased()\n            let isTransient = description.contains(\"locked\") ||\n                              description.contains(\"busy\") ||\n                              description.contains(\"timeout\") ||\n                              description.contains(\"temporarily\") ||\n                              description.contains(\"try again\")\n\n            if isTransient && attempt < maxRetryAttempts {\n                let delay = min(baseRetryDelay * pow(2.0, Double(attempt - 1)), maxRetryDelay)\n                let jitter = delay * Double.random(in: 0.1...0.2)\n                let totalDelay = delay + jitter\n\n                let timestamp = ISO8601DateFormatter().string(from: Date())\n                fputs(\"[\\(timestamp)] Transient error (attempt \\(attempt)/\\(maxRetryAttempts)): \\(error.localizedDescription)\\n\", stdout)\n                fputs(\"[\\(timestamp)] Retrying in \\(String(format: \"%.1f\", totalDelay))s...\\n\", stdout)\n                fflush(stdout)\n\n                Thread.sleep(forTimeInterval: totalDelay)\n            } else {\n                let timestamp = ISO8601DateFormatter().string(from: Date())\n                fputs(\"[\\(timestamp)] ERROR: Initial sync failed: \\(error.localizedDescription)\\n\", stderr)\n                fflush(stderr)\n                return\n            }\n        }\n    }\n}\n\n/// Perform auto-export in daemon mode\n/// Messages are grouped by conversation/thread for better organization.\nprivate func performDaemonAutoExport(mailDatabase: MailDatabase, exportDir: String) {\n    let exporter = MailExporter(mailDatabase: mailDatabase)\n\n    do {\n        let exportResult = try exporter.exportNewMessages(to: exportDir)\n\n        if exportResult.exported > 0 {\n            let timestamp = ISO8601DateFormatter().string(from: Date())\n            var details: [String] = []\n            if exportResult.threadsExported > 0 {\n                details.append(\"\\(exportResult.threadsExported) threads\")\n            }\n            if exportResult.unthreadedExported > 0 {\n                details.append(\"\\(exportResult.unthreadedExported) unthreaded\")\n            }\n            let detailStr = details.isEmpty ? \"\" : \" (\\(details.joined(separator: \", \")))\"\n            fputs(\"[\\(timestamp)] Auto-export: \\(exportResult.exported) message(s) to Swiftea/Mail/\\(detailStr)\\n\", stdout)\n            fflush(stdout)\n        }\n\n        if !exportResult.errors.isEmpty {\n            let timestamp = ISO8601DateFormatter().string(from: Date())\n            fputs(\"[\\(timestamp)]   \\(exportResult.errors.count) export warning(s)\\n\", stdout)\n            fflush(stdout)\n        }\n    } catch {\n        let timestamp = ISO8601DateFormatter().string(from: Date())\n        fputs(\"[\\(timestamp)] ERROR: Auto-export failed: \\(error.localizedDescription)\\n\", stderr)\n        fflush(stderr)\n    }\n}\n\n/// Process pending backward sync actions in daemon mode (archive/delete from SwiftEA to Apple Mail)\nprivate func performDaemonBackwardSync(mailDatabase: MailDatabase) {\n    let backwardSync = MailSyncBackward(mailDatabase: mailDatabase)\n\n    do {\n        let result = try backwardSync.processPendingActions()\n\n        // Log results if any actions were processed\n        if result.archived > 0 || result.deleted > 0 {\n            let timestamp = ISO8601DateFormatter().string(from: Date())\n            fputs(\"[\\(timestamp)] Backward sync: \\(result.archived) archived, \\(result.deleted) deleted\\n\", stdout)\n            fflush(stdout)\n        }\n\n        // Log warnings for failed actions\n        if result.failed > 0 {\n            let timestamp = ISO8601DateFormatter().string(from: Date())\n            fputs(\"[\\(timestamp)] WARNING: Backward sync failed for \\(result.failed) message(s)\\n\", stdout)\n            fflush(stdout)\n            for error in result.errors.prefix(3) {\n                fputs(\"[\\(timestamp)]   - \\(error)\\n\", stdout)\n            }\n            if result.errors.count > 3 {\n                fputs(\"[\\(timestamp)]   ... and \\(result.errors.count - 3) more errors\\n\", stdout)\n            }\n            fflush(stdout)\n        }\n    } catch {\n        let timestamp = ISO8601DateFormatter().string(from: Date())\n        fputs(\"[\\(timestamp)] ERROR: Backward sync failed: \\(error.localizedDescription)\\n\", stderr)\n        fflush(stderr)\n    }\n}\n\nstruct MailSearchCommand: ParsableCommand {\n    static let configuration = CommandConfiguration(\n        commandName: \"search\",\n        abstract: \"Search mail using full-text search with structured filters\",\n        discussion: \"\"\"\n            Search for mail messages using full-text search and/or structured filters.\n\n            STRUCTURED FILTERS:\n              from:email       - Filter by sender email or name\n              to:email         - Filter by recipient email or name\n              subject:text     - Filter by subject containing text\n              mailbox:name     - Filter by mailbox name\n              is:read          - Show only read messages\n              is:unread        - Show only unread messages\n              is:flagged       - Show only flagged messages\n              is:unflagged     - Show only unflagged messages\n              has:attachments  - Show only messages with attachments\n              after:YYYY-MM-DD - Messages received after date\n              before:YYYY-MM-DD - Messages received before date\n              date:YYYY-MM-DD  - Messages received on specific date\n\n            STATUS FILTER (--status):\n              inbox    - Messages in your inbox\n              archived - Messages you've archived\n              deleted  - Messages you've deleted\n\n            EXAMPLES:\n              swea mail search \"from:alice@example.com project\"\n              swea mail search \"is:unread is:flagged\"\n              swea mail search \"after:2024-01-01 before:2024-02-01\"\n              swea mail search \"mailbox:INBOX from:support\"\n              swea mail search --status inbox \"from:support\"\n              swea mail search --status archived \"\"\n\n            Use quotes around values with spaces: from:\"Alice Smith\"\n            \"\"\"\n    )\n\n    @Argument(help: \"Search query with optional structured filters\")\n    var query: String\n\n    @Option(name: .long, help: \"Filter by mailbox status: inbox, archived, deleted\")\n    var status: String?\n\n    @Option(name: .long, help: \"Maximum results to return\")\n    var limit: Int = 20\n\n    @Flag(name: .long, help: \"Output as JSON\")\n    var json: Bool = false\n\n    func validate() throws {\n        // --limit must be a positive integer\n        if limit <= 0 {\n            throw MailValidationError.invalidLimit\n        }\n\n        // --status must be a valid value if provided\n        if let status = status {\n            let validStatuses = [\"inbox\", \"archived\", \"deleted\"]\n            if !validStatuses.contains(status.lowercased()) {\n                throw MailValidationError.invalidStatus(value: status)\n            }\n        }\n    }\n\n    func run() throws {\n        let vault = try VaultContext.require()\n\n        // Open mail database\n        let mailDbPath = (vault.dataFolderPath as NSString).appendingPathComponent(\"mail.db\")\n        let mailDatabase = MailDatabase(databasePath: mailDbPath)\n        try mailDatabase.initialize()\n        defer { mailDatabase.close() }\n\n        // Parse the query for structured filters\n        var filter = mailDatabase.parseQuery(query)\n\n        // Apply --status option if provided\n        if let statusValue = status {\n            filter.mailboxStatus = MailboxStatus(rawValue: statusValue.lowercased())\n        }\n\n        // Use structured search if we have filters, otherwise fall back to basic FTS\n        let results: [MailMessage]\n        if filter.hasFilters || filter.hasFreeText {\n            results = try mailDatabase.searchMessagesWithFilters(filter, limit: limit)\n        } else {\n            // Empty query - show recent messages\n            results = try mailDatabase.getAllMessages(limit: limit)\n        }\n\n        if results.isEmpty {\n            printError(\"No messages found for: \\(query)\")\n            return\n        }\n\n        if json {\n            // Output as JSON with filter info\n            var output: [[String: Any]] = []\n            for msg in results {\n                let msgDict: [String: Any] = [\n                    \"id\": msg.id,\n                    \"subject\": msg.subject,\n                    \"sender\": msg.senderEmail ?? \"\",\n                    \"senderName\": msg.senderName ?? \"\",\n                    \"date\": msg.dateSent?.description ?? \"\",\n                    \"mailbox\": msg.mailboxName ?? \"\",\n                    \"isRead\": msg.isRead,\n                    \"isFlagged\": msg.isFlagged,\n                    \"hasAttachments\": msg.hasAttachments\n                ]\n                output.append(msgDict)\n            }\n            if let data = try? JSONSerialization.data(withJSONObject: output, options: .prettyPrinted),\n               let jsonString = String(data: data, encoding: .utf8) {\n                print(jsonString)\n            }\n        } else {\n            // Show filter summary if structured filters were used\n            if filter.hasFilters {\n                var filterDesc: [String] = []\n                if let from = filter.from { filterDesc.append(\"from:\\(from)\") }\n                if let to = filter.to { filterDesc.append(\"to:\\(to)\") }\n                if let subject = filter.subject { filterDesc.append(\"subject:\\(subject)\") }\n                if let mailbox = filter.mailbox { filterDesc.append(\"mailbox:\\(mailbox)\") }\n                if let mailboxStatus = filter.mailboxStatus { filterDesc.append(\"status:\\(mailboxStatus.rawValue)\") }\n                if let isRead = filter.isRead { filterDesc.append(isRead ? \"is:read\" : \"is:unread\") }\n                if let isFlagged = filter.isFlagged { filterDesc.append(isFlagged ? \"is:flagged\" : \"is:unflagged\") }\n                if filter.hasAttachments == true { filterDesc.append(\"has:attachments\") }\n                if filter.dateAfter != nil || filter.dateBefore != nil {\n                    let df = DateFormatter()\n                    df.dateFormat = \"yyyy-MM-dd\"\n                    if let after = filter.dateAfter { filterDesc.append(\"after:\\(df.string(from: after))\") }\n                    if let before = filter.dateBefore { filterDesc.append(\"before:\\(df.string(from: before))\") }\n                }\n                print(\"Filters: \\(filterDesc.joined(separator: \" \"))\")\n                if let freeText = filter.freeText {\n                    print(\"Search: \\(freeText)\")\n                }\n                print(\"\")\n            }\n\n            print(\"Found \\(results.count) message(s):\\n\")\n            for msg in results {\n                let date = msg.dateSent.map { DateFormatter.localizedString(from: $0, dateStyle: .short, timeStyle: .short) } ?? \"Unknown\"\n                let sender = msg.senderName ?? msg.senderEmail ?? \"Unknown\"\n                var flags: [String] = []\n                if !msg.isRead { flags.append(\"UNREAD\") }\n                if msg.isFlagged { flags.append(\"FLAGGED\") }\n                if msg.hasAttachments { flags.append(\"ATTACH\") }\n                let flagStr = flags.isEmpty ? \"\" : \" [\\(flags.joined(separator: \", \"))]\"\n\n                print(\"[\\(msg.id)]\\(flagStr)\")\n                print(\"  Subject: \\(msg.subject)\")\n                print(\"  From: \\(sender)\")\n                print(\"  Date: \\(date)\")\n                print(\"  Mailbox: \\(msg.mailboxName ?? \"Unknown\")\")\n                print(\"\")\n            }\n        }\n    }\n}\n\nstruct MailShowCommand: ParsableCommand {\n    static let configuration = CommandConfiguration(\n        commandName: \"show\",\n        abstract: \"Display a single email message\"\n    )\n\n    @Argument(help: \"Message ID to display\")\n    var id: String\n\n    @Flag(name: .long, help: \"Show HTML body instead of plain text\")\n    var html: Bool = false\n\n    @Flag(name: .long, help: \"Show raw .emlx content\")\n    var raw: Bool = false\n\n    @Flag(name: .long, help: \"Output as JSON\")\n    var json: Bool = false\n\n    func run() throws {\n        let vault = try VaultContext.require()\n\n        // Open mail database\n        let mailDbPath = (vault.dataFolderPath as NSString).appendingPathComponent(\"mail.db\")\n        let mailDatabase = MailDatabase(databasePath: mailDbPath)\n        try mailDatabase.initialize()\n        defer { mailDatabase.close() }\n\n        guard let message = try mailDatabase.getMessage(id: id) else {\n            printError(\"Message not found: \\(id)\")\n            throw ExitCode.failure\n        }\n\n        // Handle --raw flag: read original .emlx file\n        if raw {\n            guard let emlxPath = message.emlxPath else {\n                printError(\"No .emlx path available for this message\")\n                throw ExitCode.failure\n            }\n\n            // Check for EWS (Exchange) mailbox paths which contain \"ews:\" prefix\n            // These are cloud-based mailboxes that don't have local .emlx files\n            if emlxPath.contains(\"ews:\") || emlxPath.contains(\"/ews:/\") {\n                printError(\"Raw .emlx viewing is not available for Exchange (EWS) mailboxes.\")\n                printError(\"Exchange messages are stored on the server, not as local .emlx files.\")\n                printError(\"Use 'mail show \\(id)' without --raw to view the message content.\")\n                throw ExitCode.failure\n            }\n\n            guard let content = try? String(contentsOfFile: emlxPath, encoding: .utf8) else {\n                printError(\"Could not read .emlx file: \\(emlxPath)\")\n                throw ExitCode.failure\n            }\n            print(content)\n            return\n        }\n\n        // Handle --json flag\n        if json {\n            let output: [String: Any] = [\n                \"id\": message.id,\n                \"messageId\": message.messageId ?? \"\",\n                \"subject\": message.subject,\n                \"from\": formatSender(message),\n                \"date\": message.dateSent?.iso8601String ?? \"\",\n                \"mailbox\": message.mailboxName ?? \"\",\n                \"isRead\": message.isRead,\n                \"isFlagged\": message.isFlagged,\n                \"hasAttachments\": message.hasAttachments,\n                \"body\": html ? (message.bodyHtml ?? \"\") : (message.bodyText ?? \"\")\n            ]\n            if let data = try? JSONSerialization.data(withJSONObject: output, options: .prettyPrinted),\n               let jsonString = String(data: data, encoding: .utf8) {\n                print(jsonString)\n            }\n            return\n        }\n\n        // Default: formatted text output\n        let date = message.dateSent.map { DateFormatter.localizedString(from: $0, dateStyle: .long, timeStyle: .long) } ?? \"Unknown\"\n        let sender = formatSender(message)\n\n        print(\"Subject: \\(message.subject)\")\n        print(\"From: \\(sender)\")\n        print(\"Date: \\(date)\")\n        print(\"Mailbox: \\(message.mailboxName ?? \"Unknown\")\")\n        if message.hasAttachments {\n            print(\"Attachments: Yes\")\n        }\n        print(\"\")\n        print(String(repeating: \"-\", count: 60))\n        print(\"\")\n\n        // Show body content\n        if html {\n            if let htmlBody = message.bodyHtml {\n                print(htmlBody)\n            } else {\n                print(\"(No HTML body available)\")\n            }\n        } else {\n            if let textBody = message.bodyText {\n                print(textBody)\n            } else if let htmlBody = message.bodyHtml {\n                // Fallback: strip HTML tags for plain text display\n                print(stripHtml(htmlBody))\n            } else {\n                print(\"(No message body available)\")\n            }\n        }\n    }\n\n    private func formatSender(_ message: MailMessage) -> String {\n        if let name = message.senderName, let email = message.senderEmail {\n            return \"\\(name) <\\(email)>\"\n        } else if let email = message.senderEmail {\n            return email\n        } else if let name = message.senderName {\n            return name\n        }\n        return \"Unknown\"\n    }\n\n    private func stripHtml(_ html: String) -> String {\n        // Simple HTML tag stripping\n        var result = html\n        // Remove script and style blocks\n        result = result.replacingOccurrences(of: \"<script[^>]*>.*?</script>\", with: \"\", options: .regularExpression)\n        result = result.replacingOccurrences(of: \"<style[^>]*>.*?</style>\", with: \"\", options: .regularExpression)\n        // Replace common entities\n        result = result.replacingOccurrences(of: \"&nbsp;\", with: \" \")\n        result = result.replacingOccurrences(of: \"&amp;\", with: \"&\")\n        result = result.replacingOccurrences(of: \"&lt;\", with: \"<\")\n        result = result.replacingOccurrences(of: \"&gt;\", with: \">\")\n        result = result.replacingOccurrences(of: \"&quot;\", with: \"\\\"\")\n        // Replace <br> and </p> with newlines\n        result = result.replacingOccurrences(of: \"<br[^>]*>\", with: \"\\n\", options: .regularExpression)\n        result = result.replacingOccurrences(of: \"</p>\", with: \"\\n\\n\")\n        // Remove all remaining tags\n        result = result.replacingOccurrences(of: \"<[^>]+>\", with: \"\", options: .regularExpression)\n        // Collapse multiple newlines\n        result = result.replacingOccurrences(of: \"\\n{3,}\", with: \"\\n\\n\", options: .regularExpression)\n        return result.trimmingCharacters(in: .whitespacesAndNewlines)\n    }\n}\n\n// MARK: - Thread Command\n\nstruct MailThreadCommand: ParsableCommand {\n    static let configuration = CommandConfiguration(\n        commandName: \"thread\",\n        abstract: \"Display all messages in an email thread\",\n        discussion: \"\"\"\n            Shows all messages in a conversation thread, ordered chronologically.\n            Displays thread metadata including subject, participants, and date range.\n\n            EXAMPLES\n              swea mail thread abc123                    # Display thread (default: text)\n              swea mail thread abc123 --format json      # Output as JSON for scripting\n              swea mail thread abc123 --format markdown  # Output as Markdown\n              swea mail thread abc123 --html             # Show HTML bodies instead of plain text\n            \"\"\"\n    )\n\n    @Argument(help: \"Thread ID to display\")\n    var id: String\n\n    @Flag(name: .long, help: \"Show HTML body instead of plain text\")\n    var html: Bool = false\n\n    @Option(name: .long, help: \"Output format: text (default), json, or markdown\")\n    var format: ThreadOutputFormat = .text\n\n    func run() throws {\n        let vault = try VaultContext.require()\n\n        // Open mail database\n        let mailDbPath = (vault.dataFolderPath as NSString).appendingPathComponent(\"mail.db\")\n        let mailDatabase = MailDatabase(databasePath: mailDbPath)\n        try mailDatabase.initialize()\n        defer { mailDatabase.close() }\n\n        // Get thread by ID\n        guard let thread = try mailDatabase.getThread(id: id) else {\n            printError(\"Thread not found: \\(id)\")\n            printError(\"\")\n            printError(\"To find available threads, try:\")\n            printError(\"  swea mail export-threads --limit 10   # Export recent threads\")\n            printError(\"  swea mail search <query>              # Search for messages\")\n            throw ExitCode.failure\n        }\n\n        // Get all messages in the thread, sorted chronologically\n        let messages = try mailDatabase.getMessagesInThreadViaJunction(threadId: thread.id, limit: 10000)\n\n        // Extract thread properties to avoid type ambiguity with Foundation.Thread\n        let threadId = thread.id\n        let threadSubject = thread.subject\n        let participantCount = thread.participantCount\n        let messageCount = thread.messageCount\n        let firstDate = thread.firstDate\n        let lastDate = thread.lastDate\n\n        switch format {\n        case .json:\n            outputAsJson(\n                threadId: threadId,\n                subject: threadSubject,\n                participantCount: participantCount,\n                messageCount: messageCount,\n                firstDate: firstDate,\n                lastDate: lastDate,\n                messages: messages\n            )\n        case .markdown, .md:\n            outputAsMarkdown(\n                threadId: threadId,\n                subject: threadSubject,\n                participantCount: participantCount,\n                messageCount: messageCount,\n                firstDate: firstDate,\n                lastDate: lastDate,\n                messages: messages\n            )\n        case .text:\n            outputAsText(\n                threadId: threadId,\n                subject: threadSubject,\n                participantCount: participantCount,\n                messageCount: messageCount,\n                firstDate: firstDate,\n                lastDate: lastDate,\n                messages: messages\n            )\n        }\n    }\n\n    private func outputAsJson(\n        threadId: String,\n        subject: String?,\n        participantCount: Int,\n        messageCount: Int,\n        firstDate: Date?,\n        lastDate: Date?,\n        messages: [MailMessage]\n    ) {\n        let threadTotal = messages.count\n\n        // Build messages array with thread position\n        var messagesArray: [[String: Any]] = []\n        for (index, message) in messages.enumerated() {\n            let position = index + 1\n            messagesArray.append([\n                \"id\": message.id,\n                \"messageId\": message.messageId ?? \"\",\n                \"subject\": message.subject,\n                \"from\": [\n                    \"name\": message.senderName ?? \"\",\n                    \"email\": message.senderEmail ?? \"\"\n                ],\n                \"date\": message.dateSent?.iso8601String ?? \"\",\n                \"mailbox\": message.mailboxName ?? \"\",\n                \"isRead\": message.isRead,\n                \"isFlagged\": message.isFlagged,\n                \"hasAttachments\": message.hasAttachments,\n                \"body\": html ? (message.bodyHtml ?? \"\") : (message.bodyText ?? message.bodyHtml.map { stripHtml($0) } ?? \"\"),\n                \"thread_position\": position,\n                \"thread_total\": threadTotal\n            ])\n        }\n\n        // Build thread structure\n        let output: [String: Any] = [\n            \"thread_id\": threadId,\n            \"subject\": subject ?? \"\",\n            \"participant_count\": participantCount,\n            \"message_count\": messageCount,\n            \"first_date\": firstDate?.iso8601String ?? \"\",\n            \"last_date\": lastDate?.iso8601String ?? \"\",\n            \"messages\": messagesArray\n        ]\n\n        if let data = try? JSONSerialization.data(withJSONObject: output, options: [.prettyPrinted, .sortedKeys]),\n           let jsonString = String(data: data, encoding: .utf8) {\n            print(jsonString)\n        }\n    }\n\n    private func outputAsMarkdown(\n        threadId: String,\n        subject: String?,\n        participantCount: Int,\n        messageCount: Int,\n        firstDate: Date?,\n        lastDate: Date?,\n        messages: [MailMessage]\n    ) {\n        let threadTotal = messages.count\n        let dateFormatter = ISO8601DateFormatter()\n        dateFormatter.formatOptions = [.withInternetDateTime]\n\n        // YAML frontmatter\n        print(\"---\")\n        print(\"thread_id: \\(threadId)\")\n        print(\"subject: \\\"\\(escapeYaml(subject ?? \"(No Subject)\"))\\\"\")\n        print(\"participant_count: \\(participantCount)\")\n        print(\"message_count: \\(messageCount)\")\n        if let firstDate = firstDate {\n            print(\"first_date: \\(dateFormatter.string(from: firstDate))\")\n        }\n        if let lastDate = lastDate {\n            print(\"last_date: \\(dateFormatter.string(from: lastDate))\")\n        }\n        print(\"---\")\n        print(\"\")\n\n        // Thread header\n        print(\"# \\(subject ?? \"(No Subject)\")\")\n        print(\"\")\n        print(\"**Thread ID:** `\\(threadId)`  \")\n        print(\"**Participants:** \\(participantCount)  \")\n        print(\"**Messages:** \\(messageCount)\")\n        print(\"\")\n\n        if let firstDate = firstDate, let lastDate = lastDate {\n            let firstFormatted = DateFormatter.localizedString(from: firstDate, dateStyle: .long, timeStyle: .short)\n            let lastFormatted = DateFormatter.localizedString(from: lastDate, dateStyle: .long, timeStyle: .short)\n            print(\"**Date Range:** \\(firstFormatted) â†’ \\(lastFormatted)\")\n            print(\"\")\n        }\n\n        print(\"---\")\n        print(\"\")\n\n        // Display each message\n        for (index, message) in messages.enumerated() {\n            let position = index + 1\n\n            print(\"## [\\(position)/\\(threadTotal)] \\(message.subject)\")\n            print(\"\")\n            print(\"**From:** \\(formatSender(message))  \")\n            if let date = message.dateSent {\n                let dateFormatted = DateFormatter.localizedString(from: date, dateStyle: .long, timeStyle: .long)\n                print(\"**Date:** \\(dateFormatted)  \")\n            }\n            if let mailbox = message.mailboxName {\n                print(\"**Mailbox:** \\(mailbox)  \")\n            }\n            if message.hasAttachments {\n                print(\"**Attachments:** Yes\")\n            }\n            print(\"\")\n\n            // Body content in a blockquote for better formatting\n            let body: String\n            if html {\n                body = message.bodyHtml ?? \"(No HTML body available)\"\n            } else if let textBody = message.bodyText, !textBody.isEmpty {\n                body = textBody\n            } else if let htmlBody = message.bodyHtml {\n                body = stripHtml(htmlBody)\n            } else {\n                body = \"(No message body available)\"\n            }\n\n            // Output body - preserve line breaks for readability\n            print(body)\n            print(\"\")\n\n            // Separator between messages\n            if index < messages.count - 1 {\n                print(\"---\")\n                print(\"\")\n            }\n        }\n\n        // Footer\n        print(\"\")\n        print(\"---\")\n        print(\"\")\n        print(\"*End of thread (\\(threadTotal) message(s))*\")\n    }\n\n    private func escapeYaml(_ string: String) -> String {\n        return string.replacingOccurrences(of: \"\\\"\", with: \"\\\\\\\"\")\n    }\n\n    private func outputAsText(\n        threadId: String,\n        subject: String?,\n        participantCount: Int,\n        messageCount: Int,\n        firstDate: Date?,\n        lastDate: Date?,\n        messages: [MailMessage]\n    ) {\n        let threadTotal = messages.count\n\n        // Thread header with metadata\n        print(\"Thread: \\(subject ?? \"(No Subject)\")\")\n        print(String(repeating: \"=\", count: 70))\n        print(\"\")\n        print(\"Thread ID: \\(threadId)\")\n        print(\"Participants: \\(participantCount)\")\n        print(\"Messages: \\(messageCount)\")\n        if let firstDate = firstDate, let lastDate = lastDate {\n            let firstFormatted = DateFormatter.localizedString(from: firstDate, dateStyle: .long, timeStyle: .short)\n            let lastFormatted = DateFormatter.localizedString(from: lastDate, dateStyle: .long, timeStyle: .short)\n            print(\"Date Range: \\(firstFormatted) â†’ \\(lastFormatted)\")\n        }\n        print(\"\")\n        print(String(repeating: \"=\", count: 70))\n\n        // Display each message chronologically\n        for (index, message) in messages.enumerated() {\n            let position = index + 1\n            print(\"\")\n            print(\"[\\(position)/\\(threadTotal)] \\(message.subject)\")\n            print(String(repeating: \"-\", count: 60))\n            print(\"From: \\(formatSender(message))\")\n            if let date = message.dateSent {\n                let dateFormatted = DateFormatter.localizedString(from: date, dateStyle: .long, timeStyle: .long)\n                print(\"Date: \\(dateFormatted)\")\n            }\n            if let mailbox = message.mailboxName {\n                print(\"Mailbox: \\(mailbox)\")\n            }\n            if message.hasAttachments {\n                print(\"Attachments: Yes\")\n            }\n            print(\"\")\n\n            // Body content\n            if html {\n                if let htmlBody = message.bodyHtml {\n                    print(htmlBody)\n                } else {\n                    print(\"(No HTML body available)\")\n                }\n            } else {\n                if let textBody = message.bodyText, !textBody.isEmpty {\n                    print(textBody)\n                } else if let htmlBody = message.bodyHtml {\n                    print(stripHtml(htmlBody))\n                } else {\n                    print(\"(No message body available)\")\n                }\n            }\n        }\n\n        // Footer\n        print(\"\")\n        print(String(repeating: \"=\", count: 70))\n        print(\"End of thread (\\(threadTotal) message(s))\")\n    }\n\n    private func formatSender(_ message: MailMessage) -> String {\n        if let name = message.senderName, let email = message.senderEmail {\n            return \"\\(name) <\\(email)>\"\n        } else if let email = message.senderEmail {\n            return email\n        } else if let name = message.senderName {\n            return name\n        }\n        return \"Unknown\"\n    }\n\n    private func stripHtml(_ html: String) -> String {\n        var result = html\n        result = result.replacingOccurrences(of: \"<script[^>]*>.*?</script>\", with: \"\", options: .regularExpression)\n        result = result.replacingOccurrences(of: \"<style[^>]*>.*?</style>\", with: \"\", options: .regularExpression)\n        result = result.replacingOccurrences(of: \"&nbsp;\", with: \" \")\n        result = result.replacingOccurrences(of: \"&amp;\", with: \"&\")\n        result = result.replacingOccurrences(of: \"&lt;\", with: \"<\")\n        result = result.replacingOccurrences(of: \"&gt;\", with: \">\")\n        result = result.replacingOccurrences(of: \"&quot;\", with: \"\\\"\")\n        result = result.replacingOccurrences(of: \"<br[^>]*>\", with: \"\\n\", options: .regularExpression)\n        result = result.replacingOccurrences(of: \"</p>\", with: \"\\n\\n\")\n        result = result.replacingOccurrences(of: \"<[^>]+>\", with: \"\", options: .regularExpression)\n        result = result.replacingOccurrences(of: \"\\n{3,}\", with: \"\\n\\n\", options: .regularExpression)\n        return result.trimmingCharacters(in: .whitespacesAndNewlines)\n    }\n}\n\n// MARK: - Threads Command (List all threads)\n\nstruct MailThreadsCommand: ParsableCommand {\n    static let configuration = CommandConfiguration(\n        commandName: \"threads\",\n        abstract: \"List all email threads\",\n        discussion: \"\"\"\n            Lists all email threads (conversations) with their metadata including\n            thread ID, subject, participants, message count, and date range.\n            Threads are ordered by most recent activity by default.\n\n            EXAMPLES\n              swea mail threads                         # List threads (default: text)\n              swea mail threads --limit 100             # List more threads\n              swea mail threads --sort subject          # Sort by subject alphabetically\n              swea mail threads --sort message_count    # Sort by number of messages\n              swea mail threads --participant john@     # Filter by participant email\n              swea mail threads --format json           # Output as JSON for scripting\n              swea mail threads --format markdown       # Output as Markdown\n            \"\"\"\n    )\n\n    @Option(name: .shortAndLong, help: \"Maximum number of threads to display (default: 50)\")\n    var limit: Int = 50\n\n    @Option(name: .shortAndLong, help: \"Number of threads to skip (for pagination)\")\n    var offset: Int = 0\n\n    @Option(name: .shortAndLong, help: \"Sort by: date (default), subject, or message_count\")\n    var sort: ThreadSortOption = .date\n\n    @Option(name: .shortAndLong, help: \"Filter threads by participant email (partial match)\")\n    var participant: String?\n\n    @Option(name: .long, help: \"Output format: text (default), json, or markdown\")\n    var format: ThreadOutputFormat = .text\n\n    func run() throws {\n        let vault = try VaultContext.require()\n\n        // Open mail database\n        let mailDbPath = (vault.dataFolderPath as NSString).appendingPathComponent(\"mail.db\")\n        let mailDatabase = MailDatabase(databasePath: mailDbPath)\n        try mailDatabase.initialize()\n        defer { mailDatabase.close() }\n\n        // Get threads with filtering and sorting options\n        let threads = try mailDatabase.getThreads(\n            limit: limit,\n            offset: offset,\n            sortBy: sort.toDbSortOrder(),\n            participant: participant\n        )\n\n        if threads.isEmpty {\n            if format.isJson {\n                let message = participant != nil\n                    ? \"No threads found matching participant '\\(participant!)'\"\n                    : \"No threads found\"\n                print(\"{\\\"threads\\\": [], \\\"count\\\": 0, \\\"message\\\": \\\"\\(message)\\\"}\")\n            } else {\n                if let participant = participant {\n                    print(\"No email threads found with participant '\\(participant)'.\")\n                } else {\n                    print(\"No email threads found.\")\n                }\n                print(\"\")\n                print(\"To build threads from your synced messages, run:\")\n                print(\"  swea mail sync\")\n                print(\"\")\n                print(\"Threads are automatically created during sync based on\")\n                print(\"email headers (In-Reply-To, References) and subject matching.\")\n            }\n            return\n        }\n\n        let totalCount = try mailDatabase.getThreadCount(participant: participant)\n\n        switch format {\n        case .json:\n            outputAsJson(threads: threads, totalCount: totalCount)\n        case .markdown, .md:\n            outputAsMarkdown(threads: threads, totalCount: totalCount)\n        case .text:\n            outputAsText(threads: threads, totalCount: totalCount)\n        }\n    }\n\n    private func outputAsJson<T: ThreadLike>(threads: [T], totalCount: Int) {\n        var threadsArray: [[String: Any]] = []\n        for thread in threads {\n            var threadDict: [String: Any] = [\n                \"id\": thread.id,\n                \"subject\": thread.subject ?? \"\",\n                \"participant_count\": thread.participantCount,\n                \"message_count\": thread.messageCount\n            ]\n            if let firstDate = thread.firstDate {\n                threadDict[\"first_date\"] = firstDate.iso8601String\n            }\n            if let lastDate = thread.lastDate {\n                threadDict[\"last_date\"] = lastDate.iso8601String\n            }\n            threadsArray.append(threadDict)\n        }\n\n        var output: [String: Any] = [\n            \"threads\": threadsArray,\n            \"count\": threads.count,\n            \"total\": totalCount,\n            \"offset\": offset,\n            \"limit\": limit,\n            \"sort\": sort.rawValue\n        ]\n        if let participant = participant {\n            output[\"participant_filter\"] = participant\n        }\n\n        if let data = try? JSONSerialization.data(withJSONObject: output, options: [.prettyPrinted, .sortedKeys]),\n           let jsonString = String(data: data, encoding: .utf8) {\n            print(jsonString)\n        }\n    }\n\n    private func outputAsMarkdown<T: ThreadLike>(threads: [T], totalCount: Int) {\n        let dateFormatter = ISO8601DateFormatter()\n        dateFormatter.formatOptions = [.withInternetDateTime]\n\n        // YAML frontmatter\n        print(\"---\")\n        print(\"type: thread_list\")\n        print(\"count: \\(threads.count)\")\n        print(\"total: \\(totalCount)\")\n        print(\"offset: \\(offset)\")\n        print(\"limit: \\(limit)\")\n        print(\"sort: \\(sort.rawValue)\")\n        if let participant = participant {\n            print(\"participant_filter: \\(participant)\")\n        }\n        print(\"---\")\n        print(\"\")\n\n        // Header\n        print(\"# Email Threads\")\n        print(\"\")\n        var summaryLine = \"Showing \\(threads.count) of \\(totalCount) threads\"\n        if let participant = participant {\n            summaryLine += \" (filtered by: \\(participant))\"\n        }\n        if sort != .date {\n            summaryLine += \" (sorted by: \\(sort.rawValue))\"\n        }\n        print(summaryLine)\n        print(\"\")\n\n        // Date formatter for display\n        let displayFormatter = DateFormatter()\n        displayFormatter.dateStyle = .medium\n        displayFormatter.timeStyle = .short\n\n        // Table header\n        print(\"| Thread ID | Subject | Participants | Messages | Last Activity |\")\n        print(\"|-----------|---------|--------------|----------|---------------|\")\n\n        for thread in threads {\n            let subject = thread.subject ?? \"(No Subject)\"\n            let truncatedSubject = subject.count > 40 ? String(subject.prefix(37)) + \"...\" : subject\n            let escapedSubject = truncatedSubject.replacingOccurrences(of: \"|\", with: \"\\\\|\")\n            let lastActivity = thread.lastDate.map { displayFormatter.string(from: $0) } ?? \"-\"\n\n            print(\"| `\\(thread.id)` | \\(escapedSubject) | \\(thread.participantCount) | \\(thread.messageCount) | \\(lastActivity) |\")\n        }\n\n        print(\"\")\n\n        // Footer\n        if totalCount > threads.count + offset {\n            print(\"---\")\n            print(\"\")\n            print(\"*Showing \\(offset + 1)-\\(offset + threads.count) of \\(totalCount) threads*\")\n            print(\"\")\n            print(\"To see more threads:\")\n            print(\"```\")\n            print(\"swea mail threads --limit \\(limit) --offset \\(offset + threads.count)\")\n            print(\"```\")\n        }\n\n        print(\"\")\n        print(\"To view a specific thread:\")\n        print(\"```\")\n        print(\"swea mail thread <thread-id>\")\n        print(\"```\")\n    }\n\n    private func outputAsText<T: ThreadLike>(threads: [T], totalCount: Int) {\n        var headerLine = \"Email Threads\"\n        if let participant = participant {\n            headerLine += \" (filtered by: \\(participant))\"\n        }\n        if sort != .date {\n            headerLine += \" (sorted by: \\(sort.rawValue))\"\n        }\n        print(headerLine)\n        print(String(repeating: \"=\", count: 70))\n        print(\"\")\n\n        // Date formatter for consistent display\n        let dateFormatter = DateFormatter()\n        dateFormatter.dateStyle = .medium\n        dateFormatter.timeStyle = .short\n\n        for thread in threads {\n            // Thread ID and subject\n            let subject = thread.subject ?? \"(No Subject)\"\n            print(\"[\\(thread.id)] \\(subject)\")\n\n            // Participants and message count\n            print(\"  Participants: \\(thread.participantCount)  |  Messages: \\(thread.messageCount)\")\n\n            // Date range\n            if let firstDate = thread.firstDate, let lastDate = thread.lastDate {\n                let firstFormatted = dateFormatter.string(from: firstDate)\n                let lastFormatted = dateFormatter.string(from: lastDate)\n                if firstDate == lastDate {\n                    print(\"  Date: \\(firstFormatted)\")\n                } else {\n                    print(\"  Date Range: \\(firstFormatted) â†’ \\(lastFormatted)\")\n                }\n            } else if let lastDate = thread.lastDate {\n                print(\"  Last Activity: \\(dateFormatter.string(from: lastDate))\")\n            }\n\n            print(\"\")\n        }\n\n        // Footer with pagination info\n        print(String(repeating: \"-\", count: 70))\n        if totalCount > threads.count + offset {\n            print(\"Showing \\(offset + 1)-\\(offset + threads.count) of \\(totalCount) threads\")\n            print(\"\")\n            print(\"To see more threads:\")\n            print(\"  swea mail threads --limit \\(limit) --offset \\(offset + threads.count)\")\n        } else {\n            print(\"Showing \\(threads.count) of \\(totalCount) threads\")\n        }\n        print(\"\")\n        print(\"To view a specific thread:\")\n        print(\"  swea mail thread <thread-id>\")\n    }\n}\n\n// Note: ThreadLike protocol is defined in SwiftEAKit.MailDatabase\n// and Thread already conforms to it\n\n/// Output format for mail export command.\n/// Conforms to ExpressibleByArgument for ArgumentParser integration,\n/// enabling type-safe parsing with automatic validation.\npublic enum OutputFormat: String, CaseIterable, ExpressibleByArgument {\n    case markdown\n    case md\n    case json\n\n    /// All valid format values for help text and error messages\n    public static var allValueStrings: [String] {\n        allCases.map { $0.rawValue }\n    }\n\n    /// Check if this format produces JSON output\n    var isJson: Bool {\n        self == .json\n    }\n\n    /// Check if this format produces Markdown output\n    var isMarkdown: Bool {\n        self == .markdown || self == .md\n    }\n\n    /// File extension for this format\n    var fileExtension: String {\n        isJson ? \"json\" : \"md\"\n    }\n}\n\n/// Output format for thread display commands.\n/// Supports text (human-readable), JSON (for scripting), and Markdown (for documentation).\npublic enum ThreadOutputFormat: String, CaseIterable, ExpressibleByArgument {\n    case text\n    case json\n    case markdown\n    case md\n\n    /// All valid format values for help text\n    public static var allValueStrings: [String] {\n        allCases.map { $0.rawValue }\n    }\n\n    /// Check if this format produces JSON output\n    var isJson: Bool {\n        self == .json\n    }\n\n    /// Check if this format produces Markdown output\n    var isMarkdown: Bool {\n        self == .markdown || self == .md\n    }\n\n    /// Check if this format produces plain text output\n    var isText: Bool {\n        self == .text\n    }\n}\n\n/// Sort options for thread listing commands.\n/// Allows sorting threads by date, subject, or message count.\npublic enum ThreadSortOption: String, CaseIterable, ExpressibleByArgument {\n    case date\n    case subject\n    case messageCount = \"message_count\"\n\n    /// All valid sort values for help text\n    public static var allValueStrings: [String] {\n        allCases.map { $0.rawValue }\n    }\n\n    /// Convert to database sort order enum\n    func toDbSortOrder() -> ThreadSortOrder {\n        switch self {\n        case .date:\n            return .date\n        case .subject:\n            return .subject\n        case .messageCount:\n            return .messageCount\n        }\n    }\n}\n\nstruct MailExportCommand: ParsableCommand {\n    static let configuration = CommandConfiguration(\n        commandName: \"export\",\n        abstract: \"Export synced messages to markdown or JSON files\",\n        discussion: \"\"\"\n            Creates .md or .json files from synced messages. Note: 'swea mail sync'\n            now auto-exports new messages, so manual export is usually not needed.\n\n            Default output: Swiftea/Mail/ (same as auto-export)\n            Markdown files include YAML frontmatter for Obsidian compatibility.\n\n            EXAMPLES\n              swea mail export                              # Export all (up to limit)\n              swea mail export --query \"from:alice\"         # Export matching messages\n              swea mail export --output ~/Obsidian/Mail     # Export to custom folder\n              swea mail export --format json                # Export as JSON\n              swea mail export --include-attachments        # Also save attachments\n\n            Use --include-attachments to also extract and save attachment files.\n            Attachments are saved in an 'attachments/<message-id>/' subdirectory.\n\n            THREAD EXPORT\n              swea mail export --format json --thread <thread-id>   # Export full thread structure\n\n            Thread exports include a nested messages array with thread_position for each message.\n            \"\"\"\n    )\n\n    @Option(name: .long, help: \"Export format: \\(OutputFormat.allValueStrings.joined(separator: \", \"))\")\n    var format: OutputFormat = .markdown\n\n    @Option(name: .long, help: \"Message ID to export (or 'all' for all synced messages)\")\n    var id: String = \"all\"\n\n    @Option(name: .shortAndLong, help: \"Output directory (default: Swiftea/Mail/)\")\n    var output: String?\n\n    @Option(name: .long, help: \"Search query to filter messages for export\")\n    var query: String?\n\n    @Option(name: .long, help: \"Maximum messages to export (default: 100)\")\n    var limit: Int = 100\n\n    @Flag(name: .long, help: \"Extract and save attachment files\")\n    var includeAttachments: Bool = false\n\n    @Option(name: .long, help: \"Thread ID to export as full thread structure (JSON only)\")\n    var thread: String?\n\n    func validate() throws {\n        // --limit must be a positive integer\n        if limit <= 0 {\n            throw MailValidationError.invalidLimit\n        }\n        // --thread requires --format json\n        if thread != nil && !format.isJson {\n            throw ValidationError(\"--thread requires --format json\")\n        }\n        // Note: --format validation is handled automatically by ArgumentParser via OutputFormat enum\n    }\n\n    func run() throws {\n        let vault = try VaultContext.require()\n\n        // Determine output directory (default: Swiftea/Mail/ for Obsidian compatibility)\n        let outputDir: String\n        if let specifiedOutput = output {\n            outputDir = specifiedOutput\n        } else {\n            outputDir = (vault.dataFolderPath as NSString).appendingPathComponent(\"Mail\")\n        }\n\n        // Create output directory if needed\n        let fileManager = FileManager.default\n        if !fileManager.fileExists(atPath: outputDir) {\n            try fileManager.createDirectory(atPath: outputDir, withIntermediateDirectories: true)\n        }\n\n        // Open mail database\n        let mailDbPath = (vault.dataFolderPath as NSString).appendingPathComponent(\"mail.db\")\n        let mailDatabase = MailDatabase(databasePath: mailDbPath)\n        try mailDatabase.initialize()\n        defer { mailDatabase.close() }\n\n        // Handle thread export mode\n        if let threadId = thread {\n            try exportThread(threadId: threadId, outputDir: outputDir, database: mailDatabase)\n            return\n        }\n\n        // Get messages to export\n        var messages: [MailMessage] = []\n\n        if id != \"all\" {\n            // Export single message\n            if let message = try mailDatabase.getMessage(id: id) {\n                messages = [message]\n            } else {\n                printError(\"Message not found: \\(id)\")\n                throw ExitCode.failure\n            }\n        } else if let searchQuery = query {\n            // Export messages matching query\n            messages = try mailDatabase.searchMessages(query: searchQuery, limit: limit)\n        } else {\n            // Export all messages (up to limit) - use direct query without FTS\n            messages = try mailDatabase.getAllMessages(limit: limit)\n        }\n\n        if messages.isEmpty {\n            printError(\"No messages to export\")\n            return\n        }\n\n        print(\"Exporting \\(messages.count) message(s) to \\(outputDir)...\")\n\n        var exportedCount = 0\n        var attachmentCount = 0\n        let emlxParser = EmlxParser()\n\n        for message in messages {\n            let filename = generateFilename(for: message)\n            let filePath = (outputDir as NSString).appendingPathComponent(filename)\n\n            let content: String\n            if format.isJson {\n                content = formatAsJson(message)\n            } else {\n                content = formatAsMarkdown(message)\n            }\n\n            try content.write(toFile: filePath, atomically: true, encoding: .utf8)\n\n            // Update export path in database\n            try mailDatabase.updateExportPath(id: message.id, path: filePath)\n            exportedCount += 1\n\n            // Extract attachments if requested\n            if includeAttachments, message.hasAttachments, let emlxPath = message.emlxPath {\n                // Skip EWS/Exchange messages (no local .emlx file)\n                if emlxPath.contains(\"ews:\") || emlxPath.contains(\"/ews:/\") {\n                    continue\n                }\n\n                let attachmentsDir = (outputDir as NSString).appendingPathComponent(\"attachments/\\(message.id)\")\n\n                do {\n                    let attachments = try emlxParser.extractAttachments(path: emlxPath)\n\n                    if !attachments.isEmpty {\n                        // Create attachments directory\n                        if !fileManager.fileExists(atPath: attachmentsDir) {\n                            try fileManager.createDirectory(atPath: attachmentsDir, withIntermediateDirectories: true)\n                        }\n\n                        for attachment in attachments {\n                            let attachmentPath = (attachmentsDir as NSString).appendingPathComponent(attachment.info.filename)\n                            try attachment.data.write(to: URL(fileURLWithPath: attachmentPath))\n                            attachmentCount += 1\n                        }\n                    }\n                } catch {\n                    // Log warning but continue exporting\n                    printError(\"  Warning: Could not extract attachments from \\(message.id): \\(error.localizedDescription)\")\n                }\n            }\n        }\n\n        print(\"Exported \\(exportedCount) message(s) to \\(outputDir)\")\n        if attachmentCount > 0 {\n            print(\"Extracted \\(attachmentCount) attachment(s)\")\n        }\n    }\n\n    private func generateFilename(for message: MailMessage) -> String {\n        // Flat filename using message ID for uniqueness and idempotent overwrites\n        return \"\\(message.id).\\(format.fileExtension)\"\n    }\n\n    private func formatAsMarkdown(_ message: MailMessage) -> String {\n        var lines: [String] = []\n\n        // Minimal YAML frontmatter: id, subject, from, date, aliases\n        lines.append(\"---\")\n        lines.append(\"id: \\\"\\(message.id)\\\"\")\n        lines.append(\"subject: \\\"\\(escapeYaml(message.subject))\\\"\")\n        lines.append(\"from: \\\"\\(escapeYaml(formatSender(message)))\\\"\")\n        if let date = message.dateSent {\n            lines.append(\"date: \\(date.iso8601String)\")\n        }\n        // aliases: use subject as an alias for linking by topic\n        lines.append(\"aliases:\")\n        lines.append(\"  - \\\"\\(escapeYaml(message.subject))\\\"\")\n        lines.append(\"---\")\n        lines.append(\"\")\n\n        // Subject as heading\n        lines.append(\"# \\(message.subject)\")\n        lines.append(\"\")\n\n        // Body content\n        if let textBody = message.bodyText, !textBody.isEmpty {\n            lines.append(textBody)\n        } else if let htmlBody = message.bodyHtml {\n            // Fall back to stripped HTML\n            lines.append(stripHtml(htmlBody))\n        } else {\n            lines.append(\"*(No message body)*\")\n        }\n\n        return lines.joined(separator: \"\\n\")\n    }\n\n    private func formatAsJson(_ message: MailMessage, threadPosition: Int? = nil, threadTotal: Int? = nil) -> String {\n        var output: [String: Any] = [\n            \"id\": message.id,\n            \"messageId\": message.messageId ?? \"\",\n            \"subject\": message.subject,\n            \"from\": [\n                \"name\": message.senderName ?? \"\",\n                \"email\": message.senderEmail ?? \"\"\n            ],\n            \"date\": message.dateSent?.iso8601String ?? \"\",\n            \"mailbox\": message.mailboxName ?? \"\",\n            \"isRead\": message.isRead,\n            \"isFlagged\": message.isFlagged,\n            \"hasAttachments\": message.hasAttachments,\n            \"bodyText\": message.bodyText ?? \"\",\n            \"bodyHtml\": message.bodyHtml ?? \"\"\n        ]\n\n        // Add thread fields if available\n        if let threadId = message.threadId {\n            output[\"thread_id\"] = threadId\n        }\n        if let position = threadPosition {\n            output[\"thread_position\"] = position\n        }\n        if let total = threadTotal {\n            output[\"thread_total\"] = total\n        }\n\n        if let data = try? JSONSerialization.data(withJSONObject: output, options: [.prettyPrinted, .sortedKeys]),\n           let jsonString = String(data: data, encoding: .utf8) {\n            return jsonString\n        }\n        return \"{}\"\n    }\n\n    /// Convert a MailMessage to a dictionary for JSON serialization (used in thread exports)\n    private func messageToDict(_ message: MailMessage, threadPosition: Int, threadTotal: Int) -> [String: Any] {\n        return [\n            \"id\": message.id,\n            \"messageId\": message.messageId ?? \"\",\n            \"subject\": message.subject,\n            \"from\": [\n                \"name\": message.senderName ?? \"\",\n                \"email\": message.senderEmail ?? \"\"\n            ],\n            \"date\": message.dateSent?.iso8601String ?? \"\",\n            \"mailbox\": message.mailboxName ?? \"\",\n            \"isRead\": message.isRead,\n            \"isFlagged\": message.isFlagged,\n            \"hasAttachments\": message.hasAttachments,\n            \"bodyText\": message.bodyText ?? \"\",\n            \"bodyHtml\": message.bodyHtml ?? \"\",\n            \"thread_id\": message.threadId ?? \"\",\n            \"thread_position\": threadPosition,\n            \"thread_total\": threadTotal\n        ]\n    }\n\n    /// Export a thread with full structure including nested messages array\n    private func exportThread(threadId: String, outputDir: String, database: MailDatabase) throws {\n        // Get thread metadata\n        guard let thread = try database.getThread(id: threadId) else {\n            printError(\"Thread not found: \\(threadId)\")\n            throw ExitCode.failure\n        }\n\n        // Get all messages in the thread, sorted by date\n        let messages = try database.getMessagesInThreadViaJunction(threadId: threadId, limit: 10000)\n\n        if messages.isEmpty {\n            printError(\"Thread has no messages: \\(threadId)\")\n            throw ExitCode.failure\n        }\n\n        let threadTotal = messages.count\n\n        // Build nested messages array with thread position\n        var messagesArray: [[String: Any]] = []\n        for (index, message) in messages.enumerated() {\n            let position = index + 1  // 1-indexed position\n            messagesArray.append(messageToDict(message, threadPosition: position, threadTotal: threadTotal))\n        }\n\n        // Build thread export structure\n        let threadExport: [String: Any] = [\n            \"thread_id\": threadId,\n            \"subject\": thread.subject ?? \"\",\n            \"participant_count\": thread.participantCount,\n            \"message_count\": thread.messageCount,\n            \"first_date\": thread.firstDate?.iso8601String ?? \"\",\n            \"last_date\": thread.lastDate?.iso8601String ?? \"\",\n            \"messages\": messagesArray\n        ]\n\n        // Write to file\n        let filename = \"thread-\\(threadId).json\"\n        let filePath = (outputDir as NSString).appendingPathComponent(filename)\n\n        if let data = try? JSONSerialization.data(withJSONObject: threadExport, options: [.prettyPrinted, .sortedKeys]),\n           let jsonString = String(data: data, encoding: .utf8) {\n            try jsonString.write(toFile: filePath, atomically: true, encoding: .utf8)\n            print(\"Exported thread with \\(threadTotal) message(s) to \\(filePath)\")\n        } else {\n            printError(\"Failed to serialize thread to JSON\")\n            throw ExitCode.failure\n        }\n    }\n\n    private func formatSender(_ message: MailMessage) -> String {\n        if let name = message.senderName, let email = message.senderEmail {\n            return \"\\(name) <\\(email)>\"\n        } else if let email = message.senderEmail {\n            return email\n        } else if let name = message.senderName {\n            return name\n        }\n        return \"Unknown\"\n    }\n\n    private func escapeYaml(_ text: String) -> String {\n        text.replacingOccurrences(of: \"\\\"\", with: \"\\\\\\\"\")\n    }\n\n    private func stripHtml(_ html: String) -> String {\n        var result = html\n        result = result.replacingOccurrences(of: \"<script[^>]*>.*?</script>\", with: \"\", options: .regularExpression)\n        result = result.replacingOccurrences(of: \"<style[^>]*>.*?</style>\", with: \"\", options: .regularExpression)\n        result = result.replacingOccurrences(of: \"&nbsp;\", with: \" \")\n        result = result.replacingOccurrences(of: \"&amp;\", with: \"&\")\n        result = result.replacingOccurrences(of: \"&lt;\", with: \"<\")\n        result = result.replacingOccurrences(of: \"&gt;\", with: \">\")\n        result = result.replacingOccurrences(of: \"&quot;\", with: \"\\\"\")\n        result = result.replacingOccurrences(of: \"<br[^>]*>\", with: \"\\n\", options: .regularExpression)\n        result = result.replacingOccurrences(of: \"</p>\", with: \"\\n\\n\")\n        result = result.replacingOccurrences(of: \"<[^>]+>\", with: \"\", options: .regularExpression)\n        result = result.replacingOccurrences(of: \"\\n{3,}\", with: \"\\n\\n\", options: .regularExpression)\n        return result.trimmingCharacters(in: .whitespacesAndNewlines)\n    }\n}\n\n// MARK: - Mail Export Threads Command\n\nstruct MailExportThreadsCommand: ParsableCommand {\n    static let configuration = CommandConfiguration(\n        commandName: \"export-threads\",\n        abstract: \"Export entire email threads as single units\",\n        discussion: \"\"\"\n            Exports complete email threads (conversations) to markdown or JSON files.\n            Each thread is exported as a single file containing all messages in the\n            conversation, ordered chronologically.\n\n            EXAMPLES\n              swea mail export-threads                          # Export all threads (up to limit)\n              swea mail export-threads --thread-id abc123       # Export specific thread\n              swea mail export-threads --format json            # Export as JSON\n              swea mail export-threads --output ~/Threads       # Export to custom folder\n              swea mail export-threads --limit 50               # Export up to 50 threads\n            \"\"\"\n    )\n\n    @Option(name: .long, help: \"Export format: \\(OutputFormat.allValueStrings.joined(separator: \", \"))\")\n    var format: OutputFormat = .markdown\n\n    @Option(name: .long, help: \"Specific thread ID to export\")\n    var threadId: String?\n\n    @Option(name: .shortAndLong, help: \"Output directory (default: Swiftea/Threads/)\")\n    var output: String?\n\n    @Option(name: .long, help: \"Maximum threads to export (default: 100)\")\n    var limit: Int = 100\n\n    func validate() throws {\n        if limit <= 0 {\n            throw MailValidationError.invalidLimit\n        }\n    }\n\n    func run() throws {\n        let vault = try VaultContext.require()\n\n        // Determine output directory (default: Swiftea/Threads/)\n        let outputDir: String\n        if let specifiedOutput = output {\n            outputDir = specifiedOutput\n        } else {\n            outputDir = (vault.dataFolderPath as NSString).appendingPathComponent(\"Threads\")\n        }\n\n        // Create output directory if needed\n        let fileManager = FileManager.default\n        if !fileManager.fileExists(atPath: outputDir) {\n            try fileManager.createDirectory(atPath: outputDir, withIntermediateDirectories: true)\n        }\n\n        // Open mail database\n        let mailDbPath = (vault.dataFolderPath as NSString).appendingPathComponent(\"mail.db\")\n        let mailDatabase = MailDatabase(databasePath: mailDbPath)\n        try mailDatabase.initialize()\n        defer { mailDatabase.close() }\n\n        // Get threads to export - handle single thread vs all threads differently\n        // to avoid type annotation issues with Thread shadowing\n        if let specificThreadId = threadId {\n            // Export single thread\n            guard let thread = try mailDatabase.getThread(id: specificThreadId) else {\n                printError(\"Thread not found: \\(specificThreadId)\")\n                throw ExitCode.failure\n            }\n\n            let filename = \"thread-\\(thread.id).\\(format.fileExtension)\"\n            let filePath = (outputDir as NSString).appendingPathComponent(filename)\n            let messages = try mailDatabase.getMessagesInThreadViaJunction(threadId: thread.id, limit: 10000)\n\n            let content: String\n            if format.isJson {\n                content = formatThreadAsJson(threadId: thread.id, subject: thread.subject, participantCount: thread.participantCount, messageCount: thread.messageCount, firstDate: thread.firstDate, lastDate: thread.lastDate, messages: messages)\n            } else {\n                content = formatThreadAsMarkdown(threadId: thread.id, subject: thread.subject, participantCount: thread.participantCount, messageCount: thread.messageCount, firstDate: thread.firstDate, lastDate: thread.lastDate, messages: messages)\n            }\n\n            try content.write(toFile: filePath, atomically: true, encoding: .utf8)\n            print(\"Exported 1 thread to \\(outputDir)\")\n            return\n        }\n\n        // Export all threads (up to limit)\n        let threads = try mailDatabase.getThreads(limit: limit)\n\n        if threads.isEmpty {\n            printError(\"No threads to export\")\n            return\n        }\n\n        print(\"Exporting \\(threads.count) thread(s) to \\(outputDir)...\")\n\n        var exportedCount = 0\n\n        for thread in threads {\n            let filename = \"thread-\\(thread.id).\\(format.fileExtension)\"\n            let filePath = (outputDir as NSString).appendingPathComponent(filename)\n\n            // Get all messages in the thread, sorted by date\n            let messages = try mailDatabase.getMessagesInThreadViaJunction(threadId: thread.id, limit: 10000)\n\n            let content: String\n            if format.isJson {\n                content = formatThreadAsJson(threadId: thread.id, subject: thread.subject, participantCount: thread.participantCount, messageCount: thread.messageCount, firstDate: thread.firstDate, lastDate: thread.lastDate, messages: messages)\n            } else {\n                content = formatThreadAsMarkdown(threadId: thread.id, subject: thread.subject, participantCount: thread.participantCount, messageCount: thread.messageCount, firstDate: thread.firstDate, lastDate: thread.lastDate, messages: messages)\n            }\n\n            try content.write(toFile: filePath, atomically: true, encoding: .utf8)\n            exportedCount += 1\n        }\n\n        print(\"Exported \\(exportedCount) thread(s) to \\(outputDir)\")\n    }\n\n    private func formatThreadAsJson(threadId: String, subject: String?, participantCount: Int, messageCount: Int, firstDate: Date?, lastDate: Date?, messages: [MailMessage]) -> String {\n        let threadTotal = messages.count\n\n        // Build nested messages array with thread position\n        var messagesArray: [[String: Any]] = []\n        for (index, message) in messages.enumerated() {\n            let position = index + 1  // 1-indexed position\n            messagesArray.append(messageToDict(message, threadPosition: position, threadTotal: threadTotal))\n        }\n\n        // Build thread export structure\n        let threadExport: [String: Any] = [\n            \"thread_id\": threadId,\n            \"subject\": subject ?? \"\",\n            \"participant_count\": participantCount,\n            \"message_count\": messageCount,\n            \"first_date\": firstDate?.iso8601String ?? \"\",\n            \"last_date\": lastDate?.iso8601String ?? \"\",\n            \"messages\": messagesArray\n        ]\n\n        if let data = try? JSONSerialization.data(withJSONObject: threadExport, options: [.prettyPrinted, .sortedKeys]),\n           let jsonString = String(data: data, encoding: .utf8) {\n            return jsonString\n        }\n        return \"{}\"\n    }\n\n    private func formatThreadAsMarkdown(threadId: String, subject: String?, participantCount: Int, messageCount: Int, firstDate: Date?, lastDate: Date?, messages: [MailMessage]) -> String {\n        var lines: [String] = []\n        let threadTotal = messages.count\n\n        // YAML frontmatter with thread metadata\n        lines.append(\"---\")\n        lines.append(\"thread_id: \\\"\\(threadId)\\\"\")\n        lines.append(\"subject: \\\"\\(escapeYaml(subject ?? \"\"))\\\"\")\n        lines.append(\"participant_count: \\(participantCount)\")\n        lines.append(\"message_count: \\(messageCount)\")\n        if let firstDate = firstDate {\n            lines.append(\"first_date: \\(firstDate.iso8601String)\")\n        }\n        if let lastDate = lastDate {\n            lines.append(\"last_date: \\(lastDate.iso8601String)\")\n        }\n        lines.append(\"---\")\n        lines.append(\"\")\n\n        // Thread heading\n        lines.append(\"# Thread: \\(subject ?? \"(No Subject)\")\")\n        lines.append(\"\")\n        lines.append(\"**\\(threadTotal) message(s) between \\(participantCount) participant(s)**\")\n        lines.append(\"\")\n\n        // Each message in the thread\n        for (index, message) in messages.enumerated() {\n            let position = index + 1\n            lines.append(\"---\")\n            lines.append(\"\")\n            lines.append(\"## Message \\(position) of \\(threadTotal)\")\n            lines.append(\"\")\n            lines.append(\"**From:** \\(formatSender(message))\")\n            if let date = message.dateSent {\n                lines.append(\"**Date:** \\(date.iso8601String)\")\n            }\n            lines.append(\"**Subject:** \\(message.subject)\")\n            lines.append(\"\")\n\n            // Body content\n            if let textBody = message.bodyText, !textBody.isEmpty {\n                lines.append(textBody)\n            } else if let htmlBody = message.bodyHtml {\n                lines.append(stripHtml(htmlBody))\n            } else {\n                lines.append(\"*(No message body)*\")\n            }\n            lines.append(\"\")\n        }\n\n        return lines.joined(separator: \"\\n\")\n    }\n\n    private func messageToDict(_ message: MailMessage, threadPosition: Int, threadTotal: Int) -> [String: Any] {\n        return [\n            \"id\": message.id,\n            \"messageId\": message.messageId ?? \"\",\n            \"subject\": message.subject,\n            \"from\": [\n                \"name\": message.senderName ?? \"\",\n                \"email\": message.senderEmail ?? \"\"\n            ],\n            \"date\": message.dateSent?.iso8601String ?? \"\",\n            \"mailbox\": message.mailboxName ?? \"\",\n            \"isRead\": message.isRead,\n            \"isFlagged\": message.isFlagged,\n            \"hasAttachments\": message.hasAttachments,\n            \"bodyText\": message.bodyText ?? \"\",\n            \"bodyHtml\": message.bodyHtml ?? \"\",\n            \"thread_id\": message.threadId ?? \"\",\n            \"thread_position\": threadPosition,\n            \"thread_total\": threadTotal\n        ]\n    }\n\n    private func formatSender(_ message: MailMessage) -> String {\n        if let name = message.senderName, let email = message.senderEmail {\n            return \"\\(name) <\\(email)>\"\n        } else if let email = message.senderEmail {\n            return email\n        } else if let name = message.senderName {\n            return name\n        }\n        return \"Unknown\"\n    }\n\n    private func escapeYaml(_ text: String) -> String {\n        text.replacingOccurrences(of: \"\\\"\", with: \"\\\\\\\"\")\n    }\n\n    private func stripHtml(_ html: String) -> String {\n        var result = html\n        result = result.replacingOccurrences(of: \"<script[^>]*>.*?</script>\", with: \"\", options: .regularExpression)\n        result = result.replacingOccurrences(of: \"<style[^>]*>.*?</style>\", with: \"\", options: .regularExpression)\n        result = result.replacingOccurrences(of: \"&nbsp;\", with: \" \")\n        result = result.replacingOccurrences(of: \"&amp;\", with: \"&\")\n        result = result.replacingOccurrences(of: \"&lt;\", with: \"<\")\n        result = result.replacingOccurrences(of: \"&gt;\", with: \">\")\n        result = result.replacingOccurrences(of: \"&quot;\", with: \"\\\"\")\n        result = result.replacingOccurrences(of: \"<br[^>]*>\", with: \"\\n\", options: .regularExpression)\n        result = result.replacingOccurrences(of: \"</p>\", with: \"\\n\\n\")\n        result = result.replacingOccurrences(of: \"<[^>]+>\", with: \"\", options: .regularExpression)\n        result = result.replacingOccurrences(of: \"\\n{3,}\", with: \"\\n\\n\", options: .regularExpression)\n        return result.trimmingCharacters(in: .whitespacesAndNewlines)\n    }\n}\n\n// MARK: - Mail Validation Errors\n\n/// Error thrown when CLI input validation fails\npublic enum MailValidationError: Error, LocalizedError, Equatable {\n    case invalidLimit\n    case emptyRecipient\n    case watchAndStopMutuallyExclusive\n    case invalidInterval(minimum: Int)\n    case invalidStatus(value: String)\n    case unknownFilter(names: [String], validFilters: [String])\n\n    public var errorDescription: String? {\n        switch self {\n        case .invalidLimit:\n            return \"--limit must be a positive integer\"\n        case .emptyRecipient:\n            return \"--to requires a non-empty email address\"\n        case .watchAndStopMutuallyExclusive:\n            return \"--watch and --stop cannot be used together\"\n        case .invalidInterval(let minimum):\n            return \"--interval must be at least \\(minimum) seconds\"\n        case .invalidStatus(let value):\n            return \"Invalid status '\\(value)'. Valid options: inbox, archived, deleted\"\n        case .unknownFilter(let names, let validFilters):\n            let unknownList = names.map { \"'\\($0)'\" }.joined(separator: \", \")\n            let validList = validFilters.joined(separator: \", \")\n            if names.count == 1 {\n                return \"Unknown filter \\(unknownList). Valid filters: \\(validList)\"\n            } else {\n                return \"Unknown filters \\(unknownList). Valid filters: \\(validList)\"\n            }\n        }\n    }\n}\n\n// MARK: - Mail Action Commands\n\n/// Error thrown when action validation fails\nenum MailActionError: Error, LocalizedError {\n    case messageNotFound(String)\n    case mailboxRequired\n    case confirmationRequired(action: String)\n    case invalidFlagOperation\n    case invalidMarkOperation\n\n    var errorDescription: String? {\n        switch self {\n        case .messageNotFound(let id):\n            return \"Message not found: \\(id)\"\n        case .mailboxRequired:\n            return \"Target mailbox is required. Use --mailbox to specify destination.\"\n        case .confirmationRequired(let action):\n            return \"Destructive action '\\(action)' requires --yes to confirm or --dry-run to preview.\"\n        case .invalidFlagOperation:\n            return \"Specify either --set or --clear for flag operation.\"\n        case .invalidMarkOperation:\n            return \"Specify either --read or --unread for mark operation.\"\n        }\n    }\n}\n\nstruct MailArchiveCommand: ParsableCommand {\n    static let configuration = CommandConfiguration(\n        commandName: \"archive\",\n        abstract: \"Archive a mail message\",\n        discussion: \"\"\"\n            Moves the specified message to the Archive mailbox in Mail.app.\n\n            DESTRUCTIVE ACTION: This command modifies your mailbox.\n            Use --dry-run to preview the action without making changes.\n            Use --yes to confirm the action.\n            \"\"\"\n    )\n\n    @Option(name: .long, help: \"Message ID to archive (required)\")\n    var id: String\n\n    @Flag(name: .long, help: \"Confirm the destructive action\")\n    var yes: Bool = false\n\n    @Flag(name: .long, help: \"Preview the action without making changes\")\n    var dryRun: Bool = false\n\n    func validate() throws {\n        // Validate that either --yes or --dry-run is provided\n        if !yes && !dryRun {\n            throw MailActionError.confirmationRequired(action: \"archive\")\n        }\n    }\n\n    func run() throws {\n        let vault = try VaultContext.require()\n\n        // Open mail database\n        let mailDbPath = (vault.dataFolderPath as NSString).appendingPathComponent(\"mail.db\")\n        let mailDatabase = MailDatabase(databasePath: mailDbPath)\n        try mailDatabase.initialize()\n        defer { mailDatabase.close() }\n\n        // Resolve message to Mail.app reference\n        let resolver = MessageResolver(database: mailDatabase)\n        let resolved = try resolver.resolve(id: id)\n\n        if dryRun {\n            print(\"[DRY RUN] Would archive message:\")\n            print(\"  ID: \\(resolved.swiftEAId)\")\n            print(\"  Message-ID: \\(resolved.messageId)\")\n            print(\"  Subject: \\(resolved.message.subject)\")\n            print(\"  From: \\(resolved.message.senderEmail ?? \"Unknown\")\")\n            print(\"  Current mailbox: \\(resolved.message.mailboxName ?? \"Unknown\")\")\n            return\n        }\n\n        // Use MailSyncBackward for optimistic update pattern\n        let backwardSync = MailSyncBackward(mailDatabase: mailDatabase)\n        try backwardSync.archiveMessage(id: resolved.swiftEAId)\n\n        print(\"Archived message: \\(resolved.swiftEAId)\")\n        print(\"  Subject: \\(resolved.message.subject)\")\n    }\n}\n\nstruct MailDeleteCommand: ParsableCommand {\n    static let configuration = CommandConfiguration(\n        commandName: \"delete\",\n        abstract: \"Delete a mail message\",\n        discussion: \"\"\"\n            Moves the specified message to the Trash mailbox in Mail.app.\n\n            DESTRUCTIVE ACTION: This command modifies your mailbox.\n            Use --dry-run to preview the action without making changes.\n            Use --yes to confirm the action.\n            \"\"\"\n    )\n\n    @Option(name: .long, help: \"Message ID to delete (required)\")\n    var id: String\n\n    @Flag(name: .long, help: \"Confirm the destructive action\")\n    var yes: Bool = false\n\n    @Flag(name: .long, help: \"Preview the action without making changes\")\n    var dryRun: Bool = false\n\n    func validate() throws {\n        // Validate that either --yes or --dry-run is provided\n        if !yes && !dryRun {\n            throw MailActionError.confirmationRequired(action: \"delete\")\n        }\n    }\n\n    func run() throws {\n        let vault = try VaultContext.require()\n\n        // Open mail database\n        let mailDbPath = (vault.dataFolderPath as NSString).appendingPathComponent(\"mail.db\")\n        let mailDatabase = MailDatabase(databasePath: mailDbPath)\n        try mailDatabase.initialize()\n        defer { mailDatabase.close() }\n\n        // Resolve message to Mail.app reference\n        let resolver = MessageResolver(database: mailDatabase)\n        let resolved = try resolver.resolve(id: id)\n\n        if dryRun {\n            print(\"[DRY RUN] Would delete message:\")\n            print(\"  ID: \\(resolved.swiftEAId)\")\n            print(\"  Message-ID: \\(resolved.messageId)\")\n            print(\"  Subject: \\(resolved.message.subject)\")\n            print(\"  From: \\(resolved.message.senderEmail ?? \"Unknown\")\")\n            print(\"  Current mailbox: \\(resolved.message.mailboxName ?? \"Unknown\")\")\n            return\n        }\n\n        // Use MailSyncBackward for optimistic update pattern\n        let backwardSync = MailSyncBackward(mailDatabase: mailDatabase)\n        try backwardSync.deleteMessage(id: resolved.swiftEAId)\n\n        print(\"Deleted message: \\(resolved.swiftEAId)\")\n        print(\"  Subject: \\(resolved.message.subject)\")\n    }\n}\n\nstruct MailMoveCommand: ParsableCommand {\n    static let configuration = CommandConfiguration(\n        commandName: \"move\",\n        abstract: \"Move a mail message to a different mailbox\",\n        discussion: \"\"\"\n            Moves the specified message to the target mailbox in Mail.app.\n\n            DESTRUCTIVE ACTION: This command modifies your mailbox.\n            Use --dry-run to preview the action without making changes.\n            Use --yes to confirm the action.\n            \"\"\"\n    )\n\n    @Option(name: .long, help: \"Message ID to move (required)\")\n    var id: String\n\n    @Option(name: .long, help: \"Target mailbox name (required)\")\n    var mailbox: String?\n\n    @Flag(name: .long, help: \"Confirm the destructive action\")\n    var yes: Bool = false\n\n    @Flag(name: .long, help: \"Preview the action without making changes\")\n    var dryRun: Bool = false\n\n    func validate() throws {\n        // Validate mailbox is provided\n        guard mailbox != nil else {\n            throw MailActionError.mailboxRequired\n        }\n\n        // Validate that either --yes or --dry-run is provided\n        if !yes && !dryRun {\n            throw MailActionError.confirmationRequired(action: \"move\")\n        }\n    }\n\n    func run() throws {\n        let vault = try VaultContext.require()\n\n        // Open mail database\n        let mailDbPath = (vault.dataFolderPath as NSString).appendingPathComponent(\"mail.db\")\n        let mailDatabase = MailDatabase(databasePath: mailDbPath)\n        try mailDatabase.initialize()\n        defer { mailDatabase.close() }\n\n        // Resolve message to Mail.app reference\n        let resolver = MessageResolver(database: mailDatabase)\n        let resolved = try resolver.resolve(id: id)\n\n        let targetMailbox = mailbox!\n\n        if dryRun {\n            print(\"[DRY RUN] Would move message:\")\n            print(\"  ID: \\(resolved.swiftEAId)\")\n            print(\"  Message-ID: \\(resolved.messageId)\")\n            print(\"  Subject: \\(resolved.message.subject)\")\n            print(\"  From: \\(resolved.message.senderEmail ?? \"Unknown\")\")\n            print(\"  Current mailbox: \\(resolved.message.mailboxName ?? \"Unknown\")\")\n            print(\"  Target mailbox: \\(targetMailbox)\")\n            return\n        }\n\n        // Execute move via AppleScript\n        // Use the same account as the source message for the target mailbox\n        let script = MailActionScripts.moveMessage(byMessageId: resolved.messageId, toMailbox: targetMailbox)\n\n        let appleScriptService = AppleScriptService.shared\n        let result = try appleScriptService.executeMailScript(script)\n\n        if result.success {\n            print(\"Moved message: \\(resolved.swiftEAId)\")\n            print(\"  Subject: \\(resolved.message.subject)\")\n            print(\"  To mailbox: \\(targetMailbox)\")\n        }\n    }\n}\n\nstruct MailFlagCommand: ParsableCommand {\n    static let configuration = CommandConfiguration(\n        commandName: \"flag\",\n        abstract: \"Set or clear the flag on a mail message\",\n        discussion: \"\"\"\n            Sets or clears the flag (star) on the specified message in Mail.app.\n\n            Use --set to flag the message.\n            Use --clear to remove the flag.\n            Use --dry-run to preview the action without making changes.\n            \"\"\"\n    )\n\n    @Option(name: .long, help: \"Message ID to flag/unflag (required)\")\n    var id: String\n\n    @Flag(name: .long, help: \"Set the flag on the message\")\n    var set: Bool = false\n\n    @Flag(name: .long, help: \"Clear the flag from the message\")\n    var clear: Bool = false\n\n    @Flag(name: .long, help: \"Preview the action without making changes\")\n    var dryRun: Bool = false\n\n    func validate() throws {\n        // Exactly one of --set or --clear must be provided\n        if set == clear {\n            throw MailActionError.invalidFlagOperation\n        }\n    }\n\n    func run() throws {\n        let vault = try VaultContext.require()\n\n        // Open mail database\n        let mailDbPath = (vault.dataFolderPath as NSString).appendingPathComponent(\"mail.db\")\n        let mailDatabase = MailDatabase(databasePath: mailDbPath)\n        try mailDatabase.initialize()\n        defer { mailDatabase.close() }\n\n        // Resolve message to Mail.app reference\n        let resolver = MessageResolver(database: mailDatabase)\n        let resolved = try resolver.resolve(id: id)\n\n        let willFlag = set\n        let action = willFlag ? \"flag\" : \"unflag\"\n\n        if dryRun {\n            print(\"[DRY RUN] Would \\(action) message:\")\n            print(\"  ID: \\(resolved.swiftEAId)\")\n            print(\"  Message-ID: \\(resolved.messageId)\")\n            print(\"  Subject: \\(resolved.message.subject)\")\n            print(\"  Current flag status: \\(resolved.message.isFlagged ? \"flagged\" : \"not flagged\")\")\n            return\n        }\n\n        // Execute flag via AppleScript\n        let script = MailActionScripts.setFlag(byMessageId: resolved.messageId, flagged: willFlag)\n\n        let appleScriptService = AppleScriptService.shared\n        let result = try appleScriptService.executeMailScript(script)\n\n        if result.success {\n            print(\"\\(willFlag ? \"Flagged\" : \"Unflagged\") message: \\(resolved.swiftEAId)\")\n            print(\"  Subject: \\(resolved.message.subject)\")\n        }\n    }\n}\n\nstruct MailMarkCommand: ParsableCommand {\n    static let configuration = CommandConfiguration(\n        commandName: \"mark\",\n        abstract: \"Mark a mail message as read or unread\",\n        discussion: \"\"\"\n            Marks the specified message as read or unread in Mail.app.\n\n            Use --read to mark the message as read.\n            Use --unread to mark the message as unread.\n            Use --dry-run to preview the action without making changes.\n            \"\"\"\n    )\n\n    @Option(name: .long, help: \"Message ID to mark (required)\")\n    var id: String\n\n    @Flag(name: .long, help: \"Mark the message as read\")\n    var read: Bool = false\n\n    @Flag(name: .long, help: \"Mark the message as unread\")\n    var unread: Bool = false\n\n    @Flag(name: .long, help: \"Preview the action without making changes\")\n    var dryRun: Bool = false\n\n    func validate() throws {\n        // Exactly one of --read or --unread must be provided\n        if read == unread {\n            throw MailActionError.invalidMarkOperation\n        }\n    }\n\n    func run() throws {\n        let vault = try VaultContext.require()\n\n        // Open mail database\n        let mailDbPath = (vault.dataFolderPath as NSString).appendingPathComponent(\"mail.db\")\n        let mailDatabase = MailDatabase(databasePath: mailDbPath)\n        try mailDatabase.initialize()\n        defer { mailDatabase.close() }\n\n        // Resolve message to Mail.app reference\n        let resolver = MessageResolver(database: mailDatabase)\n        let resolved = try resolver.resolve(id: id)\n\n        let markAsRead = read\n        let action = markAsRead ? \"mark as read\" : \"mark as unread\"\n\n        if dryRun {\n            print(\"[DRY RUN] Would \\(action) message:\")\n            print(\"  ID: \\(resolved.swiftEAId)\")\n            print(\"  Message-ID: \\(resolved.messageId)\")\n            print(\"  Subject: \\(resolved.message.subject)\")\n            print(\"  Current status: \\(resolved.message.isRead ? \"read\" : \"unread\")\")\n            return\n        }\n\n        // Execute mark via AppleScript\n        let script = MailActionScripts.setReadStatus(byMessageId: resolved.messageId, read: markAsRead)\n\n        let appleScriptService = AppleScriptService.shared\n        let result = try appleScriptService.executeMailScript(script)\n\n        if result.success {\n            print(\"Marked message as \\(markAsRead ? \"read\" : \"unread\"): \\(resolved.swiftEAId)\")\n            print(\"  Subject: \\(resolved.message.subject)\")\n        }\n    }\n}\n\nstruct MailReplyCommand: ParsableCommand {\n    static let configuration = CommandConfiguration(\n        commandName: \"reply\",\n        abstract: \"Create a reply to a mail message\",\n        discussion: \"\"\"\n            Creates a reply draft for the specified message in Mail.app.\n\n            By default, opens the reply in Mail.app for editing.\n            Use --send to send the reply immediately (requires --body).\n            Use --dry-run to preview the action without making changes.\n\n            The reply will be addressed to the original sender and include\n            the original message as quoted text.\n            \"\"\"\n    )\n\n    @Option(name: .long, help: \"Message ID to reply to (required)\")\n    var id: String\n\n    @Option(name: .long, help: \"Reply body text (required if using --send)\")\n    var body: String?\n\n    @Flag(name: .long, help: \"Reply to all recipients\")\n    var all: Bool = false\n\n    @Flag(name: .long, help: \"Send the reply immediately instead of opening a draft\")\n    var send: Bool = false\n\n    @Flag(name: .long, help: \"Preview the action without making changes\")\n    var dryRun: Bool = false\n\n    func validate() throws {\n        // If --send is specified, --body is required\n        if send && body == nil {\n            throw ValidationError(\"--body is required when using --send\")\n        }\n    }\n\n    func run() throws {\n        let vault = try VaultContext.require()\n\n        // Open mail database\n        let mailDbPath = (vault.dataFolderPath as NSString).appendingPathComponent(\"mail.db\")\n        let mailDatabase = MailDatabase(databasePath: mailDbPath)\n        try mailDatabase.initialize()\n        defer { mailDatabase.close() }\n\n        // Resolve message to Mail.app reference\n        let resolver = MessageResolver(database: mailDatabase)\n        let resolved = try resolver.resolve(id: id)\n\n        let replyType = all ? \"reply all\" : \"reply\"\n\n        if dryRun {\n            print(\"[DRY RUN] Would create \\(replyType) to message:\")\n            print(\"  ID: \\(resolved.swiftEAId)\")\n            print(\"  Message-ID: \\(resolved.messageId)\")\n            print(\"  Subject: \\(resolved.message.subject)\")\n            print(\"  Original sender: \\(resolved.message.senderEmail ?? \"Unknown\")\")\n            if let replyBody = body {\n                let preview = replyBody.prefix(100)\n                print(\"  Body: \\(preview)\\(replyBody.count > 100 ? \"...\" : \"\")\")\n            }\n            print(\"  Mode: \\(send ? \"Send immediately\" : \"Open draft in Mail.app\")\")\n            return\n        }\n\n        // Execute reply via AppleScript\n        let script = MailActionScripts.createReply(\n            byMessageId: resolved.messageId,\n            replyToAll: all,\n            body: body,\n            send: send\n        )\n\n        let appleScriptService = AppleScriptService.shared\n        let result = try appleScriptService.executeMailScript(script)\n\n        if result.success {\n            if send {\n                print(\"Sent \\(replyType) to: \\(resolved.message.senderEmail ?? \"Unknown\")\")\n            } else {\n                print(\"Created \\(replyType) draft in Mail.app\")\n            }\n            print(\"  Original subject: \\(resolved.message.subject)\")\n        }\n    }\n}\n\nstruct MailComposeCommand: ParsableCommand {\n    static let configuration = CommandConfiguration(\n        commandName: \"compose\",\n        abstract: \"Compose a new mail message\",\n        discussion: \"\"\"\n            Creates a new email draft in Mail.app.\n\n            By default, opens the compose window in Mail.app for editing.\n            Use --send to send the message immediately.\n            Use --dry-run to preview the action without making changes.\n            \"\"\"\n    )\n\n    @Option(name: .long, help: \"Recipient email address (required)\")\n    var to: String\n\n    @Option(name: .long, help: \"Email subject (required)\")\n    var subject: String\n\n    @Option(name: .long, help: \"Email body text\")\n    var body: String?\n\n    @Option(name: .long, help: \"CC recipients (comma-separated)\")\n    var cc: String?\n\n    @Option(name: .long, help: \"BCC recipients (comma-separated)\")\n    var bcc: String?\n\n    @Flag(name: .long, help: \"Send the message immediately instead of opening a draft\")\n    var send: Bool = false\n\n    @Flag(name: .long, help: \"Preview the action without making changes\")\n    var dryRun: Bool = false\n\n    func validate() throws {\n        // --to requires a non-empty email address\n        if to.trimmingCharacters(in: .whitespaces).isEmpty {\n            throw MailValidationError.emptyRecipient\n        }\n    }\n\n    func run() throws {\n        _ = try VaultContext.require()\n\n        if dryRun {\n            print(\"[DRY RUN] Would compose new message:\")\n            print(\"  To: \\(to)\")\n            print(\"  Subject: \\(subject)\")\n            if let ccRecipients = cc {\n                print(\"  CC: \\(ccRecipients)\")\n            }\n            if let bccRecipients = bcc {\n                print(\"  BCC: \\(bccRecipients)\")\n            }\n            if let messageBody = body {\n                let preview = messageBody.prefix(100)\n                print(\"  Body: \\(preview)\\(messageBody.count > 100 ? \"...\" : \"\")\")\n            }\n            print(\"  Mode: \\(send ? \"Send immediately\" : \"Open draft in Mail.app\")\")\n            return\n        }\n\n        // Execute compose via AppleScript\n        let script = MailActionScripts.compose(\n            to: to,\n            subject: subject,\n            body: body,\n            cc: cc,\n            bcc: bcc,\n            send: send\n        )\n\n        let appleScriptService = AppleScriptService.shared\n        let result = try appleScriptService.executeMailScript(script)\n\n        if result.success {\n            if send {\n                print(\"Sent message to: \\(to)\")\n            } else {\n                print(\"Created draft in Mail.app\")\n            }\n            print(\"  Subject: \\(subject)\")\n        }\n    }\n}\n\n// MARK: - Database Migration Command\n\nstruct MailMigrateCommand: ParsableCommand {\n    static let configuration = CommandConfiguration(\n        commandName: \"migrate\",\n        abstract: \"Run database migrations to upgrade schema\",\n        discussion: \"\"\"\n            Upgrades the mail database schema to the latest version. This command\n            is idempotent and safe to run multiple times - it only applies migrations\n            that haven't been applied yet.\n\n            The migration system handles:\n            - Adding new columns to existing tables (thread support)\n            - Creating new tables (threads, thread_messages)\n            - Adding indexes for query optimization\n            - Empty databases (creates all tables from scratch)\n\n            THREADING MIGRATIONS\n            Migrations V3-V7 add email threading support:\n              V3: Threading headers (in_reply_to, references)\n              V4: Threads table and thread_id reference\n              V5: Thread-messages junction table\n              V6: Thread position metadata (position, total)\n              V7: Large inbox optimization indexes\n\n            EXAMPLES\n              swea mail migrate              # Apply pending migrations\n              swea mail migrate --status     # Show migration status\n              swea mail migrate --verbose    # Show detailed migration info\n            \"\"\"\n    )\n\n    @Flag(name: .long, help: \"Show current schema version and migration history\")\n    var status: Bool = false\n\n    @Flag(name: .long, help: \"Show detailed information about each migration\")\n    var verbose: Bool = false\n\n    @Flag(name: .long, help: \"Output as JSON\")\n    var json: Bool = false\n\n    @Option(name: .long, help: \"Path to database file (defaults to vault's mail.db)\")\n    var database: String?\n\n    func run() throws {\n        let dbPath: String\n\n        if let customPath = database {\n            dbPath = customPath\n        } else {\n            let vault = try VaultContext.require()\n            dbPath = (vault.dataFolderPath as NSString).appendingPathComponent(\"mail.db\")\n        }\n\n        // Check if database file exists (before migration)\n        let fileManager = FileManager.default\n        let dbExists = fileManager.fileExists(atPath: dbPath)\n\n        // Create database instance without initializing (to check pre-migration state)\n        let mailDatabase = MailDatabase(databasePath: dbPath)\n\n        if status {\n            try showStatus(mailDatabase: mailDatabase, dbPath: dbPath, dbExists: dbExists)\n            return\n        }\n\n        // Run migrations\n        try runMigrations(mailDatabase: mailDatabase, dbPath: dbPath, dbExists: dbExists)\n    }\n\n    private func showStatus(mailDatabase: MailDatabase, dbPath: String, dbExists: Bool) throws {\n        // Initialize database to run migrations and get status\n        try mailDatabase.initialize()\n        defer { mailDatabase.close() }\n\n        let currentVersion = try mailDatabase.getSchemaVersion()\n        let latestVersion = MailDatabase.currentSchemaVersion\n        let history = try mailDatabase.getMigrationHistory()\n\n        if json {\n            var result: [String: Any] = [\n                \"database_path\": dbPath,\n                \"current_version\": currentVersion,\n                \"latest_version\": latestVersion,\n                \"up_to_date\": currentVersion >= latestVersion,\n                \"pending_migrations\": max(0, latestVersion - currentVersion)\n            ]\n\n            var migrations: [[String: Any]] = []\n            for (version, appliedAt) in history {\n                var migration: [String: Any] = [\n                    \"version\": version,\n                    \"applied_at\": appliedAt\n                ]\n                if let description = MailDatabase.migrationDescriptions[version] {\n                    migration[\"description\"] = description\n                }\n                migrations.append(migration)\n            }\n            result[\"migrations\"] = migrations\n\n            if let jsonData = try? JSONSerialization.data(withJSONObject: result, options: .prettyPrinted),\n               let jsonString = String(data: jsonData, encoding: .utf8) {\n                print(jsonString)\n            }\n        } else {\n            print(\"Mail Database Schema Status\")\n            print(\"===========================\")\n            print(\"Database: \\(dbPath)\")\n            print(\"Current version: V\\(currentVersion)\")\n            print(\"Latest version:  V\\(latestVersion)\")\n\n            if currentVersion >= latestVersion {\n                print(\"\\nâœ“ Database is up to date\")\n            } else {\n                let pending = latestVersion - currentVersion\n                print(\"\\nâš  \\(pending) migration(s) pending\")\n            }\n\n            if verbose || !history.isEmpty {\n                print(\"\\nMigration History:\")\n                if history.isEmpty {\n                    print(\"  No migrations applied yet\")\n                } else {\n                    for (version, appliedAt) in history {\n                        let description = MailDatabase.migrationDescriptions[version] ?? \"Unknown\"\n                        print(\"  V\\(version): \\(appliedAt)\")\n                        if verbose {\n                            print(\"       \\(description)\")\n                        }\n                    }\n                }\n            }\n\n            if verbose {\n                print(\"\\nAll Migrations:\")\n                for version in 1...latestVersion {\n                    let description = MailDatabase.migrationDescriptions[version] ?? \"Unknown\"\n                    let applied = history.contains { $0.version == version }\n                    let status = applied ? \"âœ“\" : \"â—‹\"\n                    print(\"  \\(status) V\\(version): \\(description)\")\n                }\n            }\n\n            // Show table status\n            print(\"\\nTable Status:\")\n            let tables = [\"messages\", \"threads\", \"thread_messages\", \"recipients\", \"attachments\", \"mailboxes\"]\n            for table in tables {\n                let exists = try mailDatabase.tableExists(table)\n                let status = exists ? \"âœ“\" : \"â—‹\"\n                print(\"  \\(status) \\(table)\")\n                if verbose && exists {\n                    let columns = try mailDatabase.getTableColumns(table)\n                    print(\"       Columns: \\(columns.count)\")\n                }\n            }\n        }\n    }\n\n    private func runMigrations(mailDatabase: MailDatabase, dbPath: String, dbExists: Bool) throws {\n        // Get pre-migration version if database exists\n        var preMigrationVersion = 0\n        if dbExists {\n            // Temporarily initialize just to check version, then close\n            let tempDb = MailDatabase(databasePath: dbPath)\n            try tempDb.initialize()\n            preMigrationVersion = try tempDb.getSchemaVersion()\n            tempDb.close()\n        }\n\n        if verbose {\n            print(\"Database: \\(dbPath)\")\n            if dbExists {\n                print(\"Pre-migration version: V\\(preMigrationVersion)\")\n            } else {\n                print(\"Creating new database...\")\n            }\n        }\n\n        // Initialize database (this runs migrations)\n        try mailDatabase.initialize()\n        defer { mailDatabase.close() }\n\n        let postMigrationVersion = try mailDatabase.getSchemaVersion()\n        let migrationsApplied = postMigrationVersion - preMigrationVersion\n\n        if json {\n            let result: [String: Any] = [\n                \"database_path\": dbPath,\n                \"was_new_database\": !dbExists,\n                \"pre_migration_version\": preMigrationVersion,\n                \"post_migration_version\": postMigrationVersion,\n                \"migrations_applied\": migrationsApplied,\n                \"success\": true\n            ]\n\n            if let jsonData = try? JSONSerialization.data(withJSONObject: result, options: .prettyPrinted),\n               let jsonString = String(data: jsonData, encoding: .utf8) {\n                print(jsonString)\n            }\n        } else {\n            if migrationsApplied == 0 {\n                print(\"âœ“ Database already at latest version (V\\(postMigrationVersion))\")\n            } else if !dbExists {\n                print(\"âœ“ Created new database at V\\(postMigrationVersion)\")\n                if verbose {\n                    print(\"  Applied \\(migrationsApplied) migration(s)\")\n                }\n            } else {\n                print(\"âœ“ Migrated from V\\(preMigrationVersion) to V\\(postMigrationVersion)\")\n                print(\"  Applied \\(migrationsApplied) migration(s):\")\n                for version in (preMigrationVersion + 1)...postMigrationVersion {\n                    if let description = MailDatabase.migrationDescriptions[version] {\n                        print(\"    V\\(version): \\(description)\")\n                    }\n                }\n            }\n\n            // Show threading table status\n            let threadsExist = try mailDatabase.tableExists(\"threads\")\n            let junctionExist = try mailDatabase.tableExists(\"thread_messages\")\n\n            if verbose {\n                print(\"\\nThreading Support:\")\n                print(\"  threads table: \\(threadsExist ? \"âœ“\" : \"â—‹\")\")\n                print(\"  thread_messages table: \\(junctionExist ? \"âœ“\" : \"â—‹\")\")\n\n                // Check for thread columns in messages table\n                let messageColumns = try mailDatabase.getTableColumns(\"messages\")\n                let hasThreadId = messageColumns.contains(\"thread_id\")\n                let hasThreadPosition = messageColumns.contains(\"thread_position\")\n                let hasThreadTotal = messageColumns.contains(\"thread_total\")\n                let hasInReplyTo = messageColumns.contains(\"in_reply_to\")\n                let hasReferences = messageColumns.contains(\"threading_references\")\n\n                print(\"  messages.thread_id: \\(hasThreadId ? \"âœ“\" : \"â—‹\")\")\n                print(\"  messages.thread_position: \\(hasThreadPosition ? \"âœ“\" : \"â—‹\")\")\n                print(\"  messages.thread_total: \\(hasThreadTotal ? \"âœ“\" : \"â—‹\")\")\n                print(\"  messages.in_reply_to: \\(hasInReplyTo ? \"âœ“\" : \"â—‹\")\")\n                print(\"  messages.threading_references: \\(hasReferences ? \"âœ“\" : \"â—‹\")\")\n            }\n        }\n    }\n}\n","structuredPatch":[{"oldStart":1277,"oldLines":6,"newStart":1277,"newLines":14,"lines":["         // Parse the query for structured filters","         var filter = mailDatabase.parseQuery(query)"," ","+        // Check for unknown filter names and fail with helpful error","+        if filter.hasUnknownFilters {","+            throw MailValidationError.unknownFilter(","+                names: filter.unknownFilters,","+                validFilters: MailDatabase.SearchFilter.validFilterNames","+            )","+        }","+","         // Apply --status option if provided","         if let statusValue = status {","             filter.mailboxStatus = MailboxStatus(rawValue: statusValue.lowercased())"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01FfJcsrnyrkrwDcG5W8b8jS","type":"message","role":"assistant","content":[{"type":"text","text":"Now let's add tests for this functionality:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":983,"cache_read_input_tokens":59253,"cache_creation":{"ephemeral_5m_input_tokens":983,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"940baf11-e321-42aa-8d5a-6768b90e2e1c"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01FfJcsrnyrkrwDcG5W8b8jS","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VAiMzuiXCHLX3rPk26xFaQ","name":"Edit","input":{"replace_all":false,"file_path":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift","old_string":"    func testSearchWithUnknownFilterName() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"filter-test\", subject: \"Test message for filter\")\n        try database.upsertMessage(message)\n\n        // Unknown filter names (badfilter:value format) should not crash\n        // This tests the FTS5 column prefix syntax handling\n        XCTAssertNoThrow(try database.searchMessages(query: \"badfilter:test\"), \"Search should not crash for unknown filter syntax\")\n        XCTAssertNoThrow(try database.searchMessages(query: \"unknown:value\"), \"Search should not crash for unknown filter syntax\")\n        XCTAssertNoThrow(try database.searchMessages(query: \"foo:bar baz:qux\"), \"Search should not crash for multiple unknown filters\")\n    }","new_string":"    func testSearchWithUnknownFilterName() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"filter-test\", subject: \"Test message for filter\")\n        try database.upsertMessage(message)\n\n        // Unknown filter names (badfilter:value format) should not crash\n        // This tests the FTS5 column prefix syntax handling\n        XCTAssertNoThrow(try database.searchMessages(query: \"badfilter:test\"), \"Search should not crash for unknown filter syntax\")\n        XCTAssertNoThrow(try database.searchMessages(query: \"unknown:value\"), \"Search should not crash for unknown filter syntax\")\n        XCTAssertNoThrow(try database.searchMessages(query: \"foo:bar baz:qux\"), \"Search should not crash for multiple unknown filters\")\n    }\n\n    func testParseQueryDetectsUnknownFilters() throws {\n        try database.initialize()\n\n        // Single unknown filter\n        let filter1 = database.parseQuery(\"badfilter:test\")\n        XCTAssertTrue(filter1.hasUnknownFilters)\n        XCTAssertEqual(filter1.unknownFilters, [\"badfilter\"])\n\n        // Multiple unknown filters\n        let filter2 = database.parseQuery(\"foo:bar baz:qux\")\n        XCTAssertTrue(filter2.hasUnknownFilters)\n        XCTAssertEqual(filter2.unknownFilters, [\"foo\", \"baz\"])\n\n        // Unknown filter mixed with valid filter\n        let filter3 = database.parseQuery(\"from:alice@example.com badfilter:test\")\n        XCTAssertTrue(filter3.hasUnknownFilters)\n        XCTAssertEqual(filter3.unknownFilters, [\"badfilter\"])\n        XCTAssertEqual(filter3.from, \"alice@example.com\")\n\n        // Valid filters only - no unknown filters\n        let filter4 = database.parseQuery(\"from:alice to:bob subject:hello\")\n        XCTAssertFalse(filter4.hasUnknownFilters)\n        XCTAssertEqual(filter4.unknownFilters, [])\n\n        // Plain text search without filter syntax - no unknown filters\n        let filter5 = database.parseQuery(\"hello world\")\n        XCTAssertFalse(filter5.hasUnknownFilters)\n        XCTAssertEqual(filter5.unknownFilters, [])\n\n        // is: and has: filters are valid\n        let filter6 = database.parseQuery(\"is:read has:attachments\")\n        XCTAssertFalse(filter6.hasUnknownFilters)\n        XCTAssertEqual(filter6.isRead, true)\n        XCTAssertEqual(filter6.hasAttachments, true)\n\n        // Date filters are valid\n        let filter7 = database.parseQuery(\"after:2024-01-01 before:2024-12-31 date:2024-06-15\")\n        XCTAssertFalse(filter7.hasUnknownFilters)\n    }\n\n    func testValidFilterNamesConstant() throws {\n        // Verify the list of valid filter names includes all expected filters\n        let expected = [\"from\", \"to\", \"subject\", \"mailbox\", \"is\", \"has\", \"after\", \"before\", \"date\"]\n        XCTAssertEqual(MailDatabase.SearchFilter.validFilterNames.sorted(), expected.sorted())\n    }"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":983,"cache_read_input_tokens":59253,"cache_creation":{"ephemeral_5m_input_tokens":983,"ephemeral_1h_input_tokens":0},"output_tokens":1200,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"e41f14e3-6724-4087-86e2-da085029944c"}
{"type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"<tool_use_error>File has not been read yet. Read it first before writing to it.</tool_use_error>","is_error":true,"tool_use_id":"toolu_01VAiMzuiXCHLX3rPk26xFaQ"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"1d8c8226-2d92-45ae-a1a3-daad6b43a14f","tool_use_result":"Error: File has not been read yet. Read it first before writing to it."}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Bfw9FugsW4E1uZLCmZVWsc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KDSQfuooiD5MPmMAQWsVEg","name":"Read","input":{"file_path":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift","offset":285,"limit":30}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1246,"cache_read_input_tokens":60236,"cache_creation":{"ephemeral_5m_input_tokens":1246,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"c1c4a016-d72b-4f16-b6e5-96c95a053416"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KDSQfuooiD5MPmMAQWsVEg","type":"tool_result","content":"   285â†’    func testSearchWithUnknownFilterName() throws {\n   286â†’        try database.initialize()\n   287â†’\n   288â†’        let message = MailMessage(id: \"filter-test\", subject: \"Test message for filter\")\n   289â†’        try database.upsertMessage(message)\n   290â†’\n   291â†’        // Unknown filter names (badfilter:value format) should not crash\n   292â†’        // This tests the FTS5 column prefix syntax handling\n   293â†’        XCTAssertNoThrow(try database.searchMessages(query: \"badfilter:test\"), \"Search should not crash for unknown filter syntax\")\n   294â†’        XCTAssertNoThrow(try database.searchMessages(query: \"unknown:value\"), \"Search should not crash for unknown filter syntax\")\n   295â†’        XCTAssertNoThrow(try database.searchMessages(query: \"foo:bar baz:qux\"), \"Search should not crash for multiple unknown filters\")\n   296â†’    }\n   297â†’\n   298â†’    func testSearchWithMixedSpecialCharacters() throws {\n   299â†’        try database.initialize()\n   300â†’\n   301â†’        let message = MailMessage(id: \"mixed-test\", subject: \"Can't say \\\"hello (world)\\\"\")\n   302â†’        try database.upsertMessage(message)\n   303â†’\n   304â†’        // Complex query with multiple special characters\n   305â†’        let results = try database.searchMessages(query: \"Can't say \\\"hello\\\"\")\n   306â†’        XCTAssertNotNil(results)\n   307â†’    }\n   308â†’\n   309â†’    func testSearchWithEmptyQuery() throws {\n   310â†’        try database.initialize()\n   311â†’\n   312â†’        let message = MailMessage(id: \"empty-test\", subject: \"Test message\")\n   313â†’        try database.upsertMessage(message)\n   314â†’\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"9bb17bfe-a657-49e9-b34d-44a3ccb6c9dc","tool_use_result":{"type":"text","file":{"filePath":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift","content":"    func testSearchWithUnknownFilterName() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"filter-test\", subject: \"Test message for filter\")\n        try database.upsertMessage(message)\n\n        // Unknown filter names (badfilter:value format) should not crash\n        // This tests the FTS5 column prefix syntax handling\n        XCTAssertNoThrow(try database.searchMessages(query: \"badfilter:test\"), \"Search should not crash for unknown filter syntax\")\n        XCTAssertNoThrow(try database.searchMessages(query: \"unknown:value\"), \"Search should not crash for unknown filter syntax\")\n        XCTAssertNoThrow(try database.searchMessages(query: \"foo:bar baz:qux\"), \"Search should not crash for multiple unknown filters\")\n    }\n\n    func testSearchWithMixedSpecialCharacters() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"mixed-test\", subject: \"Can't say \\\"hello (world)\\\"\")\n        try database.upsertMessage(message)\n\n        // Complex query with multiple special characters\n        let results = try database.searchMessages(query: \"Can't say \\\"hello\\\"\")\n        XCTAssertNotNil(results)\n    }\n\n    func testSearchWithEmptyQuery() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"empty-test\", subject: \"Test message\")\n        try database.upsertMessage(message)\n","numLines":30,"startLine":285,"totalLines":2497}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01CVpECMYfTcEBBUe4z5xEBU","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FCaHzBQ3JnNmPcvXZyq8Yh","name":"Edit","input":{"replace_all":false,"file_path":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift","old_string":"    func testSearchWithUnknownFilterName() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"filter-test\", subject: \"Test message for filter\")\n        try database.upsertMessage(message)\n\n        // Unknown filter names (badfilter:value format) should not crash\n        // This tests the FTS5 column prefix syntax handling\n        XCTAssertNoThrow(try database.searchMessages(query: \"badfilter:test\"), \"Search should not crash for unknown filter syntax\")\n        XCTAssertNoThrow(try database.searchMessages(query: \"unknown:value\"), \"Search should not crash for unknown filter syntax\")\n        XCTAssertNoThrow(try database.searchMessages(query: \"foo:bar baz:qux\"), \"Search should not crash for multiple unknown filters\")\n    }\n\n    func testSearchWithMixedSpecialCharacters() throws {","new_string":"    func testSearchWithUnknownFilterName() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"filter-test\", subject: \"Test message for filter\")\n        try database.upsertMessage(message)\n\n        // Unknown filter names (badfilter:value format) should not crash\n        // This tests the FTS5 column prefix syntax handling\n        XCTAssertNoThrow(try database.searchMessages(query: \"badfilter:test\"), \"Search should not crash for unknown filter syntax\")\n        XCTAssertNoThrow(try database.searchMessages(query: \"unknown:value\"), \"Search should not crash for unknown filter syntax\")\n        XCTAssertNoThrow(try database.searchMessages(query: \"foo:bar baz:qux\"), \"Search should not crash for multiple unknown filters\")\n    }\n\n    func testParseQueryDetectsUnknownFilters() throws {\n        try database.initialize()\n\n        // Single unknown filter\n        let filter1 = database.parseQuery(\"badfilter:test\")\n        XCTAssertTrue(filter1.hasUnknownFilters)\n        XCTAssertEqual(filter1.unknownFilters, [\"badfilter\"])\n\n        // Multiple unknown filters\n        let filter2 = database.parseQuery(\"foo:bar baz:qux\")\n        XCTAssertTrue(filter2.hasUnknownFilters)\n        XCTAssertEqual(filter2.unknownFilters, [\"foo\", \"baz\"])\n\n        // Unknown filter mixed with valid filter\n        let filter3 = database.parseQuery(\"from:alice@example.com badfilter:test\")\n        XCTAssertTrue(filter3.hasUnknownFilters)\n        XCTAssertEqual(filter3.unknownFilters, [\"badfilter\"])\n        XCTAssertEqual(filter3.from, \"alice@example.com\")\n\n        // Valid filters only - no unknown filters\n        let filter4 = database.parseQuery(\"from:alice to:bob subject:hello\")\n        XCTAssertFalse(filter4.hasUnknownFilters)\n        XCTAssertEqual(filter4.unknownFilters, [])\n\n        // Plain text search without filter syntax - no unknown filters\n        let filter5 = database.parseQuery(\"hello world\")\n        XCTAssertFalse(filter5.hasUnknownFilters)\n        XCTAssertEqual(filter5.unknownFilters, [])\n\n        // is: and has: filters are valid\n        let filter6 = database.parseQuery(\"is:read has:attachments\")\n        XCTAssertFalse(filter6.hasUnknownFilters)\n        XCTAssertEqual(filter6.isRead, true)\n        XCTAssertEqual(filter6.hasAttachments, true)\n\n        // Date filters are valid\n        let filter7 = database.parseQuery(\"after:2024-01-01 before:2024-12-31 date:2024-06-15\")\n        XCTAssertFalse(filter7.hasUnknownFilters)\n    }\n\n    func testValidFilterNamesConstant() throws {\n        // Verify the list of valid filter names includes all expected filters\n        let expected = [\"from\", \"to\", \"subject\", \"mailbox\", \"is\", \"has\", \"after\", \"before\", \"date\"]\n        XCTAssertEqual(MailDatabase.SearchFilter.validFilterNames.sorted(), expected.sorted())\n    }\n\n    func testSearchWithMixedSpecialCharacters() throws {"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":679,"cache_read_input_tokens":61482,"cache_creation":{"ephemeral_5m_input_tokens":679,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"a47e0623-0ea3-4417-b976-81ccb3056eac"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FCaHzBQ3JnNmPcvXZyq8Yh","type":"tool_result","content":"The file /Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift has been updated. Here's the result of running `cat -n` on a snippet of the edited file:\n   281â†’            XCTAssertNoThrow(try database.searchMessages(query: char), \"Search should not crash for character: \\(char)\")\n   282â†’        }\n   283â†’    }\n   284â†’\n   285â†’    func testSearchWithUnknownFilterName() throws {\n   286â†’        try database.initialize()\n   287â†’\n   288â†’        let message = MailMessage(id: \"filter-test\", subject: \"Test message for filter\")\n   289â†’        try database.upsertMessage(message)\n   290â†’\n   291â†’        // Unknown filter names (badfilter:value format) should not crash\n   292â†’        // This tests the FTS5 column prefix syntax handling\n   293â†’        XCTAssertNoThrow(try database.searchMessages(query: \"badfilter:test\"), \"Search should not crash for unknown filter syntax\")\n   294â†’        XCTAssertNoThrow(try database.searchMessages(query: \"unknown:value\"), \"Search should not crash for unknown filter syntax\")\n   295â†’        XCTAssertNoThrow(try database.searchMessages(query: \"foo:bar baz:qux\"), \"Search should not crash for multiple unknown filters\")\n   296â†’    }\n   297â†’\n   298â†’    func testParseQueryDetectsUnknownFilters() throws {\n   299â†’        try database.initialize()\n   300â†’\n   301â†’        // Single unknown filter\n   302â†’        let filter1 = database.parseQuery(\"badfilter:test\")\n   303â†’        XCTAssertTrue(filter1.hasUnknownFilters)\n   304â†’        XCTAssertEqual(filter1.unknownFilters, [\"badfilter\"])\n   305â†’\n   306â†’        // Multiple unknown filters\n   307â†’        let filter2 = database.parseQuery(\"foo:bar baz:qux\")\n   308â†’        XCTAssertTrue(filter2.hasUnknownFilters)\n   309â†’        XCTAssertEqual(filter2.unknownFilters, [\"foo\", \"baz\"])\n   310â†’\n   311â†’        // Unknown filter mixed with valid filter\n   312â†’        let filter3 = database.parseQuery(\"from:alice@example.com badfilter:test\")\n   313â†’        XCTAssertTrue(filter3.hasUnknownFilters)\n   314â†’        XCTAssertEqual(filter3.unknownFilters, [\"badfilter\"])\n   315â†’        XCTAssertEqual(filter3.from, \"alice@example.com\")\n   316â†’\n   317â†’        // Valid filters only - no unknown filters\n   318â†’        let filter4 = database.parseQuery(\"from:alice to:bob subject:hello\")\n   319â†’        XCTAssertFalse(filter4.hasUnknownFilters)\n   320â†’        XCTAssertEqual(filter4.unknownFilters, [])\n   321â†’\n   322â†’        // Plain text search without filter syntax - no unknown filters\n   323â†’        let filter5 = database.parseQuery(\"hello world\")\n   324â†’        XCTAssertFalse(filter5.hasUnknownFilters)\n   325â†’        XCTAssertEqual(filter5.unknownFilters, [])\n   326â†’\n   327â†’        // is: and has: filters are valid\n   328â†’        let filter6 = database.parseQuery(\"is:read has:attachments\")\n   329â†’        XCTAssertFalse(filter6.hasUnknownFilters)\n   330â†’        XCTAssertEqual(filter6.isRead, true)\n   331â†’        XCTAssertEqual(filter6.hasAttachments, true)\n   332â†’\n   333â†’        // Date filters are valid\n   334â†’        let filter7 = database.parseQuery(\"after:2024-01-01 before:2024-12-31 date:2024-06-15\")\n   335â†’        XCTAssertFalse(filter7.hasUnknownFilters)\n   336â†’    }\n   337â†’\n   338â†’    func testValidFilterNamesConstant() throws {\n   339â†’        // Verify the list of valid filter names includes all expected filters\n   340â†’        let expected = [\"from\", \"to\", \"subject\", \"mailbox\", \"is\", \"has\", \"after\", \"before\", \"date\"]\n   341â†’        XCTAssertEqual(MailDatabase.SearchFilter.validFilterNames.sorted(), expected.sorted())\n   342â†’    }\n   343â†’\n   344â†’    func testSearchWithMixedSpecialCharacters() throws {\n   345â†’        try database.initialize()\n   346â†’\n   347â†’        let message = MailMessage(id: \"mixed-test\", subject: \"Can't say \\\"hello (world)\\\"\")\n   348â†’        try database.upsertMessage(message)"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"9215235b-ec2f-46a4-be80-8784250100f8","tool_use_result":{"filePath":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/MailDatabaseTests.swift","oldString":"    func testSearchWithUnknownFilterName() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"filter-test\", subject: \"Test message for filter\")\n        try database.upsertMessage(message)\n\n        // Unknown filter names (badfilter:value format) should not crash\n        // This tests the FTS5 column prefix syntax handling\n        XCTAssertNoThrow(try database.searchMessages(query: \"badfilter:test\"), \"Search should not crash for unknown filter syntax\")\n        XCTAssertNoThrow(try database.searchMessages(query: \"unknown:value\"), \"Search should not crash for unknown filter syntax\")\n        XCTAssertNoThrow(try database.searchMessages(query: \"foo:bar baz:qux\"), \"Search should not crash for multiple unknown filters\")\n    }\n\n    func testSearchWithMixedSpecialCharacters() throws {","newString":"    func testSearchWithUnknownFilterName() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"filter-test\", subject: \"Test message for filter\")\n        try database.upsertMessage(message)\n\n        // Unknown filter names (badfilter:value format) should not crash\n        // This tests the FTS5 column prefix syntax handling\n        XCTAssertNoThrow(try database.searchMessages(query: \"badfilter:test\"), \"Search should not crash for unknown filter syntax\")\n        XCTAssertNoThrow(try database.searchMessages(query: \"unknown:value\"), \"Search should not crash for unknown filter syntax\")\n        XCTAssertNoThrow(try database.searchMessages(query: \"foo:bar baz:qux\"), \"Search should not crash for multiple unknown filters\")\n    }\n\n    func testParseQueryDetectsUnknownFilters() throws {\n        try database.initialize()\n\n        // Single unknown filter\n        let filter1 = database.parseQuery(\"badfilter:test\")\n        XCTAssertTrue(filter1.hasUnknownFilters)\n        XCTAssertEqual(filter1.unknownFilters, [\"badfilter\"])\n\n        // Multiple unknown filters\n        let filter2 = database.parseQuery(\"foo:bar baz:qux\")\n        XCTAssertTrue(filter2.hasUnknownFilters)\n        XCTAssertEqual(filter2.unknownFilters, [\"foo\", \"baz\"])\n\n        // Unknown filter mixed with valid filter\n        let filter3 = database.parseQuery(\"from:alice@example.com badfilter:test\")\n        XCTAssertTrue(filter3.hasUnknownFilters)\n        XCTAssertEqual(filter3.unknownFilters, [\"badfilter\"])\n        XCTAssertEqual(filter3.from, \"alice@example.com\")\n\n        // Valid filters only - no unknown filters\n        let filter4 = database.parseQuery(\"from:alice to:bob subject:hello\")\n        XCTAssertFalse(filter4.hasUnknownFilters)\n        XCTAssertEqual(filter4.unknownFilters, [])\n\n        // Plain text search without filter syntax - no unknown filters\n        let filter5 = database.parseQuery(\"hello world\")\n        XCTAssertFalse(filter5.hasUnknownFilters)\n        XCTAssertEqual(filter5.unknownFilters, [])\n\n        // is: and has: filters are valid\n        let filter6 = database.parseQuery(\"is:read has:attachments\")\n        XCTAssertFalse(filter6.hasUnknownFilters)\n        XCTAssertEqual(filter6.isRead, true)\n        XCTAssertEqual(filter6.hasAttachments, true)\n\n        // Date filters are valid\n        let filter7 = database.parseQuery(\"after:2024-01-01 before:2024-12-31 date:2024-06-15\")\n        XCTAssertFalse(filter7.hasUnknownFilters)\n    }\n\n    func testValidFilterNamesConstant() throws {\n        // Verify the list of valid filter names includes all expected filters\n        let expected = [\"from\", \"to\", \"subject\", \"mailbox\", \"is\", \"has\", \"after\", \"before\", \"date\"]\n        XCTAssertEqual(MailDatabase.SearchFilter.validFilterNames.sorted(), expected.sorted())\n    }\n\n    func testSearchWithMixedSpecialCharacters() throws {","originalFile":"import XCTest\n@testable import SwiftEAKit\n\nfinal class MailDatabaseTests: XCTestCase {\n    var testDir: String!\n    var database: MailDatabase!\n\n    override func setUp() {\n        super.setUp()\n        testDir = NSTemporaryDirectory() + \"swiftea-maildb-test-\\(UUID().uuidString)\"\n        try? FileManager.default.createDirectory(atPath: testDir, withIntermediateDirectories: true)\n\n        let dbPath = (testDir as NSString).appendingPathComponent(\"mail.db\")\n        database = MailDatabase(databasePath: dbPath)\n    }\n\n    override func tearDown() {\n        database.close()\n        try? FileManager.default.removeItem(atPath: testDir)\n        database = nil\n        super.tearDown()\n    }\n\n    // MARK: - Initialization\n\n    func testInitializeCreatesDatabase() throws {\n        try database.initialize()\n\n        let dbPath = (testDir as NSString).appendingPathComponent(\"mail.db\")\n        XCTAssertTrue(FileManager.default.fileExists(atPath: dbPath))\n    }\n\n    func testInitializeTwiceSucceeds() throws {\n        try database.initialize()\n        try database.initialize() // Should not throw\n    }\n\n    // MARK: - Message CRUD\n\n    func testUpsertAndGetMessage() throws {\n        try database.initialize()\n\n        let message = MailMessage(\n            id: \"test-id-123\",\n            appleRowId: 12345,\n            messageId: \"<test@example.com>\",\n            mailboxId: 1,\n            mailboxName: \"INBOX\",\n            accountId: \"account-1\",\n            subject: \"Test Subject\",\n            senderName: \"John Doe\",\n            senderEmail: \"john@example.com\",\n            dateSent: Date(timeIntervalSince1970: 1736177400),\n            dateReceived: Date(timeIntervalSince1970: 1736177500),\n            isRead: true,\n            isFlagged: false,\n            isDeleted: false,\n            hasAttachments: true,\n            emlxPath: \"/path/to/12345.emlx\",\n            bodyText: \"This is the body text.\",\n            bodyHtml: nil\n        )\n\n        try database.upsertMessage(message)\n\n        let retrieved = try database.getMessage(id: \"test-id-123\")\n\n        XCTAssertNotNil(retrieved)\n        XCTAssertEqual(retrieved?.id, \"test-id-123\")\n        XCTAssertEqual(retrieved?.appleRowId, 12345)\n        XCTAssertEqual(retrieved?.messageId, \"<test@example.com>\")\n        XCTAssertEqual(retrieved?.mailboxId, 1)\n        XCTAssertEqual(retrieved?.mailboxName, \"INBOX\")\n        XCTAssertEqual(retrieved?.subject, \"Test Subject\")\n        XCTAssertEqual(retrieved?.senderName, \"John Doe\")\n        XCTAssertEqual(retrieved?.senderEmail, \"john@example.com\")\n        XCTAssertEqual(retrieved?.isRead, true)\n        XCTAssertEqual(retrieved?.isFlagged, false)\n        XCTAssertEqual(retrieved?.hasAttachments, true)\n        XCTAssertEqual(retrieved?.bodyText, \"This is the body text.\")\n    }\n\n    func testGetMessageByAppleRowId() throws {\n        try database.initialize()\n\n        let message = MailMessage(\n            id: \"row-test-id\",\n            appleRowId: 99999,\n            subject: \"Row Test\"\n        )\n\n        try database.upsertMessage(message)\n\n        let retrieved = try database.getMessage(appleRowId: 99999)\n\n        XCTAssertNotNil(retrieved)\n        XCTAssertEqual(retrieved?.id, \"row-test-id\")\n        XCTAssertEqual(retrieved?.appleRowId, 99999)\n    }\n\n    func testGetNonexistentMessageReturnsNil() throws {\n        try database.initialize()\n\n        let retrieved = try database.getMessage(id: \"nonexistent-id\")\n        XCTAssertNil(retrieved)\n    }\n\n    func testUpsertUpdatesExistingMessage() throws {\n        try database.initialize()\n\n        // Insert initial message\n        let message1 = MailMessage(\n            id: \"update-test\",\n            subject: \"Original Subject\",\n            isRead: false\n        )\n        try database.upsertMessage(message1)\n\n        // Update the message\n        let message2 = MailMessage(\n            id: \"update-test\",\n            subject: \"Updated Subject\",\n            isRead: true\n        )\n        try database.upsertMessage(message2)\n\n        let retrieved = try database.getMessage(id: \"update-test\")\n\n        XCTAssertEqual(retrieved?.subject, \"Updated Subject\")\n        XCTAssertEqual(retrieved?.isRead, true)\n    }\n\n    // MARK: - Special Characters\n\n    func testMessageWithSpecialCharactersInSubject() throws {\n        try database.initialize()\n\n        let message = MailMessage(\n            id: \"special-chars\",\n            subject: \"Test with 'quotes' and \\\"double\\\" and emoji ðŸŽ‰\"\n        )\n\n        try database.upsertMessage(message)\n\n        let retrieved = try database.getMessage(id: \"special-chars\")\n        XCTAssertEqual(retrieved?.subject, \"Test with 'quotes' and \\\"double\\\" and emoji ðŸŽ‰\")\n    }\n\n    func testMessageWithSqlInjectionAttempt() throws {\n        try database.initialize()\n\n        let message = MailMessage(\n            id: \"sql-inject\",\n            subject: \"Test'; DROP TABLE messages; --\"\n        )\n\n        try database.upsertMessage(message)\n\n        let retrieved = try database.getMessage(id: \"sql-inject\")\n        XCTAssertNotNil(retrieved)\n        XCTAssertEqual(retrieved?.subject, \"Test'; DROP TABLE messages; --\")\n\n        // Verify table still exists by inserting another message\n        let message2 = MailMessage(id: \"after-inject\", subject: \"After\")\n        try database.upsertMessage(message2)\n        let retrieved2 = try database.getMessage(id: \"after-inject\")\n        XCTAssertNotNil(retrieved2)\n    }\n\n    // MARK: - FTS Search\n\n    func testSearchMessages() throws {\n        try database.initialize()\n\n        // Insert multiple messages\n        let messages = [\n            MailMessage(id: \"search-1\", subject: \"Meeting about project Alpha\", senderEmail: \"alice@example.com\", bodyText: \"Let's discuss the alpha project timeline.\"),\n            MailMessage(id: \"search-2\", subject: \"Quarterly report\", senderEmail: \"bob@example.com\", bodyText: \"Q4 financial results attached.\"),\n            MailMessage(id: \"search-3\", subject: \"Re: Project Alpha update\", senderEmail: \"charlie@example.com\", bodyText: \"Great progress on alpha milestone.\")\n        ]\n\n        for msg in messages {\n            try database.upsertMessage(msg)\n        }\n\n        // Search for \"alpha\"\n        let results = try database.searchMessages(query: \"alpha\")\n\n        XCTAssertEqual(results.count, 2)\n        XCTAssertTrue(results.contains { $0.id == \"search-1\" })\n        XCTAssertTrue(results.contains { $0.id == \"search-3\" })\n    }\n\n    func testSearchWithNoResults() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"no-match\", subject: \"Hello world\")\n        try database.upsertMessage(message)\n\n        let results = try database.searchMessages(query: \"nonexistent\")\n\n        XCTAssertTrue(results.isEmpty)\n    }\n\n    func testSearchWithLimit() throws {\n        try database.initialize()\n\n        // Insert many messages\n        for i in 1...10 {\n            let msg = MailMessage(id: \"limit-\\(i)\", subject: \"Test subject \\(i)\", bodyText: \"Common keyword\")\n            try database.upsertMessage(msg)\n        }\n\n        let results = try database.searchMessages(query: \"keyword\", limit: 5)\n\n        XCTAssertEqual(results.count, 5)\n    }\n\n    // MARK: - FTS5 Special Character Handling\n\n    func testSearchWithSingleQuote() throws {\n        try database.initialize()\n\n        // Insert message containing a single quote\n        let message = MailMessage(id: \"quote-test\", subject: \"It's a test\", bodyText: \"Don't forget to check this.\")\n        try database.upsertMessage(message)\n\n        // Search for single quote - should not crash, should return empty or matching results\n        let results = try database.searchMessages(query: \"'\")\n        // The query should execute without throwing\n        XCTAssertNotNil(results)\n    }\n\n    func testSearchWithDoubleQuote() throws {\n        try database.initialize()\n\n        // Insert message containing double quotes\n        let message = MailMessage(id: \"dquote-test\", subject: \"He said \\\"hello\\\"\", bodyText: \"Test with quotes\")\n        try database.upsertMessage(message)\n\n        // Search for double quote - should not crash\n        let results = try database.searchMessages(query: \"\\\"\")\n        XCTAssertNotNil(results)\n    }\n\n    func testSearchWithSqlInjectionAttempt() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"sql-test\", subject: \"Normal email\")\n        try database.upsertMessage(message)\n\n        // SQL injection-like syntax should not crash or cause errors\n        let results = try database.searchMessages(query: \"OR 1=1 --\")\n        XCTAssertNotNil(results)\n        // Should return empty since this is treated as literal text, not SQL\n        XCTAssertTrue(results.isEmpty)\n    }\n\n    func testSearchWithFts5Operators() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"fts-test\", subject: \"Test AND or OR words\", bodyText: \"NOT near NEAR\")\n        try database.upsertMessage(message)\n\n        // FTS5 operators (AND, OR, NOT, NEAR) should be treated as literal text\n        XCTAssertNoThrow(try database.searchMessages(query: \"AND\"))\n        XCTAssertNoThrow(try database.searchMessages(query: \"OR\"))\n        XCTAssertNoThrow(try database.searchMessages(query: \"NOT\"))\n        XCTAssertNoThrow(try database.searchMessages(query: \"NEAR\"))\n    }\n\n    func testSearchWithSpecialCharacters() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"special-test\", subject: \"Special chars: * ( ) { } [ ]\")\n        try database.upsertMessage(message)\n\n        // Various special characters should not crash\n        let specialChars = [\"*\", \"(\", \")\", \"{\", \"}\", \"[\", \"]\", \"+\", \"-\", \"^\", \"~\"]\n        for char in specialChars {\n            XCTAssertNoThrow(try database.searchMessages(query: char), \"Search should not crash for character: \\(char)\")\n        }\n    }\n\n    func testSearchWithUnknownFilterName() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"filter-test\", subject: \"Test message for filter\")\n        try database.upsertMessage(message)\n\n        // Unknown filter names (badfilter:value format) should not crash\n        // This tests the FTS5 column prefix syntax handling\n        XCTAssertNoThrow(try database.searchMessages(query: \"badfilter:test\"), \"Search should not crash for unknown filter syntax\")\n        XCTAssertNoThrow(try database.searchMessages(query: \"unknown:value\"), \"Search should not crash for unknown filter syntax\")\n        XCTAssertNoThrow(try database.searchMessages(query: \"foo:bar baz:qux\"), \"Search should not crash for multiple unknown filters\")\n    }\n\n    func testSearchWithMixedSpecialCharacters() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"mixed-test\", subject: \"Can't say \\\"hello (world)\\\"\")\n        try database.upsertMessage(message)\n\n        // Complex query with multiple special characters\n        let results = try database.searchMessages(query: \"Can't say \\\"hello\\\"\")\n        XCTAssertNotNil(results)\n    }\n\n    func testSearchWithEmptyQuery() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"empty-test\", subject: \"Test message\")\n        try database.upsertMessage(message)\n\n        // Empty query should not crash\n        let results = try database.searchMessages(query: \"\")\n        XCTAssertNotNil(results)\n\n        // Whitespace-only query should not crash\n        let results2 = try database.searchMessages(query: \"   \")\n        XCTAssertNotNil(results2)\n    }\n\n    // MARK: - Export Path\n\n    func testUpdateExportPath() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"export-test\", subject: \"Export Test\")\n        try database.upsertMessage(message)\n\n        try database.updateExportPath(id: \"export-test\", path: \"/exports/email.md\")\n\n        let retrieved = try database.getMessage(id: \"export-test\")\n        XCTAssertEqual(retrieved?.exportPath, \"/exports/email.md\")\n    }\n\n    // MARK: - Update Message Body (On-Demand Fetching)\n\n    func testUpdateMessageBodyWithBothTextAndHtml() throws {\n        try database.initialize()\n\n        // Insert message without body\n        let message = MailMessage(\n            id: \"body-update-test\",\n            subject: \"Body Update Test\",\n            bodyText: nil,\n            bodyHtml: nil\n        )\n        try database.upsertMessage(message)\n\n        // Verify body is initially nil\n        let initialRetrieved = try database.getMessage(id: \"body-update-test\")\n        XCTAssertNil(initialRetrieved?.bodyText)\n        XCTAssertNil(initialRetrieved?.bodyHtml)\n\n        // Update body\n        try database.updateMessageBody(\n            id: \"body-update-test\",\n            bodyText: \"Plain text body\",\n            bodyHtml: \"<p>HTML body</p>\"\n        )\n\n        // Verify body was updated\n        let retrieved = try database.getMessage(id: \"body-update-test\")\n        XCTAssertEqual(retrieved?.bodyText, \"Plain text body\")\n        XCTAssertEqual(retrieved?.bodyHtml, \"<p>HTML body</p>\")\n    }\n\n    func testUpdateMessageBodyTextOnly() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"text-only-test\", subject: \"Text Only Test\")\n        try database.upsertMessage(message)\n\n        try database.updateMessageBody(\n            id: \"text-only-test\",\n            bodyText: \"Only plain text\",\n            bodyHtml: nil\n        )\n\n        let retrieved = try database.getMessage(id: \"text-only-test\")\n        XCTAssertEqual(retrieved?.bodyText, \"Only plain text\")\n        XCTAssertNil(retrieved?.bodyHtml)\n    }\n\n    func testUpdateMessageBodyHtmlOnly() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"html-only-test\", subject: \"HTML Only Test\")\n        try database.upsertMessage(message)\n\n        try database.updateMessageBody(\n            id: \"html-only-test\",\n            bodyText: nil,\n            bodyHtml: \"<html><body>HTML content</body></html>\"\n        )\n\n        let retrieved = try database.getMessage(id: \"html-only-test\")\n        XCTAssertNil(retrieved?.bodyText)\n        XCTAssertEqual(retrieved?.bodyHtml, \"<html><body>HTML content</body></html>\")\n    }\n\n    func testUpdateMessageBodyWithSpecialCharacters() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"special-body-test\", subject: \"Special Body Test\")\n        try database.upsertMessage(message)\n\n        // Body with SQL-injection-like content and special characters\n        let bodyText = \"Test with 'quotes' and \\\"double quotes\\\" and emoji ðŸŽ‰ and O'Brien's code\"\n        let bodyHtml = \"<p>Test's \\\"content\\\" with <script>alert('xss')</script></p>\"\n\n        try database.updateMessageBody(\n            id: \"special-body-test\",\n            bodyText: bodyText,\n            bodyHtml: bodyHtml\n        )\n\n        let retrieved = try database.getMessage(id: \"special-body-test\")\n        XCTAssertEqual(retrieved?.bodyText, bodyText)\n        XCTAssertEqual(retrieved?.bodyHtml, bodyHtml)\n    }\n\n    func testUpdateMessageBodyOverwritesExistingBody() throws {\n        try database.initialize()\n\n        // Insert message with initial body\n        let message = MailMessage(\n            id: \"overwrite-body-test\",\n            subject: \"Overwrite Body Test\",\n            bodyText: \"Original text\",\n            bodyHtml: \"<p>Original HTML</p>\"\n        )\n        try database.upsertMessage(message)\n\n        // Update body\n        try database.updateMessageBody(\n            id: \"overwrite-body-test\",\n            bodyText: \"New text\",\n            bodyHtml: \"<p>New HTML</p>\"\n        )\n\n        let retrieved = try database.getMessage(id: \"overwrite-body-test\")\n        XCTAssertEqual(retrieved?.bodyText, \"New text\")\n        XCTAssertEqual(retrieved?.bodyHtml, \"<p>New HTML</p>\")\n    }\n\n    func testUpdateMessageBodyBeforeInitializeThrows() throws {\n        // Don't call initialize()\n        XCTAssertThrowsError(try database.updateMessageBody(id: \"test\", bodyText: \"text\", bodyHtml: nil)) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected MailDatabaseError.notInitialized, got \\(error)\")\n                return\n            }\n        }\n    }\n\n    // MARK: - Sync Status\n\n    func testSetAndGetSyncStatus() throws {\n        try database.initialize()\n\n        try database.setSyncStatus(key: \"test_key\", value: \"test_value\")\n\n        let value = try database.getSyncStatus(key: \"test_key\")\n        XCTAssertEqual(value, \"test_value\")\n    }\n\n    func testGetNonexistentSyncStatus() throws {\n        try database.initialize()\n\n        let value = try database.getSyncStatus(key: \"nonexistent_key\")\n        XCTAssertNil(value)\n    }\n\n    func testUpdateSyncStatus() throws {\n        try database.initialize()\n\n        try database.setSyncStatus(key: \"update_key\", value: \"original\")\n        try database.setSyncStatus(key: \"update_key\", value: \"updated\")\n\n        let value = try database.getSyncStatus(key: \"update_key\")\n        XCTAssertEqual(value, \"updated\")\n    }\n\n    func testSetAndGetLastSyncTime() throws {\n        try database.initialize()\n\n        let syncTime = Date(timeIntervalSince1970: 1736177400)\n        try database.setLastSyncTime(syncTime)\n\n        let retrieved = try database.getLastSyncTime()\n        XCTAssertNotNil(retrieved)\n        XCTAssertEqual(retrieved!.timeIntervalSince1970, 1736177400, accuracy: 1.0)\n    }\n\n    func testGetLastSyncTimeWhenNotSet() throws {\n        try database.initialize()\n\n        let retrieved = try database.getLastSyncTime()\n        XCTAssertNil(retrieved)\n    }\n\n    // MARK: - Sync Status Tracking\n\n    func testRecordSyncStart() throws {\n        try database.initialize()\n\n        try database.recordSyncStart(isIncremental: true)\n\n        let summary = try database.getSyncStatusSummary()\n        XCTAssertEqual(summary.state, .running)\n        XCTAssertNotNil(summary.lastSyncStartTime)\n        XCTAssertEqual(summary.isIncremental, true)\n        XCTAssertNil(summary.lastSyncError)\n    }\n\n    func testRecordSyncSuccess() throws {\n        try database.initialize()\n\n        try database.recordSyncStart(isIncremental: false)\n\n        let result = SyncResult(\n            messagesProcessed: 100,\n            messagesAdded: 50,\n            messagesUpdated: 30,\n            messagesDeleted: 5,\n            messagesUnchanged: 15,\n            mailboxesProcessed: 10,\n            errors: [],\n            duration: 5.5,\n            isIncremental: false\n        )\n\n        try database.recordSyncSuccess(result: result)\n\n        let summary = try database.getSyncStatusSummary()\n        XCTAssertEqual(summary.state, .success)\n        XCTAssertNotNil(summary.lastSyncTime)\n        XCTAssertNotNil(summary.lastSyncEndTime)\n        XCTAssertEqual(summary.messagesAdded, 50)\n        XCTAssertEqual(summary.messagesUpdated, 30)\n        XCTAssertEqual(summary.messagesDeleted, 5)\n        XCTAssertNotNil(summary.duration)\n        XCTAssertEqual(summary.duration!, 5.5, accuracy: 0.01)\n        XCTAssertNil(summary.lastSyncError)\n    }\n\n    func testRecordSyncFailure() throws {\n        try database.initialize()\n\n        try database.recordSyncStart(isIncremental: true)\n\n        let error = NSError(domain: \"MailSync\", code: 1, userInfo: [\n            NSLocalizedDescriptionKey: \"Test sync failure\"\n        ])\n        try database.recordSyncFailure(error: error)\n\n        let summary = try database.getSyncStatusSummary()\n        XCTAssertEqual(summary.state, .failed)\n        XCTAssertNotNil(summary.lastSyncEndTime)\n        XCTAssertNotNil(summary.lastSyncError)\n        XCTAssertTrue(summary.lastSyncError?.contains(\"Test sync failure\") ?? false)\n    }\n\n    func testGetSyncStatusSummaryWhenNoSync() throws {\n        try database.initialize()\n\n        let summary = try database.getSyncStatusSummary()\n        XCTAssertEqual(summary.state, .idle)\n        XCTAssertNil(summary.lastSyncTime)\n        XCTAssertNil(summary.lastSyncStartTime)\n        XCTAssertNil(summary.lastSyncEndTime)\n        XCTAssertNil(summary.lastSyncError)\n        XCTAssertEqual(summary.messagesAdded, 0)\n        XCTAssertEqual(summary.messagesUpdated, 0)\n        XCTAssertEqual(summary.messagesDeleted, 0)\n    }\n\n    func testSyncStatusClearsErrorOnSuccess() throws {\n        try database.initialize()\n\n        // First, record a failure\n        try database.recordSyncStart(isIncremental: true)\n        let error = NSError(domain: \"MailSync\", code: 1, userInfo: [\n            NSLocalizedDescriptionKey: \"Previous failure\"\n        ])\n        try database.recordSyncFailure(error: error)\n\n        // Then record success\n        try database.recordSyncStart(isIncremental: false)\n        let result = SyncResult(\n            messagesProcessed: 10,\n            messagesAdded: 10,\n            messagesUpdated: 0,\n            mailboxesProcessed: 1,\n            errors: [],\n            duration: 1.0\n        )\n        try database.recordSyncSuccess(result: result)\n\n        let summary = try database.getSyncStatusSummary()\n        XCTAssertEqual(summary.state, .success)\n        XCTAssertNil(summary.lastSyncError)\n    }\n\n    // MARK: - Mailbox Operations\n\n    func testUpsertAndGetMailboxes() throws {\n        try database.initialize()\n\n        let mailboxes = [\n            Mailbox(id: 1, accountId: \"account-1\", name: \"INBOX\", fullPath: \"INBOX\", messageCount: 100, unreadCount: 10),\n            Mailbox(id: 2, accountId: \"account-1\", name: \"Sent\", fullPath: \"Sent\", messageCount: 50, unreadCount: 0),\n            Mailbox(id: 3, accountId: \"account-1\", name: \"Archive\", fullPath: \"Archive\", parentId: nil, messageCount: 200, unreadCount: 0)\n        ]\n\n        for mailbox in mailboxes {\n            try database.upsertMailbox(mailbox)\n        }\n\n        let retrieved = try database.getMailboxes()\n\n        XCTAssertEqual(retrieved.count, 3)\n        XCTAssertTrue(retrieved.contains { $0.name == \"INBOX\" && $0.messageCount == 100 })\n        XCTAssertTrue(retrieved.contains { $0.name == \"Sent\" && $0.messageCount == 50 })\n    }\n\n    func testUpdateMailbox() throws {\n        try database.initialize()\n\n        let mailbox1 = Mailbox(id: 1, accountId: \"account-1\", name: \"INBOX\", fullPath: \"INBOX\", messageCount: 100, unreadCount: 10)\n        try database.upsertMailbox(mailbox1)\n\n        let mailbox2 = Mailbox(id: 1, accountId: \"account-1\", name: \"INBOX\", fullPath: \"INBOX\", messageCount: 150, unreadCount: 5)\n        try database.upsertMailbox(mailbox2)\n\n        let retrieved = try database.getMailboxes()\n\n        XCTAssertEqual(retrieved.count, 1)\n        XCTAssertEqual(retrieved.first?.messageCount, 150)\n        XCTAssertEqual(retrieved.first?.unreadCount, 5)\n    }\n\n    // MARK: - Error Handling\n\n    func testOperationsBeforeInitializeThrow() throws {\n        // Don't call initialize()\n\n        XCTAssertThrowsError(try database.getMessage(id: \"test\")) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected MailDatabaseError.notInitialized, got \\(error)\")\n                return\n            }\n        }\n    }\n\n    // MARK: - Data Model Tests\n\n    func testMailMessageInitialization() {\n        let message = MailMessage(\n            id: \"msg-1\",\n            appleRowId: 123,\n            messageId: \"<msg@test.com>\",\n            mailboxId: 1,\n            mailboxName: \"INBOX\",\n            accountId: \"acc-1\",\n            subject: \"Test\",\n            senderName: \"Sender\",\n            senderEmail: \"sender@test.com\",\n            dateSent: Date(),\n            dateReceived: Date(),\n            isRead: true,\n            isFlagged: true,\n            isDeleted: false,\n            hasAttachments: true,\n            emlxPath: \"/path/to.emlx\",\n            bodyText: \"Body\",\n            bodyHtml: \"<p>Body</p>\",\n            exportPath: \"/export/path\"\n        )\n\n        XCTAssertEqual(message.id, \"msg-1\")\n        XCTAssertEqual(message.appleRowId, 123)\n        XCTAssertEqual(message.subject, \"Test\")\n        XCTAssertTrue(message.isRead)\n        XCTAssertTrue(message.isFlagged)\n        XCTAssertTrue(message.hasAttachments)\n    }\n\n    func testMailMessageDefaults() {\n        let message = MailMessage(id: \"minimal\", subject: \"Minimal\")\n\n        XCTAssertNil(message.appleRowId)\n        XCTAssertNil(message.messageId)\n        XCTAssertFalse(message.isRead)\n        XCTAssertFalse(message.isFlagged)\n        XCTAssertFalse(message.isDeleted)\n        XCTAssertFalse(message.hasAttachments)\n    }\n\n    func testMailboxInitialization() {\n        let mailbox = Mailbox(\n            id: 1,\n            accountId: \"acc-1\",\n            name: \"INBOX\",\n            fullPath: \"INBOX\",\n            parentId: nil,\n            messageCount: 100,\n            unreadCount: 10\n        )\n\n        XCTAssertEqual(mailbox.id, 1)\n        XCTAssertEqual(mailbox.accountId, \"acc-1\")\n        XCTAssertEqual(mailbox.name, \"INBOX\")\n        XCTAssertEqual(mailbox.messageCount, 100)\n        XCTAssertEqual(mailbox.unreadCount, 10)\n    }\n\n    func testMailAttachmentInitialization() {\n        let attachment = MailAttachment(\n            id: 1,\n            messageId: \"msg-1\",\n            filename: \"doc.pdf\",\n            mimeType: \"application/pdf\",\n            size: 1024,\n            contentId: \"cid123\",\n            isInline: false\n        )\n\n        XCTAssertEqual(attachment.id, 1)\n        XCTAssertEqual(attachment.messageId, \"msg-1\")\n        XCTAssertEqual(attachment.filename, \"doc.pdf\")\n        XCTAssertEqual(attachment.mimeType, \"application/pdf\")\n        XCTAssertEqual(attachment.size, 1024)\n        XCTAssertFalse(attachment.isInline)\n    }\n\n    // MARK: - Error Description Tests\n\n    func testMailDatabaseErrorDescriptions() {\n        let errors: [MailDatabaseError] = [\n            .connectionFailed(underlying: NSError(domain: \"test\", code: 1)),\n            .migrationFailed(underlying: NSError(domain: \"test\", code: 2)),\n            .queryFailed(underlying: NSError(domain: \"test\", code: 3)),\n            .notInitialized\n        ]\n\n        for error in errors {\n            XCTAssertNotNil(error.errorDescription, \"Error should have description\")\n            XCTAssertFalse(error.errorDescription!.isEmpty)\n        }\n    }\n\n    // MARK: - Close and Reopen\n\n    func testCloseAndReopenDatabase() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"persist-test\", subject: \"Persist\")\n        try database.upsertMessage(message)\n\n        database.close()\n\n        // Create new database instance\n        let dbPath = (testDir as NSString).appendingPathComponent(\"mail.db\")\n        let newDatabase = MailDatabase(databasePath: dbPath)\n        try newDatabase.initialize()\n\n        let retrieved = try newDatabase.getMessage(id: \"persist-test\")\n        XCTAssertNotNil(retrieved)\n        XCTAssertEqual(retrieved?.subject, \"Persist\")\n\n        newDatabase.close()\n    }\n\n    // MARK: - Batch Insert Tests\n\n    func testBatchUpsertMessagesInsertsAll() throws {\n        try database.initialize()\n\n        let messages = (1...100).map { i in\n            MailMessage(\n                id: \"batch-\\(i)\",\n                appleRowId: i,\n                subject: \"Batch Test \\(i)\",\n                senderEmail: \"sender\\(i)@example.com\",\n                isRead: i % 2 == 0,\n                isFlagged: i % 3 == 0\n            )\n        }\n\n        let result = try database.batchUpsertMessages(messages)\n\n        XCTAssertEqual(result.inserted, 100)\n        XCTAssertEqual(result.updated, 0)\n        XCTAssertEqual(result.failed, 0)\n        XCTAssertTrue(result.errors.isEmpty)\n        XCTAssertGreaterThan(result.duration, 0)\n\n        // Verify messages were inserted\n        let retrieved1 = try database.getMessage(id: \"batch-1\")\n        XCTAssertNotNil(retrieved1)\n        XCTAssertEqual(retrieved1?.subject, \"Batch Test 1\")\n\n        let retrieved50 = try database.getMessage(id: \"batch-50\")\n        XCTAssertNotNil(retrieved50)\n        XCTAssertEqual(retrieved50?.subject, \"Batch Test 50\")\n\n        let retrieved100 = try database.getMessage(id: \"batch-100\")\n        XCTAssertNotNil(retrieved100)\n        XCTAssertEqual(retrieved100?.subject, \"Batch Test 100\")\n    }\n\n    func testBatchUpsertMessagesUpdatesExisting() throws {\n        try database.initialize()\n\n        // Insert initial messages\n        let initialMessages = (1...50).map { i in\n            MailMessage(id: \"batch-\\(i)\", subject: \"Initial \\(i)\")\n        }\n        _ = try database.batchUpsertMessages(initialMessages)\n\n        // Update with new messages (some new, some updates)\n        let updateMessages = (25...75).map { i in\n            MailMessage(id: \"batch-\\(i)\", subject: \"Updated \\(i)\")\n        }\n\n        let result = try database.batchUpsertMessages(updateMessages)\n\n        // 25-50 are updates (26 messages), 51-75 are inserts (25 messages)\n        XCTAssertEqual(result.inserted, 25)\n        XCTAssertEqual(result.updated, 26)\n        XCTAssertEqual(result.failed, 0)\n\n        // Verify updates\n        let retrieved25 = try database.getMessage(id: \"batch-25\")\n        XCTAssertEqual(retrieved25?.subject, \"Updated 25\")\n\n        let retrieved50 = try database.getMessage(id: \"batch-50\")\n        XCTAssertEqual(retrieved50?.subject, \"Updated 50\")\n\n        // Verify original unchanged\n        let retrieved1 = try database.getMessage(id: \"batch-1\")\n        XCTAssertEqual(retrieved1?.subject, \"Initial 1\")\n    }\n\n    func testBatchUpsertMessagesWithCustomBatchSize() throws {\n        try database.initialize()\n\n        let messages = (1...500).map { i in\n            MailMessage(id: \"custom-batch-\\(i)\", subject: \"Custom Batch \\(i)\")\n        }\n\n        // Use small batch size\n        let config = MailDatabase.BatchInsertConfig(batchSize: 50)\n        let result = try database.batchUpsertMessages(messages, config: config)\n\n        XCTAssertEqual(result.inserted, 500)\n        XCTAssertEqual(result.updated, 0)\n        XCTAssertEqual(result.failed, 0)\n\n        // Verify all were inserted\n        let retrieved = try database.getMessage(id: \"custom-batch-250\")\n        XCTAssertNotNil(retrieved)\n        XCTAssertEqual(retrieved?.subject, \"Custom Batch 250\")\n    }\n\n    func testBatchUpsertMessagesDefaultConfig() {\n        let config = MailDatabase.BatchInsertConfig.default\n        XCTAssertEqual(config.batchSize, 1000)\n    }\n\n    func testBatchUpsertMessagesConfigMinimumBatchSize() {\n        let config = MailDatabase.BatchInsertConfig(batchSize: 0)\n        XCTAssertEqual(config.batchSize, 1)\n\n        let negativeConfig = MailDatabase.BatchInsertConfig(batchSize: -10)\n        XCTAssertEqual(negativeConfig.batchSize, 1)\n    }\n\n    func testBatchUpsertMessagesEmptyArray() throws {\n        try database.initialize()\n\n        let result = try database.batchUpsertMessages([])\n\n        XCTAssertEqual(result.inserted, 0)\n        XCTAssertEqual(result.updated, 0)\n        XCTAssertEqual(result.failed, 0)\n        XCTAssertTrue(result.errors.isEmpty)\n    }\n\n    func testBatchUpsertMessagesWithSpecialCharacters() throws {\n        try database.initialize()\n\n        let messages = [\n            MailMessage(id: \"special-1\", subject: \"Test with 'single quotes'\"),\n            MailMessage(id: \"special-2\", subject: \"Test with \\\"double quotes\\\"\"),\n            MailMessage(id: \"special-3\", subject: \"Test with emoji ðŸŽ‰\"),\n            MailMessage(id: \"special-4\", subject: \"Test'; DROP TABLE messages; --\")\n        ]\n\n        let result = try database.batchUpsertMessages(messages)\n\n        XCTAssertEqual(result.inserted, 4)\n        XCTAssertEqual(result.failed, 0)\n\n        let retrieved1 = try database.getMessage(id: \"special-1\")\n        XCTAssertEqual(retrieved1?.subject, \"Test with 'single quotes'\")\n\n        let retrieved4 = try database.getMessage(id: \"special-4\")\n        XCTAssertEqual(retrieved4?.subject, \"Test'; DROP TABLE messages; --\")\n    }\n\n    func testBatchUpsertMessagesPerformance() throws {\n        try database.initialize()\n\n        // Create a large batch of messages\n        let messageCount = 1000\n        let messages = (1...messageCount).map { i in\n            MailMessage(\n                id: \"perf-\\(i)\",\n                appleRowId: i,\n                messageId: \"<perf\\(i)@test.com>\",\n                mailboxId: 1,\n                mailboxName: \"INBOX\",\n                accountId: \"acc-1\",\n                subject: \"Performance Test \\(i)\",\n                senderName: \"Sender \\(i)\",\n                senderEmail: \"sender\\(i)@test.com\",\n                dateSent: Date(),\n                dateReceived: Date(),\n                isRead: i % 2 == 0,\n                isFlagged: i % 5 == 0,\n                bodyText: \"This is the body text for message \\(i)\"\n            )\n        }\n\n        // Measure batch insert time\n        let startTime = Date()\n        let result = try database.batchUpsertMessages(messages)\n        let batchDuration = Date().timeIntervalSince(startTime)\n\n        XCTAssertEqual(result.inserted, messageCount)\n        XCTAssertEqual(result.failed, 0)\n\n        // Batch inserts should be fast (less than 5 seconds for 1000 messages)\n        XCTAssertLessThan(batchDuration, 5.0, \"Batch insert should complete in less than 5 seconds\")\n\n        // Log performance for reference\n        print(\"Batch insert of \\(messageCount) messages took \\(batchDuration) seconds\")\n        print(\"Rate: \\(Double(messageCount) / batchDuration) messages/second\")\n    }\n\n    func testBatchUpsertMailboxes() throws {\n        try database.initialize()\n\n        let mailboxes = [\n            Mailbox(id: 1, accountId: \"acc-1\", name: \"INBOX\", fullPath: \"INBOX\", messageCount: 100, unreadCount: 10),\n            Mailbox(id: 2, accountId: \"acc-1\", name: \"Sent\", fullPath: \"Sent\", messageCount: 50, unreadCount: 0),\n            Mailbox(id: 3, accountId: \"acc-1\", name: \"Archive\", fullPath: \"Archive\", messageCount: 200, unreadCount: 0)\n        ]\n\n        try database.batchUpsertMailboxes(mailboxes)\n\n        let retrieved = try database.getMailboxes()\n        XCTAssertEqual(retrieved.count, 3)\n        XCTAssertTrue(retrieved.contains { $0.name == \"INBOX\" && $0.messageCount == 100 })\n        XCTAssertTrue(retrieved.contains { $0.name == \"Sent\" && $0.messageCount == 50 })\n        XCTAssertTrue(retrieved.contains { $0.name == \"Archive\" && $0.messageCount == 200 })\n    }\n\n    func testBatchUpsertMailboxesUpdatesExisting() throws {\n        try database.initialize()\n\n        // Insert initial mailboxes\n        let initial = [\n            Mailbox(id: 1, accountId: \"acc-1\", name: \"INBOX\", fullPath: \"INBOX\", messageCount: 100, unreadCount: 10)\n        ]\n        try database.batchUpsertMailboxes(initial)\n\n        // Update mailbox\n        let updated = [\n            Mailbox(id: 1, accountId: \"acc-1\", name: \"INBOX\", fullPath: \"INBOX\", messageCount: 150, unreadCount: 5)\n        ]\n        try database.batchUpsertMailboxes(updated)\n\n        let retrieved = try database.getMailboxes()\n        XCTAssertEqual(retrieved.count, 1)\n        XCTAssertEqual(retrieved.first?.messageCount, 150)\n        XCTAssertEqual(retrieved.first?.unreadCount, 5)\n    }\n\n    func testBatchInsertResultInitialization() {\n        let result = MailDatabase.BatchInsertResult(\n            inserted: 10,\n            updated: 5,\n            failed: 2,\n            errors: [\"Error 1\", \"Error 2\"],\n            duration: 1.5\n        )\n\n        XCTAssertEqual(result.inserted, 10)\n        XCTAssertEqual(result.updated, 5)\n        XCTAssertEqual(result.failed, 2)\n        XCTAssertEqual(result.errors.count, 2)\n        XCTAssertEqual(result.duration, 1.5)\n    }\n\n    // MARK: - Migration V2 Tests (Mailbox Status Tracking)\n\n    func testMigrationV2CreatesMailboxStatusColumn() throws {\n        try database.initialize()\n\n        // Insert a message with default mailbox status\n        let message = MailMessage(id: \"v2-test-1\", subject: \"V2 Test\")\n        try database.upsertMessage(message)\n\n        // Retrieve and verify default mailbox_status is 'inbox'\n        let retrieved = try database.getMessage(id: \"v2-test-1\")\n        XCTAssertNotNil(retrieved)\n        XCTAssertEqual(retrieved?.mailboxStatus, .inbox)\n    }\n\n    func testMigrationV2CreatesPendingSyncActionColumn() throws {\n        try database.initialize()\n\n        // Insert a message without pending sync action\n        let message1 = MailMessage(id: \"v2-sync-1\", subject: \"No Action\")\n        try database.upsertMessage(message1)\n\n        let retrieved1 = try database.getMessage(id: \"v2-sync-1\")\n        XCTAssertNil(retrieved1?.pendingSyncAction)\n\n        // Insert a message with pending archive action\n        let message2 = MailMessage(\n            id: \"v2-sync-2\",\n            subject: \"With Archive Action\",\n            pendingSyncAction: .archive\n        )\n        try database.upsertMessage(message2)\n\n        let retrieved2 = try database.getMessage(id: \"v2-sync-2\")\n        XCTAssertEqual(retrieved2?.pendingSyncAction, .archive)\n\n        // Insert a message with pending delete action\n        let message3 = MailMessage(\n            id: \"v2-sync-3\",\n            subject: \"With Delete Action\",\n            pendingSyncAction: .delete\n        )\n        try database.upsertMessage(message3)\n\n        let retrieved3 = try database.getMessage(id: \"v2-sync-3\")\n        XCTAssertEqual(retrieved3?.pendingSyncAction, .delete)\n    }\n\n    func testMigrationV2CreatesLastKnownMailboxIdColumn() throws {\n        try database.initialize()\n\n        // Insert a message without last known mailbox id\n        let message1 = MailMessage(id: \"v2-mailbox-1\", subject: \"No Mailbox\")\n        try database.upsertMessage(message1)\n\n        let retrieved1 = try database.getMessage(id: \"v2-mailbox-1\")\n        XCTAssertNil(retrieved1?.lastKnownMailboxId)\n\n        // Insert a message with last known mailbox id\n        let message2 = MailMessage(\n            id: \"v2-mailbox-2\",\n            subject: \"With Mailbox\",\n            lastKnownMailboxId: 42\n        )\n        try database.upsertMessage(message2)\n\n        let retrieved2 = try database.getMessage(id: \"v2-mailbox-2\")\n        XCTAssertEqual(retrieved2?.lastKnownMailboxId, 42)\n    }\n\n    func testMailboxStatusEnumValues() {\n        XCTAssertEqual(MailboxStatus.inbox.rawValue, \"inbox\")\n        XCTAssertEqual(MailboxStatus.archived.rawValue, \"archived\")\n        XCTAssertEqual(MailboxStatus.deleted.rawValue, \"deleted\")\n\n        // Test parsing from raw value\n        XCTAssertEqual(MailboxStatus(rawValue: \"inbox\"), .inbox)\n        XCTAssertEqual(MailboxStatus(rawValue: \"archived\"), .archived)\n        XCTAssertEqual(MailboxStatus(rawValue: \"deleted\"), .deleted)\n        XCTAssertNil(MailboxStatus(rawValue: \"unknown\"))\n    }\n\n    func testSyncActionEnumValues() {\n        XCTAssertEqual(SyncAction.archive.rawValue, \"archive\")\n        XCTAssertEqual(SyncAction.delete.rawValue, \"delete\")\n\n        // Test parsing from raw value\n        XCTAssertEqual(SyncAction(rawValue: \"archive\"), .archive)\n        XCTAssertEqual(SyncAction(rawValue: \"delete\"), .delete)\n        XCTAssertNil(SyncAction(rawValue: \"unknown\"))\n    }\n\n    func testMessageWithAllV2Fields() throws {\n        try database.initialize()\n\n        let message = MailMessage(\n            id: \"v2-full-test\",\n            appleRowId: 12345,\n            mailboxId: 1,\n            mailboxName: \"INBOX\",\n            subject: \"Full V2 Test\",\n            mailboxStatus: .archived,\n            pendingSyncAction: .delete,\n            lastKnownMailboxId: 99\n        )\n\n        try database.upsertMessage(message)\n\n        let retrieved = try database.getMessage(id: \"v2-full-test\")\n        XCTAssertNotNil(retrieved)\n        XCTAssertEqual(retrieved?.mailboxStatus, .archived)\n        XCTAssertEqual(retrieved?.pendingSyncAction, .delete)\n        XCTAssertEqual(retrieved?.lastKnownMailboxId, 99)\n    }\n\n    func testExistingMessagesGetDefaultMailboxStatus() throws {\n        // This tests that existing messages (after migration) have mailbox_status = 'inbox'\n        try database.initialize()\n\n        // Insert a message using minimal fields (simulating pre-V2 message)\n        let message = MailMessage(id: \"pre-v2-msg\", subject: \"Pre-V2 Message\")\n        try database.upsertMessage(message)\n\n        let retrieved = try database.getMessage(id: \"pre-v2-msg\")\n        XCTAssertEqual(retrieved?.mailboxStatus, .inbox, \"Existing messages should default to inbox status\")\n    }\n\n    func testMailboxStatusUpdateOnUpsert() throws {\n        try database.initialize()\n\n        // Insert initial message\n        let message1 = MailMessage(\n            id: \"status-update-test\",\n            subject: \"Initial\",\n            mailboxStatus: .inbox\n        )\n        try database.upsertMessage(message1)\n\n        // Update to archived\n        let message2 = MailMessage(\n            id: \"status-update-test\",\n            subject: \"Initial\",\n            mailboxStatus: .archived\n        )\n        try database.upsertMessage(message2)\n\n        let retrieved = try database.getMessage(id: \"status-update-test\")\n        XCTAssertEqual(retrieved?.mailboxStatus, .archived)\n    }\n\n    func testBatchUpsertWithV2Fields() throws {\n        try database.initialize()\n\n        let messages = [\n            MailMessage(id: \"batch-v2-1\", subject: \"Batch 1\", mailboxStatus: .inbox),\n            MailMessage(id: \"batch-v2-2\", subject: \"Batch 2\", mailboxStatus: .archived, pendingSyncAction: .archive),\n            MailMessage(id: \"batch-v2-3\", subject: \"Batch 3\", mailboxStatus: .deleted, pendingSyncAction: .delete, lastKnownMailboxId: 5)\n        ]\n\n        let result = try database.batchUpsertMessages(messages)\n        XCTAssertEqual(result.inserted, 3)\n        XCTAssertEqual(result.failed, 0)\n\n        let retrieved1 = try database.getMessage(id: \"batch-v2-1\")\n        XCTAssertEqual(retrieved1?.mailboxStatus, .inbox)\n        XCTAssertNil(retrieved1?.pendingSyncAction)\n\n        let retrieved2 = try database.getMessage(id: \"batch-v2-2\")\n        XCTAssertEqual(retrieved2?.mailboxStatus, .archived)\n        XCTAssertEqual(retrieved2?.pendingSyncAction, .archive)\n\n        let retrieved3 = try database.getMessage(id: \"batch-v2-3\")\n        XCTAssertEqual(retrieved3?.mailboxStatus, .deleted)\n        XCTAssertEqual(retrieved3?.pendingSyncAction, .delete)\n        XCTAssertEqual(retrieved3?.lastKnownMailboxId, 5)\n    }\n\n    func testMailMessageV2DefaultsInInit() {\n        let message = MailMessage(id: \"defaults-test\", subject: \"Defaults\")\n\n        XCTAssertEqual(message.mailboxStatus, .inbox, \"Default mailboxStatus should be inbox\")\n        XCTAssertNil(message.pendingSyncAction, \"Default pendingSyncAction should be nil\")\n        XCTAssertNil(message.lastKnownMailboxId, \"Default lastKnownMailboxId should be nil\")\n    }\n\n    // MARK: - US-002: Mailbox Status Query and Update Methods\n\n    func testUpdateMailboxStatus() throws {\n        try database.initialize()\n\n        // Insert a message\n        let message = MailMessage(id: \"status-test\", subject: \"Status Test\", mailboxStatus: .inbox)\n        try database.upsertMessage(message)\n\n        // Update status to archived\n        try database.updateMailboxStatus(id: \"status-test\", status: .archived)\n\n        let retrieved = try database.getMessage(id: \"status-test\")\n        XCTAssertEqual(retrieved?.mailboxStatus, .archived)\n\n        // Update status to deleted\n        try database.updateMailboxStatus(id: \"status-test\", status: .deleted)\n\n        let retrieved2 = try database.getMessage(id: \"status-test\")\n        XCTAssertEqual(retrieved2?.mailboxStatus, .deleted)\n\n        // Update back to inbox\n        try database.updateMailboxStatus(id: \"status-test\", status: .inbox)\n\n        let retrieved3 = try database.getMessage(id: \"status-test\")\n        XCTAssertEqual(retrieved3?.mailboxStatus, .inbox)\n    }\n\n    func testUpdateMailboxStatusNonexistentMessage() throws {\n        try database.initialize()\n\n        // This should not throw, it just won't update anything\n        try database.updateMailboxStatus(id: \"nonexistent\", status: .archived)\n\n        // Verify nothing was created\n        let retrieved = try database.getMessage(id: \"nonexistent\")\n        XCTAssertNil(retrieved)\n    }\n\n    func testSetPendingSyncAction() throws {\n        try database.initialize()\n\n        let message = MailMessage(id: \"action-test\", subject: \"Action Test\")\n        try database.upsertMessage(message)\n\n        // Set archive action\n        try database.setPendingSyncAction(id: \"action-test\", action: .archive)\n\n        let retrieved = try database.getMessage(id: \"action-test\")\n        XCTAssertEqual(retrieved?.pendingSyncAction, .archive)\n\n        // Change to delete action\n        try database.setPendingSyncAction(id: \"action-test\", action: .delete)\n\n        let retrieved2 = try database.getMessage(id: \"action-test\")\n        XCTAssertEqual(retrieved2?.pendingSyncAction, .delete)\n    }\n\n    func testSetPendingSyncActionNonexistentMessage() throws {\n        try database.initialize()\n\n        // This should not throw, it just won't update anything\n        try database.setPendingSyncAction(id: \"nonexistent\", action: .archive)\n\n        // Verify nothing was created\n        let retrieved = try database.getMessage(id: \"nonexistent\")\n        XCTAssertNil(retrieved)\n    }\n\n    func testClearPendingSyncAction() throws {\n        try database.initialize()\n\n        // Insert a message with pending action\n        let message = MailMessage(\n            id: \"clear-action-test\",\n            subject: \"Clear Action Test\",\n            pendingSyncAction: .archive\n        )\n        try database.upsertMessage(message)\n\n        // Verify action is set\n        let retrieved1 = try database.getMessage(id: \"clear-action-test\")\n        XCTAssertEqual(retrieved1?.pendingSyncAction, .archive)\n\n        // Clear the action\n        try database.clearPendingSyncAction(id: \"clear-action-test\")\n\n        // Verify action is cleared\n        let retrieved2 = try database.getMessage(id: \"clear-action-test\")\n        XCTAssertNil(retrieved2?.pendingSyncAction)\n    }\n\n    func testClearPendingSyncActionNonexistentMessage() throws {\n        try database.initialize()\n\n        // This should not throw, it just won't update anything\n        try database.clearPendingSyncAction(id: \"nonexistent\")\n\n        // Verify nothing was created\n        let retrieved = try database.getMessage(id: \"nonexistent\")\n        XCTAssertNil(retrieved)\n    }\n\n    func testGetMessagesWithPendingActions() throws {\n        try database.initialize()\n\n        // Insert messages with and without pending actions\n        let messages = [\n            MailMessage(id: \"pending-1\", subject: \"Pending Archive\", pendingSyncAction: .archive),\n            MailMessage(id: \"pending-2\", subject: \"Pending Delete\", pendingSyncAction: .delete),\n            MailMessage(id: \"no-action\", subject: \"No Action\"),\n            MailMessage(id: \"pending-3\", subject: \"Another Archive\", pendingSyncAction: .archive)\n        ]\n\n        for msg in messages {\n            try database.upsertMessage(msg)\n        }\n\n        // Get messages with pending actions\n        let pending = try database.getMessagesWithPendingActions()\n\n        XCTAssertEqual(pending.count, 3)\n        XCTAssertTrue(pending.contains { $0.id == \"pending-1\" })\n        XCTAssertTrue(pending.contains { $0.id == \"pending-2\" })\n        XCTAssertTrue(pending.contains { $0.id == \"pending-3\" })\n        XCTAssertFalse(pending.contains { $0.id == \"no-action\" })\n    }\n\n    func testGetMessagesWithPendingActionsEmpty() throws {\n        try database.initialize()\n\n        // Insert messages without pending actions\n        let message = MailMessage(id: \"no-action\", subject: \"No Action\")\n        try database.upsertMessage(message)\n\n        let pending = try database.getMessagesWithPendingActions()\n\n        XCTAssertTrue(pending.isEmpty)\n    }\n\n    func testGetMessagesWithPendingActionsExcludesDeleted() throws {\n        try database.initialize()\n\n        // Insert a message with pending action but marked as deleted\n        let message = MailMessage(\n            id: \"deleted-pending\",\n            subject: \"Deleted with Action\",\n            isDeleted: true,\n            pendingSyncAction: .archive\n        )\n        try database.upsertMessage(message)\n\n        let pending = try database.getMessagesWithPendingActions()\n\n        XCTAssertTrue(pending.isEmpty, \"Deleted messages should not be returned\")\n    }\n\n    func testGetMessagesByStatus() throws {\n        try database.initialize()\n\n        // Insert messages with different statuses\n        let messages = [\n            MailMessage(id: \"inbox-1\", subject: \"Inbox 1\", mailboxStatus: .inbox),\n            MailMessage(id: \"inbox-2\", subject: \"Inbox 2\", mailboxStatus: .inbox),\n            MailMessage(id: \"archived-1\", subject: \"Archived 1\", mailboxStatus: .archived),\n            MailMessage(id: \"deleted-1\", subject: \"Deleted 1\", mailboxStatus: .deleted)\n        ]\n\n        for msg in messages {\n            try database.upsertMessage(msg)\n        }\n\n        // Get inbox messages\n        let inboxMessages = try database.getMessagesByStatus(.inbox)\n        XCTAssertEqual(inboxMessages.count, 2)\n        XCTAssertTrue(inboxMessages.allSatisfy { $0.mailboxStatus == .inbox })\n\n        // Get archived messages\n        let archivedMessages = try database.getMessagesByStatus(.archived)\n        XCTAssertEqual(archivedMessages.count, 1)\n        XCTAssertEqual(archivedMessages.first?.id, \"archived-1\")\n\n        // Get deleted messages\n        let deletedMessages = try database.getMessagesByStatus(.deleted)\n        XCTAssertEqual(deletedMessages.count, 1)\n        XCTAssertEqual(deletedMessages.first?.id, \"deleted-1\")\n    }\n\n    func testGetMessagesByStatusWithLimitAndOffset() throws {\n        try database.initialize()\n\n        // Insert many inbox messages\n        for i in 1...10 {\n            let message = MailMessage(\n                id: \"inbox-\\(i)\",\n                subject: \"Inbox \\(i)\",\n                dateReceived: Date(timeIntervalSince1970: Double(1000000 + i)),\n                mailboxStatus: .inbox\n            )\n            try database.upsertMessage(message)\n        }\n\n        // Get with limit\n        let limited = try database.getMessagesByStatus(.inbox, limit: 5)\n        XCTAssertEqual(limited.count, 5)\n\n        // Get with offset\n        let offset = try database.getMessagesByStatus(.inbox, limit: 5, offset: 5)\n        XCTAssertEqual(offset.count, 5)\n\n        // Verify no overlap\n        let limitedIds = Set(limited.map { $0.id })\n        let offsetIds = Set(offset.map { $0.id })\n        XCTAssertTrue(limitedIds.isDisjoint(with: offsetIds))\n    }\n\n    func testGetMessagesByStatusEmpty() throws {\n        try database.initialize()\n\n        // Insert inbox messages only\n        let message = MailMessage(id: \"inbox-only\", subject: \"Inbox\", mailboxStatus: .inbox)\n        try database.upsertMessage(message)\n\n        // Query for archived (should be empty)\n        let archived = try database.getMessagesByStatus(.archived)\n        XCTAssertTrue(archived.isEmpty)\n    }\n\n    func testGetMessagesByStatusExcludesDeleted() throws {\n        try database.initialize()\n\n        // Insert a message that's in inbox but soft-deleted\n        let message = MailMessage(\n            id: \"soft-deleted\",\n            subject: \"Soft Deleted\",\n            isDeleted: true,\n            mailboxStatus: .inbox\n        )\n        try database.upsertMessage(message)\n\n        let inboxMessages = try database.getMessagesByStatus(.inbox)\n\n        XCTAssertTrue(inboxMessages.isEmpty, \"Soft-deleted messages should not be returned\")\n    }\n\n    func testGetMessageCountByStatus() throws {\n        try database.initialize()\n\n        // Insert messages with different statuses\n        let messages = [\n            MailMessage(id: \"inbox-1\", subject: \"Inbox 1\", mailboxStatus: .inbox),\n            MailMessage(id: \"inbox-2\", subject: \"Inbox 2\", mailboxStatus: .inbox),\n            MailMessage(id: \"inbox-3\", subject: \"Inbox 3\", mailboxStatus: .inbox),\n            MailMessage(id: \"archived-1\", subject: \"Archived 1\", mailboxStatus: .archived),\n            MailMessage(id: \"archived-2\", subject: \"Archived 2\", mailboxStatus: .archived),\n            MailMessage(id: \"deleted-1\", subject: \"Deleted 1\", mailboxStatus: .deleted)\n        ]\n\n        for msg in messages {\n            try database.upsertMessage(msg)\n        }\n\n        let counts = try database.getMessageCountByStatus()\n\n        XCTAssertEqual(counts[.inbox], 3)\n        XCTAssertEqual(counts[.archived], 2)\n        XCTAssertEqual(counts[.deleted], 1)\n    }\n\n    func testGetMessageCountByStatusEmpty() throws {\n        try database.initialize()\n\n        let counts = try database.getMessageCountByStatus()\n\n        // All counts should be 0\n        XCTAssertEqual(counts[.inbox], 0)\n        XCTAssertEqual(counts[.archived], 0)\n        XCTAssertEqual(counts[.deleted], 0)\n    }\n\n    func testGetMessageCountByStatusExcludesSoftDeleted() throws {\n        try database.initialize()\n\n        // Insert a soft-deleted message\n        let message = MailMessage(\n            id: \"soft-deleted\",\n            subject: \"Soft Deleted\",\n            isDeleted: true,\n            mailboxStatus: .inbox\n        )\n        try database.upsertMessage(message)\n\n        let counts = try database.getMessageCountByStatus()\n\n        XCTAssertEqual(counts[.inbox], 0, \"Soft-deleted messages should not be counted\")\n    }\n\n    func testStatusMethodsBeforeInitializeThrow() throws {\n        // Don't call initialize()\n\n        XCTAssertThrowsError(try database.updateMailboxStatus(id: \"test\", status: .archived)) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n                return\n            }\n        }\n\n        XCTAssertThrowsError(try database.setPendingSyncAction(id: \"test\", action: .archive)) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n                return\n            }\n        }\n\n        XCTAssertThrowsError(try database.clearPendingSyncAction(id: \"test\")) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n                return\n            }\n        }\n\n        XCTAssertThrowsError(try database.getMessagesWithPendingActions()) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n                return\n            }\n        }\n\n        XCTAssertThrowsError(try database.getMessagesByStatus(.inbox)) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n                return\n            }\n        }\n\n        XCTAssertThrowsError(try database.getMessageCountByStatus()) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n                return\n            }\n        }\n    }\n\n    // MARK: - Migration V5: Thread-Messages Junction Table Tests\n\n    func testAddMessageToThread() throws {\n        try database.initialize()\n\n        // Create a thread and a message\n        let thread = Thread(id: \"thread-1\", subject: \"Test Thread\")\n        try database.upsertThread(thread)\n\n        let message = MailMessage(id: \"msg-1\", subject: \"Test Message\")\n        try database.upsertMessage(message)\n\n        // Add message to thread\n        try database.addMessageToThread(messageId: \"msg-1\", threadId: \"thread-1\")\n\n        // Verify the relationship exists\n        let messageIds = try database.getMessageIdsInThread(threadId: \"thread-1\")\n        XCTAssertEqual(messageIds.count, 1)\n        XCTAssertEqual(messageIds.first, \"msg-1\")\n    }\n\n    func testAddMessageToThreadDuplicateIgnored() throws {\n        try database.initialize()\n\n        // Create thread and message\n        let thread = Thread(id: \"thread-dup\", subject: \"Duplicate Test\")\n        try database.upsertThread(thread)\n\n        let message = MailMessage(id: \"msg-dup\", subject: \"Duplicate Message\")\n        try database.upsertMessage(message)\n\n        // Add same message twice - should not throw\n        try database.addMessageToThread(messageId: \"msg-dup\", threadId: \"thread-dup\")\n        try database.addMessageToThread(messageId: \"msg-dup\", threadId: \"thread-dup\")\n\n        // Should still only have one entry\n        let messageIds = try database.getMessageIdsInThread(threadId: \"thread-dup\")\n        XCTAssertEqual(messageIds.count, 1)\n    }\n\n    func testRemoveMessageFromThread() throws {\n        try database.initialize()\n\n        // Setup thread and message\n        let thread = Thread(id: \"thread-remove\", subject: \"Remove Test\")\n        try database.upsertThread(thread)\n\n        let message = MailMessage(id: \"msg-remove\", subject: \"To Be Removed\")\n        try database.upsertMessage(message)\n\n        try database.addMessageToThread(messageId: \"msg-remove\", threadId: \"thread-remove\")\n\n        // Verify it exists\n        var messageIds = try database.getMessageIdsInThread(threadId: \"thread-remove\")\n        XCTAssertEqual(messageIds.count, 1)\n\n        // Remove it\n        try database.removeMessageFromThread(messageId: \"msg-remove\", threadId: \"thread-remove\")\n\n        // Verify it's gone\n        messageIds = try database.getMessageIdsInThread(threadId: \"thread-remove\")\n        XCTAssertEqual(messageIds.count, 0)\n    }\n\n    func testRemoveNonexistentMessageFromThread() throws {\n        try database.initialize()\n\n        // Should not throw even if relationship doesn't exist\n        try database.removeMessageFromThread(messageId: \"nonexistent\", threadId: \"nonexistent\")\n    }\n\n    func testGetMessageIdsInThread() throws {\n        try database.initialize()\n\n        // Create thread and multiple messages\n        let thread = Thread(id: \"thread-multi\", subject: \"Multi Message Thread\")\n        try database.upsertThread(thread)\n\n        for i in 1...5 {\n            let message = MailMessage(id: \"multi-msg-\\(i)\", subject: \"Message \\(i)\")\n            try database.upsertMessage(message)\n            try database.addMessageToThread(messageId: \"multi-msg-\\(i)\", threadId: \"thread-multi\")\n        }\n\n        let messageIds = try database.getMessageIdsInThread(threadId: \"thread-multi\")\n        XCTAssertEqual(messageIds.count, 5)\n        for i in 1...5 {\n            XCTAssertTrue(messageIds.contains(\"multi-msg-\\(i)\"))\n        }\n    }\n\n    func testGetMessageIdsInThreadEmpty() throws {\n        try database.initialize()\n\n        let messageIds = try database.getMessageIdsInThread(threadId: \"nonexistent-thread\")\n        XCTAssertTrue(messageIds.isEmpty)\n    }\n\n    func testGetThreadIdsForMessage() throws {\n        try database.initialize()\n\n        // Create multiple threads and one message\n        for i in 1...3 {\n            let thread = Thread(id: \"multi-thread-\\(i)\", subject: \"Thread \\(i)\")\n            try database.upsertThread(thread)\n        }\n\n        let message = MailMessage(id: \"shared-msg\", subject: \"Shared Message\")\n        try database.upsertMessage(message)\n\n        // Add message to all threads\n        for i in 1...3 {\n            try database.addMessageToThread(messageId: \"shared-msg\", threadId: \"multi-thread-\\(i)\")\n        }\n\n        let threadIds = try database.getThreadIdsForMessage(messageId: \"shared-msg\")\n        XCTAssertEqual(threadIds.count, 3)\n        for i in 1...3 {\n            XCTAssertTrue(threadIds.contains(\"multi-thread-\\(i)\"))\n        }\n    }\n\n    func testGetThreadIdsForMessageEmpty() throws {\n        try database.initialize()\n\n        let threadIds = try database.getThreadIdsForMessage(messageId: \"nonexistent-message\")\n        XCTAssertTrue(threadIds.isEmpty)\n    }\n\n    func testGetMessagesInThreadViaJunction() throws {\n        try database.initialize()\n\n        // Create thread\n        let thread = Thread(id: \"full-thread\", subject: \"Full Thread Test\")\n        try database.upsertThread(thread)\n\n        // Create messages with different dates\n        let baseDate = Date(timeIntervalSince1970: 1000000)\n        for i in 1...3 {\n            let message = MailMessage(\n                id: \"full-msg-\\(i)\",\n                subject: \"Full Message \\(i)\",\n                dateReceived: Date(timeIntervalSince1970: baseDate.timeIntervalSince1970 + Double(i * 100))\n            )\n            try database.upsertMessage(message)\n            try database.addMessageToThread(messageId: \"full-msg-\\(i)\", threadId: \"full-thread\")\n        }\n\n        let messages = try database.getMessagesInThreadViaJunction(threadId: \"full-thread\")\n        XCTAssertEqual(messages.count, 3)\n\n        // Verify ordering by date_received ASC\n        XCTAssertEqual(messages[0].id, \"full-msg-1\")\n        XCTAssertEqual(messages[1].id, \"full-msg-2\")\n        XCTAssertEqual(messages[2].id, \"full-msg-3\")\n    }\n\n    func testGetMessagesInThreadViaJunctionExcludesDeleted() throws {\n        try database.initialize()\n\n        // Create thread\n        let thread = Thread(id: \"deleted-test-thread\", subject: \"Deleted Test\")\n        try database.upsertThread(thread)\n\n        // Create one normal message and one deleted message\n        let normalMsg = MailMessage(id: \"normal-msg\", subject: \"Normal\")\n        let deletedMsg = MailMessage(id: \"deleted-msg\", subject: \"Deleted\", isDeleted: true)\n\n        try database.upsertMessage(normalMsg)\n        try database.upsertMessage(deletedMsg)\n\n        try database.addMessageToThread(messageId: \"normal-msg\", threadId: \"deleted-test-thread\")\n        try database.addMessageToThread(messageId: \"deleted-msg\", threadId: \"deleted-test-thread\")\n\n        let messages = try database.getMessagesInThreadViaJunction(threadId: \"deleted-test-thread\")\n        XCTAssertEqual(messages.count, 1)\n        XCTAssertEqual(messages.first?.id, \"normal-msg\")\n    }\n\n    func testGetMessagesInThreadViaJunctionWithLimitAndOffset() throws {\n        try database.initialize()\n\n        let thread = Thread(id: \"paginated-thread\", subject: \"Paginated Thread\")\n        try database.upsertThread(thread)\n\n        // Create 10 messages\n        for i in 1...10 {\n            let message = MailMessage(\n                id: \"paginated-msg-\\(i)\",\n                subject: \"Message \\(i)\",\n                dateReceived: Date(timeIntervalSince1970: Double(1000000 + i))\n            )\n            try database.upsertMessage(message)\n            try database.addMessageToThread(messageId: \"paginated-msg-\\(i)\", threadId: \"paginated-thread\")\n        }\n\n        // Get first 5\n        let first5 = try database.getMessagesInThreadViaJunction(threadId: \"paginated-thread\", limit: 5)\n        XCTAssertEqual(first5.count, 5)\n\n        // Get next 5\n        let next5 = try database.getMessagesInThreadViaJunction(threadId: \"paginated-thread\", limit: 5, offset: 5)\n        XCTAssertEqual(next5.count, 5)\n\n        // Verify no overlap\n        let first5Ids = Set(first5.map { $0.id })\n        let next5Ids = Set(next5.map { $0.id })\n        XCTAssertTrue(first5Ids.isDisjoint(with: next5Ids))\n    }\n\n    func testGetThreadsForMessage() throws {\n        try database.initialize()\n\n        // Create threads with different dates\n        let baseDate = Date(timeIntervalSince1970: 1000000)\n        for i in 1...3 {\n            let thread = Thread(\n                id: \"msg-threads-\\(i)\",\n                subject: \"Thread \\(i)\",\n                lastDate: Date(timeIntervalSince1970: baseDate.timeIntervalSince1970 + Double(i * 100))\n            )\n            try database.upsertThread(thread)\n        }\n\n        let message = MailMessage(id: \"thread-query-msg\", subject: \"Query Message\")\n        try database.upsertMessage(message)\n\n        // Add message to all threads\n        for i in 1...3 {\n            try database.addMessageToThread(messageId: \"thread-query-msg\", threadId: \"msg-threads-\\(i)\")\n        }\n\n        let threads = try database.getThreadsForMessage(messageId: \"thread-query-msg\")\n        XCTAssertEqual(threads.count, 3)\n\n        // Verify ordering by last_date DESC\n        XCTAssertEqual(threads[0].id, \"msg-threads-3\")\n        XCTAssertEqual(threads[1].id, \"msg-threads-2\")\n        XCTAssertEqual(threads[2].id, \"msg-threads-1\")\n    }\n\n    func testGetThreadsForMessageEmpty() throws {\n        try database.initialize()\n\n        let threads = try database.getThreadsForMessage(messageId: \"nonexistent\")\n        XCTAssertTrue(threads.isEmpty)\n    }\n\n    func testGetMessageCountInThread() throws {\n        try database.initialize()\n\n        let thread = Thread(id: \"count-thread\", subject: \"Count Thread\")\n        try database.upsertThread(thread)\n\n        // Initially empty\n        var count = try database.getMessageCountInThread(threadId: \"count-thread\")\n        XCTAssertEqual(count, 0)\n\n        // Add messages\n        for i in 1...5 {\n            let message = MailMessage(id: \"count-msg-\\(i)\", subject: \"Count Message \\(i)\")\n            try database.upsertMessage(message)\n            try database.addMessageToThread(messageId: \"count-msg-\\(i)\", threadId: \"count-thread\")\n        }\n\n        count = try database.getMessageCountInThread(threadId: \"count-thread\")\n        XCTAssertEqual(count, 5)\n    }\n\n    func testGetMessageCountInThreadNonexistent() throws {\n        try database.initialize()\n\n        let count = try database.getMessageCountInThread(threadId: \"nonexistent\")\n        XCTAssertEqual(count, 0)\n    }\n\n    func testIsMessageInThread() throws {\n        try database.initialize()\n\n        let thread = Thread(id: \"check-thread\", subject: \"Check Thread\")\n        try database.upsertThread(thread)\n\n        let message = MailMessage(id: \"check-msg\", subject: \"Check Message\")\n        try database.upsertMessage(message)\n\n        // Initially not in thread\n        var inThread = try database.isMessageInThread(messageId: \"check-msg\", threadId: \"check-thread\")\n        XCTAssertFalse(inThread)\n\n        // Add to thread\n        try database.addMessageToThread(messageId: \"check-msg\", threadId: \"check-thread\")\n\n        // Now in thread\n        inThread = try database.isMessageInThread(messageId: \"check-msg\", threadId: \"check-thread\")\n        XCTAssertTrue(inThread)\n\n        // Remove from thread\n        try database.removeMessageFromThread(messageId: \"check-msg\", threadId: \"check-thread\")\n\n        // Not in thread anymore\n        inThread = try database.isMessageInThread(messageId: \"check-msg\", threadId: \"check-thread\")\n        XCTAssertFalse(inThread)\n    }\n\n    func testIsMessageInThreadNonexistent() throws {\n        try database.initialize()\n\n        let inThread = try database.isMessageInThread(messageId: \"nonexistent\", threadId: \"nonexistent\")\n        XCTAssertFalse(inThread)\n    }\n\n    func testThreadMessageForeignKeyConstraintOnThreadDelete() throws {\n        try database.initialize()\n\n        // Create thread and message\n        let thread = Thread(id: \"fk-thread\", subject: \"FK Thread\")\n        try database.upsertThread(thread)\n\n        let message = MailMessage(id: \"fk-msg\", subject: \"FK Message\")\n        try database.upsertMessage(message)\n\n        try database.addMessageToThread(messageId: \"fk-msg\", threadId: \"fk-thread\")\n\n        // Verify relationship exists\n        var messageIds = try database.getMessageIdsInThread(threadId: \"fk-thread\")\n        XCTAssertEqual(messageIds.count, 1)\n\n        // Note: SQLite's foreign key CASCADE delete would clean up thread_messages\n        // when the thread is deleted. However, we don't have a deleteThread method yet.\n        // This test verifies the junction table is working correctly.\n    }\n\n    func testManyToManyRelationship() throws {\n        try database.initialize()\n\n        // Create multiple threads\n        let threads = [\"thread-a\", \"thread-b\", \"thread-c\"]\n        for threadId in threads {\n            try database.upsertThread(Thread(id: threadId, subject: \"Thread \\(threadId)\"))\n        }\n\n        // Create multiple messages\n        let messages = [\"msg-1\", \"msg-2\", \"msg-3\"]\n        for msgId in messages {\n            try database.upsertMessage(MailMessage(id: msgId, subject: \"Message \\(msgId)\"))\n        }\n\n        // Create many-to-many relationships:\n        // msg-1 -> thread-a, thread-b\n        // msg-2 -> thread-b, thread-c\n        // msg-3 -> thread-a, thread-c\n        try database.addMessageToThread(messageId: \"msg-1\", threadId: \"thread-a\")\n        try database.addMessageToThread(messageId: \"msg-1\", threadId: \"thread-b\")\n        try database.addMessageToThread(messageId: \"msg-2\", threadId: \"thread-b\")\n        try database.addMessageToThread(messageId: \"msg-2\", threadId: \"thread-c\")\n        try database.addMessageToThread(messageId: \"msg-3\", threadId: \"thread-a\")\n        try database.addMessageToThread(messageId: \"msg-3\", threadId: \"thread-c\")\n\n        // Verify thread-a has msg-1 and msg-3\n        let threadAMessages = try database.getMessageIdsInThread(threadId: \"thread-a\")\n        XCTAssertEqual(threadAMessages.count, 2)\n        XCTAssertTrue(threadAMessages.contains(\"msg-1\"))\n        XCTAssertTrue(threadAMessages.contains(\"msg-3\"))\n\n        // Verify thread-b has msg-1 and msg-2\n        let threadBMessages = try database.getMessageIdsInThread(threadId: \"thread-b\")\n        XCTAssertEqual(threadBMessages.count, 2)\n        XCTAssertTrue(threadBMessages.contains(\"msg-1\"))\n        XCTAssertTrue(threadBMessages.contains(\"msg-2\"))\n\n        // Verify thread-c has msg-2 and msg-3\n        let threadCMessages = try database.getMessageIdsInThread(threadId: \"thread-c\")\n        XCTAssertEqual(threadCMessages.count, 2)\n        XCTAssertTrue(threadCMessages.contains(\"msg-2\"))\n        XCTAssertTrue(threadCMessages.contains(\"msg-3\"))\n\n        // Verify msg-1 is in thread-a and thread-b\n        let msg1Threads = try database.getThreadIdsForMessage(messageId: \"msg-1\")\n        XCTAssertEqual(msg1Threads.count, 2)\n        XCTAssertTrue(msg1Threads.contains(\"thread-a\"))\n        XCTAssertTrue(msg1Threads.contains(\"thread-b\"))\n    }\n\n    func testThreadMessageJunctionMethodsBeforeInitializeThrow() throws {\n        // Don't call initialize()\n\n        XCTAssertThrowsError(try database.addMessageToThread(messageId: \"test\", threadId: \"test\")) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n                return\n            }\n        }\n\n        XCTAssertThrowsError(try database.removeMessageFromThread(messageId: \"test\", threadId: \"test\")) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n                return\n            }\n        }\n\n        XCTAssertThrowsError(try database.getMessageIdsInThread(threadId: \"test\")) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n                return\n            }\n        }\n\n        XCTAssertThrowsError(try database.getThreadIdsForMessage(messageId: \"test\")) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n                return\n            }\n        }\n\n        XCTAssertThrowsError(try database.getMessagesInThreadViaJunction(threadId: \"test\")) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n                return\n            }\n        }\n\n        XCTAssertThrowsError(try database.getThreadsForMessage(messageId: \"test\")) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n                return\n            }\n        }\n\n        XCTAssertThrowsError(try database.getMessageCountInThread(threadId: \"test\")) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n                return\n            }\n        }\n\n        XCTAssertThrowsError(try database.isMessageInThread(messageId: \"test\", threadId: \"test\")) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n                return\n            }\n        }\n    }\n\n    // MARK: - US-004: Thread Index Tests\n\n    func testThreadIdIndexExistsOnMessagesTable() throws {\n        try database.initialize()\n\n        let indexes = try database.getIndexes(on: \"messages\")\n\n        XCTAssertTrue(indexes.contains(\"idx_messages_thread_id\"),\n                      \"Index idx_messages_thread_id should exist on messages table. Found: \\(indexes)\")\n    }\n\n    func testThreadsTableHasPrimaryKeyIndex() throws {\n        try database.initialize()\n\n        // SQLite automatically creates an index for the PRIMARY KEY\n        // We can verify this by checking the table info\n        let indexes = try database.getIndexes(on: \"threads\")\n\n        // The threads table should have an index on last_date\n        XCTAssertTrue(indexes.contains(\"idx_threads_last_date\"),\n                      \"Index idx_threads_last_date should exist on threads table. Found: \\(indexes)\")\n    }\n\n    func testThreadMessagesIndexesExist() throws {\n        try database.initialize()\n\n        let indexes = try database.getIndexes(on: \"thread_messages\")\n\n        XCTAssertTrue(indexes.contains(\"idx_thread_messages_thread_id\"),\n                      \"Index idx_thread_messages_thread_id should exist on thread_messages table. Found: \\(indexes)\")\n        XCTAssertTrue(indexes.contains(\"idx_thread_messages_message_id\"),\n                      \"Index idx_thread_messages_message_id should exist on thread_messages table. Found: \\(indexes)\")\n    }\n\n    func testExplainQueryPlanUsesThreadIdIndex() throws {\n        try database.initialize()\n\n        // Create thread first (required for foreign key constraint)\n        let thread = Thread(id: \"test-thread-id\", subject: \"Test Thread\")\n        try database.upsertThread(thread)\n\n        // Insert some test data to ensure table has data\n        let message = MailMessage(id: \"plan-test-msg\", subject: \"Plan Test\", threadId: \"test-thread-id\")\n        try database.upsertMessage(message)\n\n        // Query plan for looking up messages by thread_id\n        let plan = try database.explainQueryPlan(\n            \"SELECT * FROM messages WHERE thread_id = 'test-thread-id'\"\n        )\n\n        // The plan should show usage of the index\n        // SQLite's EXPLAIN QUERY PLAN typically shows \"SEARCH\" with index usage\n        let planString = plan.joined(separator: \" \")\n        XCTAssertTrue(\n            planString.contains(\"idx_messages_thread_id\") || planString.contains(\"USING INDEX\"),\n            \"Query should use idx_messages_thread_id index. Plan: \\(planString)\"\n        )\n    }\n\n    func testExplainQueryPlanUsesThreadMessagesIndex() throws {\n        try database.initialize()\n\n        // Insert test data\n        let thread = Thread(id: \"plan-thread\", subject: \"Plan Thread\")\n        try database.upsertThread(thread)\n        let message = MailMessage(id: \"plan-msg\", subject: \"Plan Message\")\n        try database.upsertMessage(message)\n        try database.addMessageToThread(messageId: \"plan-msg\", threadId: \"plan-thread\")\n\n        // Query plan for looking up messages in a thread via junction table\n        let plan = try database.explainQueryPlan(\n            \"SELECT message_id FROM thread_messages WHERE thread_id = 'plan-thread'\"\n        )\n\n        // The plan should show usage of an index (could be explicit index or autoindex for primary key)\n        // SQLite may use sqlite_autoindex_thread_messages_1 which is the covering index for the composite primary key\n        let planString = plan.joined(separator: \" \")\n        XCTAssertTrue(\n            planString.contains(\"idx_thread_messages_thread_id\") ||\n            planString.contains(\"USING INDEX\") ||\n            planString.contains(\"USING COVERING INDEX\") ||\n            planString.contains(\"sqlite_autoindex\"),\n            \"Query should use an index. Plan: \\(planString)\"\n        )\n    }\n\n    func testIndexVerificationMethodsBeforeInitializeThrow() throws {\n        // Don't call initialize()\n\n        XCTAssertThrowsError(try database.getIndexes(on: \"messages\")) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n                return\n            }\n        }\n\n        XCTAssertThrowsError(try database.explainQueryPlan(\"SELECT 1\")) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected MailDatabaseError.notInitialized\")\n                return\n            }\n        }\n    }\n\n    // MARK: - US-023: Large Inbox Query Optimization Tests\n\n    func testMigrationV7IndexesExist() throws {\n        try database.initialize()\n\n        // Verify indexes added in migration V7 for large inbox optimization\n        let threadIndexes = try database.getIndexes(on: \"threads\")\n        XCTAssertTrue(threadIndexes.contains(\"idx_threads_subject\"),\n                      \"Index idx_threads_subject should exist on threads table. Found: \\(threadIndexes)\")\n        XCTAssertTrue(threadIndexes.contains(\"idx_threads_message_count\"),\n                      \"Index idx_threads_message_count should exist on threads table. Found: \\(threadIndexes)\")\n\n        let messageIndexes = try database.getIndexes(on: \"messages\")\n        XCTAssertTrue(messageIndexes.contains(\"idx_messages_sender_email\"),\n                      \"Index idx_messages_sender_email should exist on messages table. Found: \\(messageIndexes)\")\n        XCTAssertTrue(messageIndexes.contains(\"idx_messages_thread_position\"),\n                      \"Index idx_messages_thread_position should exist on messages table. Found: \\(messageIndexes)\")\n\n        let recipientIndexes = try database.getIndexes(on: \"recipients\")\n        XCTAssertTrue(recipientIndexes.contains(\"idx_recipients_email\"),\n                      \"Index idx_recipients_email should exist on recipients table. Found: \\(recipientIndexes)\")\n    }\n\n    func testThreadListingUsesLastDateIndex() throws {\n        try database.initialize()\n\n        // Insert test data\n        let thread = Thread(id: \"perf-thread\", subject: \"Performance Test\")\n        try database.upsertThread(thread)\n\n        // Query plan for basic thread listing by date\n        let plan = try database.explainQueryPlan(\n            \"SELECT * FROM threads ORDER BY last_date DESC LIMIT 50\"\n        )\n\n        let planString = plan.joined(separator: \" \")\n        XCTAssertTrue(\n            planString.contains(\"idx_threads_last_date\") || planString.contains(\"USING INDEX\"),\n            \"Thread listing by date should use idx_threads_last_date. Plan: \\(planString)\"\n        )\n    }\n\n    func testThreadListingBySubjectUsesIndex() throws {\n        try database.initialize()\n\n        let thread = Thread(id: \"subj-thread\", subject: \"Subject Test\")\n        try database.upsertThread(thread)\n\n        // Query plan for thread listing by subject\n        let plan = try database.explainQueryPlan(\n            \"SELECT * FROM threads ORDER BY subject LIMIT 50\"\n        )\n\n        let planString = plan.joined(separator: \" \")\n        XCTAssertTrue(\n            planString.contains(\"idx_threads_subject\") || planString.contains(\"USING INDEX\") || planString.contains(\"SCAN\"),\n            \"Query should use idx_threads_subject or scan. Plan: \\(planString)\"\n        )\n    }\n\n    func testThreadListingByMessageCountUsesIndex() throws {\n        try database.initialize()\n\n        let thread = Thread(id: \"count-thread\", subject: \"Count Test\", messageCount: 5)\n        try database.upsertThread(thread)\n\n        // Query plan for thread listing by message count\n        let plan = try database.explainQueryPlan(\n            \"SELECT * FROM threads ORDER BY message_count DESC LIMIT 50\"\n        )\n\n        let planString = plan.joined(separator: \" \")\n        XCTAssertTrue(\n            planString.contains(\"idx_threads_message_count\") || planString.contains(\"USING INDEX\") || planString.contains(\"SCAN\"),\n            \"Query should use idx_threads_message_count or scan. Plan: \\(planString)\"\n        )\n    }\n\n    func testBatchThreadPositionUpdate() throws {\n        try database.initialize()\n\n        // Create a thread with 15 messages to trigger batch update\n        let thread = Thread(id: \"batch-thread\", subject: \"Batch Update Test\")\n        try database.upsertThread(thread)\n\n        for i in 1...15 {\n            let message = MailMessage(\n                id: \"batch-msg-\\(i)\",\n                subject: \"Message \\(i)\",\n                dateReceived: Date(timeIntervalSince1970: Double(1700000000 + i * 100)),\n                threadId: \"batch-thread\"\n            )\n            try database.upsertMessage(message)\n            try database.addMessageToThread(messageId: \"batch-msg-\\(i)\", threadId: \"batch-thread\")\n        }\n\n        // Update thread positions using batch update\n        try database.updateThreadPositions(threadId: \"batch-thread\")\n\n        // Verify positions were updated correctly\n        let messages = try database.getMessagesInThreadViaJunction(threadId: \"batch-thread\", limit: 100, offset: 0)\n        XCTAssertEqual(messages.count, 15)\n\n        for (index, message) in messages.enumerated() {\n            XCTAssertEqual(message.threadPosition, index + 1,\n                          \"Message \\(message.id) should have position \\(index + 1)\")\n            XCTAssertEqual(message.threadTotal, 15,\n                          \"Message \\(message.id) should have total 15\")\n        }\n    }\n\n    func testSmallThreadPositionUpdateUsesIndividualQueries() throws {\n        try database.initialize()\n\n        // Create a thread with 5 messages (below batch threshold of 10)\n        let thread = Thread(id: \"small-thread\", subject: \"Small Thread Test\")\n        try database.upsertThread(thread)\n\n        for i in 1...5 {\n            let message = MailMessage(\n                id: \"small-msg-\\(i)\",\n                subject: \"Message \\(i)\",\n                dateReceived: Date(timeIntervalSince1970: Double(1700000000 + i * 100)),\n                threadId: \"small-thread\"\n            )\n            try database.upsertMessage(message)\n            try database.addMessageToThread(messageId: \"small-msg-\\(i)\", threadId: \"small-thread\")\n        }\n\n        // Update thread positions\n        try database.updateThreadPositions(threadId: \"small-thread\")\n\n        // Verify positions were updated correctly\n        let messages = try database.getMessagesInThreadViaJunction(threadId: \"small-thread\", limit: 100, offset: 0)\n        XCTAssertEqual(messages.count, 5)\n\n        for (index, message) in messages.enumerated() {\n            XCTAssertEqual(message.threadPosition, index + 1)\n            XCTAssertEqual(message.threadTotal, 5)\n        }\n    }\n\n    func testEmptyThreadPositionUpdateDoesNothing() throws {\n        try database.initialize()\n\n        let thread = Thread(id: \"empty-thread\", subject: \"Empty Thread\")\n        try database.upsertThread(thread)\n\n        // Should not throw for empty thread\n        XCTAssertNoThrow(try database.updateThreadPositions(threadId: \"empty-thread\"))\n    }\n\n    func testThreadQueryWithPaginationBoundsMemory() throws {\n        try database.initialize()\n\n        // Create 100 threads\n        for i in 1...100 {\n            let thread = Thread(\n                id: \"page-thread-\\(i)\",\n                subject: \"Thread \\(i)\",\n                lastDate: Date(timeIntervalSince1970: Double(1700000000 + i * 100))\n            )\n            try database.upsertThread(thread)\n        }\n\n        // Get first page of 10\n        let page1 = try database.getThreads(limit: 10, offset: 0)\n        XCTAssertEqual(page1.count, 10, \"First page should have 10 threads\")\n\n        // Get second page of 10\n        let page2 = try database.getThreads(limit: 10, offset: 10)\n        XCTAssertEqual(page2.count, 10, \"Second page should have 10 threads\")\n\n        // Verify pages don't overlap\n        let page1Ids = Set(page1.map { $0.id })\n        let page2Ids = Set(page2.map { $0.id })\n        XCTAssertTrue(page1Ids.isDisjoint(with: page2Ids), \"Pages should not overlap\")\n    }\n\n    func testThreadDetailViewUsesIndexes() throws {\n        try database.initialize()\n\n        // Create thread with messages\n        let thread = Thread(id: \"detail-thread\", subject: \"Detail Test\")\n        try database.upsertThread(thread)\n\n        let message = MailMessage(id: \"detail-msg\", subject: \"Detail Message\", threadId: \"detail-thread\")\n        try database.upsertMessage(message)\n        try database.addMessageToThread(messageId: \"detail-msg\", threadId: \"detail-thread\")\n\n        // Query plan for thread detail (get messages in thread)\n        let plan = try database.explainQueryPlan(\n            \"SELECT m.* FROM messages m JOIN thread_messages tm ON m.id = tm.message_id WHERE tm.thread_id = 'detail-thread' ORDER BY m.date_received ASC\"\n        )\n\n        let planString = plan.joined(separator: \" \")\n        XCTAssertTrue(\n            planString.contains(\"idx_thread_messages_thread_id\") ||\n            planString.contains(\"USING INDEX\") ||\n            planString.contains(\"USING COVERING INDEX\") ||\n            planString.contains(\"sqlite_autoindex\"),\n            \"Thread detail query should use an index. Plan: \\(planString)\"\n        )\n    }\n\n    // MARK: - US-005: Database Migration Script Tests\n\n    func testGetSchemaVersionReturnsCurrentVersion() throws {\n        try database.initialize()\n\n        let version = try database.getSchemaVersion()\n        XCTAssertEqual(version, MailDatabase.currentSchemaVersion,\n                       \"Schema version should be \\(MailDatabase.currentSchemaVersion) after initialization\")\n    }\n\n    func testGetSchemaVersionBeforeInitializationThrows() {\n        // Database not initialized\n        XCTAssertThrowsError(try database.getSchemaVersion()) { error in\n            guard case MailDatabaseError.notInitialized = error else {\n                XCTFail(\"Expected notInitialized error, got: \\(error)\")\n                return\n            }\n        }\n    }\n\n    func testMigrationHistoryContainsAllVersions() throws {\n        try database.initialize()\n\n        let history = try database.getMigrationHistory()\n\n        // Should have all migrations from V1 to current\n        XCTAssertEqual(history.count, MailDatabase.currentSchemaVersion,\n                       \"Migration history should have \\(MailDatabase.currentSchemaVersion) entries\")\n\n        // Verify each version is present\n        for version in 1...MailDatabase.currentSchemaVersion {\n            XCTAssertTrue(history.contains { $0.version == version },\n                          \"Migration history should contain version \\(version)\")\n        }\n\n        // Verify timestamps are present\n        for (_, appliedAt) in history {\n            XCTAssertFalse(appliedAt.isEmpty, \"Applied timestamp should not be empty\")\n        }\n    }\n\n    func testTableExistsForCoreThreadingTables() throws {\n        try database.initialize()\n\n        // Core tables that should exist after migration\n        XCTAssertTrue(try database.tableExists(\"messages\"), \"messages table should exist\")\n        XCTAssertTrue(try database.tableExists(\"threads\"), \"threads table should exist\")\n        XCTAssertTrue(try database.tableExists(\"thread_messages\"), \"thread_messages table should exist\")\n        XCTAssertTrue(try database.tableExists(\"recipients\"), \"recipients table should exist\")\n        XCTAssertTrue(try database.tableExists(\"attachments\"), \"attachments table should exist\")\n        XCTAssertTrue(try database.tableExists(\"mailboxes\"), \"mailboxes table should exist\")\n        XCTAssertTrue(try database.tableExists(\"schema_version\"), \"schema_version table should exist\")\n    }\n\n    func testTableExistsReturnsFalseForNonExistentTable() throws {\n        try database.initialize()\n\n        XCTAssertFalse(try database.tableExists(\"nonexistent_table\"),\n                       \"tableExists should return false for non-existent table\")\n    }\n\n    func testGetTableColumnsForMessages() throws {\n        try database.initialize()\n\n        let columns = try database.getTableColumns(\"messages\")\n\n        // Check core columns from V1\n        XCTAssertTrue(columns.contains(\"id\"), \"messages should have id column\")\n        XCTAssertTrue(columns.contains(\"apple_rowid\"), \"messages should have apple_rowid column\")\n        XCTAssertTrue(columns.contains(\"message_id\"), \"messages should have message_id column\")\n        XCTAssertTrue(columns.contains(\"subject\"), \"messages should have subject column\")\n\n        // Check V3 threading columns\n        XCTAssertTrue(columns.contains(\"in_reply_to\"), \"messages should have in_reply_to column (V3)\")\n        XCTAssertTrue(columns.contains(\"threading_references\"), \"messages should have threading_references column (V3)\")\n\n        // Check V4 thread_id column\n        XCTAssertTrue(columns.contains(\"thread_id\"), \"messages should have thread_id column (V4)\")\n\n        // Check V6 thread position columns\n        XCTAssertTrue(columns.contains(\"thread_position\"), \"messages should have thread_position column (V6)\")\n        XCTAssertTrue(columns.contains(\"thread_total\"), \"messages should have thread_total column (V6)\")\n    }\n\n    func testGetTableColumnsForThreads() throws {\n        try database.initialize()\n\n        let columns = try database.getTableColumns(\"threads\")\n\n        // Check all expected columns in threads table (V4)\n        XCTAssertTrue(columns.contains(\"id\"), \"threads should have id column\")\n        XCTAssertTrue(columns.contains(\"subject\"), \"threads should have subject column\")\n        XCTAssertTrue(columns.contains(\"participant_count\"), \"threads should have participant_count column\")\n        XCTAssertTrue(columns.contains(\"message_count\"), \"threads should have message_count column\")\n        XCTAssertTrue(columns.contains(\"first_date\"), \"threads should have first_date column\")\n        XCTAssertTrue(columns.contains(\"last_date\"), \"threads should have last_date column\")\n        XCTAssertTrue(columns.contains(\"created_at\"), \"threads should have created_at column\")\n        XCTAssertTrue(columns.contains(\"updated_at\"), \"threads should have updated_at column\")\n    }\n\n    func testGetTableColumnsForThreadMessages() throws {\n        try database.initialize()\n\n        let columns = try database.getTableColumns(\"thread_messages\")\n\n        // Check all expected columns in thread_messages junction table (V5)\n        XCTAssertTrue(columns.contains(\"thread_id\"), \"thread_messages should have thread_id column\")\n        XCTAssertTrue(columns.contains(\"message_id\"), \"thread_messages should have message_id column\")\n        XCTAssertTrue(columns.contains(\"added_at\"), \"thread_messages should have added_at column\")\n    }\n\n    func testMigrationIsIdempotent() throws {\n        // Run migrations once\n        try database.initialize()\n        let firstVersion = try database.getSchemaVersion()\n        database.close()\n\n        // Create new database instance pointing to same file\n        let dbPath = (testDir as NSString).appendingPathComponent(\"mail.db\")\n        let database2 = MailDatabase(databasePath: dbPath)\n\n        // Run migrations again - should be safe\n        try database2.initialize()\n        let secondVersion = try database2.getSchemaVersion()\n        database2.close()\n\n        XCTAssertEqual(firstVersion, secondVersion,\n                       \"Schema version should be the same after re-running migrations\")\n        XCTAssertEqual(secondVersion, MailDatabase.currentSchemaVersion,\n                       \"Schema version should be at latest after initialization\")\n    }\n\n    func testMigrationHandlesEmptyDatabase() throws {\n        // Start with no database file\n        let dbPath = (testDir as NSString).appendingPathComponent(\"fresh.db\")\n        let freshDatabase = MailDatabase(databasePath: dbPath)\n\n        // Initialize should create all tables\n        try freshDatabase.initialize()\n\n        // Verify all migrations were applied\n        let version = try freshDatabase.getSchemaVersion()\n        XCTAssertEqual(version, MailDatabase.currentSchemaVersion,\n                       \"Fresh database should be at latest schema version\")\n\n        // Verify core tables exist\n        XCTAssertTrue(try freshDatabase.tableExists(\"messages\"))\n        XCTAssertTrue(try freshDatabase.tableExists(\"threads\"))\n        XCTAssertTrue(try freshDatabase.tableExists(\"thread_messages\"))\n\n        freshDatabase.close()\n    }\n\n    func testMigrationDescriptionsExistForAllVersions() {\n        // Verify all migrations have descriptions\n        for version in 1...MailDatabase.currentSchemaVersion {\n            XCTAssertNotNil(MailDatabase.migrationDescriptions[version],\n                           \"Migration V\\(version) should have a description\")\n            XCTAssertFalse(MailDatabase.migrationDescriptions[version]!.isEmpty,\n                          \"Migration V\\(version) description should not be empty\")\n        }\n    }\n\n    func testMigrationPreservesExistingData() throws {\n        try database.initialize()\n\n        // Insert test data\n        let message = MailMessage(\n            id: \"migration-test-msg\",\n            appleRowId: 54321,\n            messageId: \"<migration-test@example.com>\",\n            mailboxId: 1,\n            mailboxName: \"INBOX\",\n            subject: \"Migration Test Message\",\n            senderName: \"Test Sender\",\n            senderEmail: \"test@example.com\"\n        )\n        try database.upsertMessage(message)\n\n        let thread = Thread(\n            id: \"migration-test-thread\",\n            subject: \"Migration Test Thread\",\n            participantCount: 2,\n            messageCount: 1\n        )\n        try database.upsertThread(thread)\n\n        // Close and reopen database (triggers migration check)\n        database.close()\n\n        let dbPath = (testDir as NSString).appendingPathComponent(\"mail.db\")\n        let database2 = MailDatabase(databasePath: dbPath)\n        try database2.initialize()\n\n        // Verify data is preserved\n        let retrievedMessage = try database2.getMessage(id: \"migration-test-msg\")\n        XCTAssertNotNil(retrievedMessage, \"Message should be preserved after migration\")\n        XCTAssertEqual(retrievedMessage?.subject, \"Migration Test Message\")\n\n        let retrievedThread = try database2.getThread(id: \"migration-test-thread\")\n        XCTAssertNotNil(retrievedThread, \"Thread should be preserved after migration\")\n        XCTAssertEqual(retrievedThread?.subject, \"Migration Test Thread\")\n\n        database2.close()\n    }\n}\n","structuredPatch":[{"oldStart":295,"oldLines":6,"newStart":295,"newLines":52,"lines":["         XCTAssertNoThrow(try database.searchMessages(query: \"foo:bar baz:qux\"), \"Search should not crash for multiple unknown filters\")","     }"," ","+    func testParseQueryDetectsUnknownFilters() throws {","+        try database.initialize()","+","+        // Single unknown filter","+        let filter1 = database.parseQuery(\"badfilter:test\")","+        XCTAssertTrue(filter1.hasUnknownFilters)","+        XCTAssertEqual(filter1.unknownFilters, [\"badfilter\"])","+","+        // Multiple unknown filters","+        let filter2 = database.parseQuery(\"foo:bar baz:qux\")","+        XCTAssertTrue(filter2.hasUnknownFilters)","+        XCTAssertEqual(filter2.unknownFilters, [\"foo\", \"baz\"])","+","+        // Unknown filter mixed with valid filter","+        let filter3 = database.parseQuery(\"from:alice@example.com badfilter:test\")","+        XCTAssertTrue(filter3.hasUnknownFilters)","+        XCTAssertEqual(filter3.unknownFilters, [\"badfilter\"])","+        XCTAssertEqual(filter3.from, \"alice@example.com\")","+","+        // Valid filters only - no unknown filters","+        let filter4 = database.parseQuery(\"from:alice to:bob subject:hello\")","+        XCTAssertFalse(filter4.hasUnknownFilters)","+        XCTAssertEqual(filter4.unknownFilters, [])","+","+        // Plain text search without filter syntax - no unknown filters","+        let filter5 = database.parseQuery(\"hello world\")","+        XCTAssertFalse(filter5.hasUnknownFilters)","+        XCTAssertEqual(filter5.unknownFilters, [])","+","+        // is: and has: filters are valid","+        let filter6 = database.parseQuery(\"is:read has:attachments\")","+        XCTAssertFalse(filter6.hasUnknownFilters)","+        XCTAssertEqual(filter6.isRead, true)","+        XCTAssertEqual(filter6.hasAttachments, true)","+","+        // Date filters are valid","+        let filter7 = database.parseQuery(\"after:2024-01-01 before:2024-12-31 date:2024-06-15\")","+        XCTAssertFalse(filter7.hasUnknownFilters)","+    }","+","+    func testValidFilterNamesConstant() throws {","+        // Verify the list of valid filter names includes all expected filters","+        let expected = [\"from\", \"to\", \"subject\", \"mailbox\", \"is\", \"has\", \"after\", \"before\", \"date\"]","+        XCTAssertEqual(MailDatabase.SearchFilter.validFilterNames.sorted(), expected.sorted())","+    }","+","     func testSearchWithMixedSpecialCharacters() throws {","         try database.initialize()"," "]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01UZL9XB8FTCQLpKqnxzEKBq","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DU4g6DWQu2WdxJ1zM4wWcY","name":"TodoWrite","input":{"todos":[{"content":"Find and analyze the mail search code","status":"completed","activeForm":"Finding and analyzing the mail search code"},{"content":"Add test for unknown filter names to verify current behavior","status":"completed","activeForm":"Adding test for unknown filter names"},{"content":"Implement validation of filter names in parseQuery","status":"completed","activeForm":"Implementing validation of filter names in parseQuery"},{"content":"Add user-friendly error message with valid filter list","status":"completed","activeForm":"Adding user-friendly error message with valid filter list"},{"content":"Run swift build and swift test","status":"in_progress","activeForm":"Running swift build and swift test"},{"content":"Commit and close the bead","status":"pending","activeForm":"Committing and closing the bead"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2464,"cache_read_input_tokens":62161,"cache_creation":{"ephemeral_5m_input_tokens":2464,"ephemeral_1h_input_tokens":0},"output_tokens":26,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"945444b4-6e7a-4632-bfaa-ba5e446516be"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DU4g6DWQu2WdxJ1zM4wWcY","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"4b9080e2-08a5-4858-8f7b-f6e2bbc40faa","tool_use_result":{"oldTodos":[{"content":"Find and analyze the mail search code","status":"completed","activeForm":"Finding and analyzing the mail search code"},{"content":"Add test for unknown filter names to verify current behavior","status":"completed","activeForm":"Adding test for unknown filter names"},{"content":"Implement validation of filter names in parseQuery","status":"completed","activeForm":"Implementing validation of filter names in parseQuery"},{"content":"Add user-friendly error message with valid filter list","status":"in_progress","activeForm":"Adding user-friendly error message with valid filter list"},{"content":"Run swift build and swift test","status":"pending","activeForm":"Running swift build and swift test"},{"content":"Commit and close the bead","status":"pending","activeForm":"Committing and closing the bead"}],"newTodos":[{"content":"Find and analyze the mail search code","status":"completed","activeForm":"Finding and analyzing the mail search code"},{"content":"Add test for unknown filter names to verify current behavior","status":"completed","activeForm":"Adding test for unknown filter names"},{"content":"Implement validation of filter names in parseQuery","status":"completed","activeForm":"Implementing validation of filter names in parseQuery"},{"content":"Add user-friendly error message with valid filter list","status":"completed","activeForm":"Adding user-friendly error message with valid filter list"},{"content":"Run swift build and swift test","status":"in_progress","activeForm":"Running swift build and swift test"},{"content":"Commit and close the bead","status":"pending","activeForm":"Committing and closing the bead"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Pw7Awg4XJWAGNdFszuQXim","type":"message","role":"assistant","content":[{"type":"text","text":"Now let's build and run tests:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":299,"cache_read_input_tokens":64625,"cache_creation":{"ephemeral_5m_input_tokens":299,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"ce023cc9-99f8-455c-8dc4-451bf00e352e"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Pw7Awg4XJWAGNdFszuQXim","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YTqzVynYQU1CEc5DUwcZUq","name":"Bash","input":{"command":"cd /Users/I852000/Library/Mobile\\ Documents/com~apple~CloudDocs/swiftea && swift build 2>&1","description":"Build the project","timeout":300000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":299,"cache_read_input_tokens":64625,"cache_creation":{"ephemeral_5m_input_tokens":299,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"3580034b-1d37-4d38-b79c-b9a998958a8f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YTqzVynYQU1CEc5DUwcZUq","type":"tool_result","content":"warning: 'swiftea': found 1 file(s) which are unhandled; explicitly declare them as resources or exclude from the target\n    /Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/CalendarModule/README.md\n[0/1] Planning build\n[1/1] Compiling plugin GenerateManual\n[2/2] Compiling plugin GenerateDoccReference\nBuilding for debugging...\n[2/7] Write sources\n[4/7] Write swift-version--58304C5D6DBC2206.txt\n[6/9] Emitting module SwiftEAKit\n[7/9] Compiling SwiftEAKit MailDatabase.swift\n[8/11] Compiling SwiftEACLI MailCommand.swift\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEACLI/Commands/MailCommand.swift:920:13: warning: capture of 'self' with non-Sendable type 'MailSyncDaemonController?' in a '@Sendable' closure [#SendableClosureCaptures]\n 824 | /// Controls the mail sync daemon with sleep/wake detection.\n 825 | /// Uses NSWorkspace notifications to detect system wake and trigger incremental sync.\n 826 | final class MailSyncDaemonController: NSObject {\n     |             `- note: class 'MailSyncDaemonController' does not conform to the 'Sendable' protocol\n 827 |     private let mailDatabase: MailDatabase\n 828 |     private let exportDir: String\n     :\n 918 |         // Schedule new timer on the main run loop\n 919 |         syncTimer = Timer.scheduledTimer(withTimeInterval: syncIntervalSeconds, repeats: true) { [weak self] _ in\n 920 |             self?.triggerSync(reason: \"scheduled\")\n     |             `- warning: capture of 'self' with non-Sendable type 'MailSyncDaemonController?' in a '@Sendable' closure [#SendableClosureCaptures]\n 921 |         }\n 922 | \n\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEACLI/Commands/MailCommand.swift:941:30: warning: capture of 'self' with non-Sendable type 'MailSyncDaemonController?' in a '@Sendable' closure [#SendableClosureCaptures]\n 824 | /// Controls the mail sync daemon with sleep/wake detection.\n 825 | /// Uses NSWorkspace notifications to detect system wake and trigger incremental sync.\n 826 | final class MailSyncDaemonController: NSObject {\n     |             `- note: class 'MailSyncDaemonController' does not conform to the 'Sendable' protocol\n 827 |     private let mailDatabase: MailDatabase\n 828 |     private let exportDir: String\n     :\n 939 |         // Don't spawn duplicate syncs\n 940 |         syncQueue.async { [weak self] in\n 941 |             guard let self = self else { return }\n     |                              `- warning: capture of 'self' with non-Sendable type 'MailSyncDaemonController?' in a '@Sendable' closure [#SendableClosureCaptures]\n 942 | \n 943 |             if self.isSyncing {\n\n[#SendableClosureCaptures]: <https://docs.swift.org/compiler/documentation/diagnostics/sendable-closure-captures>\n[9/11] Emitting module SwiftEACLI\n[10/12] Emitting module SwiftEA\n[10/13] Write Objects.LinkFileList\n[11/13] Linking swea\n[12/13] Applying swea\nBuild complete! (5.62s)","is_error":false}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"e4ab5e06-a761-441c-8bbc-c2ea0d62ba71","tool_use_result":{"stdout":"warning: 'swiftea': found 1 file(s) which are unhandled; explicitly declare them as resources or exclude from the target\n    /Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEAKit/Modules/CalendarModule/README.md\n[0/1] Planning build\n[1/1] Compiling plugin GenerateManual\n[2/2] Compiling plugin GenerateDoccReference\nBuilding for debugging...\n[2/7] Write sources\n[4/7] Write swift-version--58304C5D6DBC2206.txt\n[6/9] Emitting module SwiftEAKit\n[7/9] Compiling SwiftEAKit MailDatabase.swift\n[8/11] Compiling SwiftEACLI MailCommand.swift\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEACLI/Commands/MailCommand.swift:920:13: warning: capture of 'self' with non-Sendable type 'MailSyncDaemonController?' in a '@Sendable' closure [#SendableClosureCaptures]\n 824 | /// Controls the mail sync daemon with sleep/wake detection.\n 825 | /// Uses NSWorkspace notifications to detect system wake and trigger incremental sync.\n 826 | final class MailSyncDaemonController: NSObject {\n     |             `- note: class 'MailSyncDaemonController' does not conform to the 'Sendable' protocol\n 827 |     private let mailDatabase: MailDatabase\n 828 |     private let exportDir: String\n     :\n 918 |         // Schedule new timer on the main run loop\n 919 |         syncTimer = Timer.scheduledTimer(withTimeInterval: syncIntervalSeconds, repeats: true) { [weak self] _ in\n 920 |             self?.triggerSync(reason: \"scheduled\")\n     |             `- warning: capture of 'self' with non-Sendable type 'MailSyncDaemonController?' in a '@Sendable' closure [#SendableClosureCaptures]\n 921 |         }\n 922 | \n\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Sources/SwiftEACLI/Commands/MailCommand.swift:941:30: warning: capture of 'self' with non-Sendable type 'MailSyncDaemonController?' in a '@Sendable' closure [#SendableClosureCaptures]\n 824 | /// Controls the mail sync daemon with sleep/wake detection.\n 825 | /// Uses NSWorkspace notifications to detect system wake and trigger incremental sync.\n 826 | final class MailSyncDaemonController: NSObject {\n     |             `- note: class 'MailSyncDaemonController' does not conform to the 'Sendable' protocol\n 827 |     private let mailDatabase: MailDatabase\n 828 |     private let exportDir: String\n     :\n 939 |         // Don't spawn duplicate syncs\n 940 |         syncQueue.async { [weak self] in\n 941 |             guard let self = self else { return }\n     |                              `- warning: capture of 'self' with non-Sendable type 'MailSyncDaemonController?' in a '@Sendable' closure [#SendableClosureCaptures]\n 942 | \n 943 |             if self.isSyncing {\n\n[#SendableClosureCaptures]: <https://docs.swift.org/compiler/documentation/diagnostics/sendable-closure-captures>\n[9/11] Emitting module SwiftEACLI\n[10/12] Emitting module SwiftEA\n[10/13] Write Objects.LinkFileList\n[11/13] Linking swea\n[12/13] Applying swea\nBuild complete! (5.62s)","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_014HVwFCxNuUghmdqyHxGAUA","type":"message","role":"assistant","content":[{"type":"text","text":"Build succeeded. Now let's run the tests:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1106,"cache_read_input_tokens":64924,"cache_creation":{"ephemeral_5m_input_tokens":1106,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"23ebbb64-54b4-4be3-9a16-cb8744c61afc"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_014HVwFCxNuUghmdqyHxGAUA","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019XSGQc2MZFqZRMq2bD9JFz","name":"Bash","input":{"command":"cd /Users/I852000/Library/Mobile\\ Documents/com~apple~CloudDocs/swiftea && swift test --filter \"MailDatabaseTests\" 2>&1 | tail -50","description":"Run MailDatabaseTests","timeout":300000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1106,"cache_read_input_tokens":64924,"cache_creation":{"ephemeral_5m_input_tokens":1106,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"8a91f903-6125-4435-b089-b115d12cb10e"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019XSGQc2MZFqZRMq2bD9JFz","type":"tool_result","content":"Test Case '-[SwiftEAKitTests.MailDatabaseTests testThreadMessageJunctionMethodsBeforeInitializeThrow]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testThreadMessageJunctionMethodsBeforeInitializeThrow]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testThreadMessagesIndexesExist]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testThreadMessagesIndexesExist]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testThreadQueryWithPaginationBoundsMemory]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testThreadQueryWithPaginationBoundsMemory]' passed (0.024 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testThreadsTableHasPrimaryKeyIndex]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testThreadsTableHasPrimaryKeyIndex]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateExportPath]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateExportPath]' passed (0.012 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMailbox]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMailbox]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMailboxStatus]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMailboxStatus]' passed (0.012 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMailboxStatusNonexistentMessage]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMailboxStatusNonexistentMessage]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMessageBodyBeforeInitializeThrows]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMessageBodyBeforeInitializeThrows]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMessageBodyHtmlOnly]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMessageBodyHtmlOnly]' passed (0.015 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMessageBodyOverwritesExistingBody]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMessageBodyOverwritesExistingBody]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMessageBodyTextOnly]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMessageBodyTextOnly]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMessageBodyWithBothTextAndHtml]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMessageBodyWithBothTextAndHtml]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMessageBodyWithSpecialCharacters]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMessageBodyWithSpecialCharacters]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateSyncStatus]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateSyncStatus]' passed (0.013 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpsertAndGetMailboxes]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpsertAndGetMailboxes]' passed (0.008 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpsertAndGetMessage]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpsertAndGetMessage]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpsertUpdatesExistingMessage]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpsertUpdatesExistingMessage]' passed (0.012 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testValidFilterNamesConstant]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testValidFilterNamesConstant]' passed (0.001 seconds).\nTest Suite 'MailDatabaseTests' passed at 2026-01-15 19:18:59.374.\n\t Executed 132 tests, with 0 failures (0 unexpected) in 1.182 (1.190) seconds\nTest Suite 'SwiftEAPackageTests.xctest' passed at 2026-01-15 19:18:59.374.\n\t Executed 132 tests, with 0 failures (0 unexpected) in 1.182 (1.190) seconds\nTest Suite 'Selected tests' passed at 2026-01-15 19:18:59.374.\n\t Executed 132 tests, with 0 failures (0 unexpected) in 1.182 (1.191) seconds\nBatch insert of 1000 messages took 0.05322897434234619 seconds\nRate: 18786.760638452735 messages/second\nâ—‡ Test run started.\nâ†³ Testing Library Version: 1501\nâ†³ Target Platform: arm64e-apple-macos14.0\nâœ” Test run with 0 tests in 0 suites passed after 0.001 seconds.","is_error":false}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"4052cb6e-0e79-464d-ac65-089775ab8549","tool_use_result":{"stdout":"Test Case '-[SwiftEAKitTests.MailDatabaseTests testThreadMessageJunctionMethodsBeforeInitializeThrow]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testThreadMessageJunctionMethodsBeforeInitializeThrow]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testThreadMessagesIndexesExist]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testThreadMessagesIndexesExist]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testThreadQueryWithPaginationBoundsMemory]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testThreadQueryWithPaginationBoundsMemory]' passed (0.024 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testThreadsTableHasPrimaryKeyIndex]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testThreadsTableHasPrimaryKeyIndex]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateExportPath]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateExportPath]' passed (0.012 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMailbox]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMailbox]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMailboxStatus]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMailboxStatus]' passed (0.012 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMailboxStatusNonexistentMessage]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMailboxStatusNonexistentMessage]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMessageBodyBeforeInitializeThrows]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMessageBodyBeforeInitializeThrows]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMessageBodyHtmlOnly]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMessageBodyHtmlOnly]' passed (0.015 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMessageBodyOverwritesExistingBody]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMessageBodyOverwritesExistingBody]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMessageBodyTextOnly]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMessageBodyTextOnly]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMessageBodyWithBothTextAndHtml]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMessageBodyWithBothTextAndHtml]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMessageBodyWithSpecialCharacters]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMessageBodyWithSpecialCharacters]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateSyncStatus]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateSyncStatus]' passed (0.013 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpsertAndGetMailboxes]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpsertAndGetMailboxes]' passed (0.008 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpsertAndGetMessage]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpsertAndGetMessage]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpsertUpdatesExistingMessage]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpsertUpdatesExistingMessage]' passed (0.012 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testValidFilterNamesConstant]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testValidFilterNamesConstant]' passed (0.001 seconds).\nTest Suite 'MailDatabaseTests' passed at 2026-01-15 19:18:59.374.\n\t Executed 132 tests, with 0 failures (0 unexpected) in 1.182 (1.190) seconds\nTest Suite 'SwiftEAPackageTests.xctest' passed at 2026-01-15 19:18:59.374.\n\t Executed 132 tests, with 0 failures (0 unexpected) in 1.182 (1.190) seconds\nTest Suite 'Selected tests' passed at 2026-01-15 19:18:59.374.\n\t Executed 132 tests, with 0 failures (0 unexpected) in 1.182 (1.191) seconds\nBatch insert of 1000 messages took 0.05322897434234619 seconds\nRate: 18786.760638452735 messages/second\nâ—‡ Test run started.\nâ†³ Testing Library Version: 1501\nâ†³ Target Platform: arm64e-apple-macos14.0\nâœ” Test run with 0 tests in 0 suites passed after 0.001 seconds.","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01YWazmeUxHiZQdmVMoqBPzL","type":"message","role":"assistant","content":[{"type":"text","text":"All MailDatabaseTests pass. Let me check that my specific new tests ran:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1713,"cache_read_input_tokens":66030,"cache_creation":{"ephemeral_5m_input_tokens":1713,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"3b54f665-aa9a-408a-a1df-dbba57135a4f"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01YWazmeUxHiZQdmVMoqBPzL","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0173XNnFWhUeWVfKBQZLqAcV","name":"Bash","input":{"command":"cd /Users/I852000/Library/Mobile\\ Documents/com~apple~CloudDocs/swiftea && swift test --filter \"testParseQueryDetectsUnknownFilters\" 2>&1","description":"Run specific unknown filter test","timeout":120000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1713,"cache_read_input_tokens":66030,"cache_creation":{"ephemeral_5m_input_tokens":1713,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"8ee7510d-0df8-49f5-9905-25ac61db85f7"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0173XNnFWhUeWVfKBQZLqAcV","type":"tool_result","content":"[1/1] Compiling plugin GenerateManual\n[2/2] Compiling plugin GenerateDoccReference\nBuilding for debugging...\n[2/6] Write swift-version--58304C5D6DBC2206.txt\nBuild complete! (0.13s)\nTest Suite 'Selected tests' started at 2026-01-15 19:19:05.117.\nTest Suite 'SwiftEAPackageTests.xctest' started at 2026-01-15 19:19:05.117.\nTest Suite 'MailDatabaseTests' started at 2026-01-15 19:19:05.117.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testParseQueryDetectsUnknownFilters]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testParseQueryDetectsUnknownFilters]' passed (0.013 seconds).\nTest Suite 'MailDatabaseTests' passed at 2026-01-15 19:19:05.130.\n\t Executed 1 test, with 0 failures (0 unexpected) in 0.013 (0.013) seconds\nTest Suite 'SwiftEAPackageTests.xctest' passed at 2026-01-15 19:19:05.130.\n\t Executed 1 test, with 0 failures (0 unexpected) in 0.013 (0.013) seconds\nTest Suite 'Selected tests' passed at 2026-01-15 19:19:05.130.\n\t Executed 1 test, with 0 failures (0 unexpected) in 0.013 (0.014) seconds\nâ—‡ Test run started.\nâ†³ Testing Library Version: 1501\nâ†³ Target Platform: arm64e-apple-macos14.0\nâœ” Test run with 0 tests in 0 suites passed after 0.001 seconds.","is_error":false}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"f4818906-8637-4402-8322-d50db1598bb0","tool_use_result":{"stdout":"[1/1] Compiling plugin GenerateManual\n[2/2] Compiling plugin GenerateDoccReference\nBuilding for debugging...\n[2/6] Write swift-version--58304C5D6DBC2206.txt\nBuild complete! (0.13s)\nTest Suite 'Selected tests' started at 2026-01-15 19:19:05.117.\nTest Suite 'SwiftEAPackageTests.xctest' started at 2026-01-15 19:19:05.117.\nTest Suite 'MailDatabaseTests' started at 2026-01-15 19:19:05.117.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testParseQueryDetectsUnknownFilters]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testParseQueryDetectsUnknownFilters]' passed (0.013 seconds).\nTest Suite 'MailDatabaseTests' passed at 2026-01-15 19:19:05.130.\n\t Executed 1 test, with 0 failures (0 unexpected) in 0.013 (0.013) seconds\nTest Suite 'SwiftEAPackageTests.xctest' passed at 2026-01-15 19:19:05.130.\n\t Executed 1 test, with 0 failures (0 unexpected) in 0.013 (0.013) seconds\nTest Suite 'Selected tests' passed at 2026-01-15 19:19:05.130.\n\t Executed 1 test, with 0 failures (0 unexpected) in 0.013 (0.014) seconds\nâ—‡ Test run started.\nâ†³ Testing Library Version: 1501\nâ†³ Target Platform: arm64e-apple-macos14.0\nâœ” Test run with 0 tests in 0 suites passed after 0.001 seconds.","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01AJXbwpXUoN7KACKkgqb8U2","type":"message","role":"assistant","content":[{"type":"text","text":"Now let's run all tests to make sure nothing is broken:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":644,"cache_read_input_tokens":67743,"cache_creation":{"ephemeral_5m_input_tokens":644,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"2f8f91bf-2980-4527-b799-7d74441130e1"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01AJXbwpXUoN7KACKkgqb8U2","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Uk7ddZunqrh6gw2EvHumWT","name":"Bash","input":{"command":"cd /Users/I852000/Library/Mobile\\ Documents/com~apple~CloudDocs/swiftea && swift test 2>&1 | tail -30","description":"Run all tests","timeout":600000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":644,"cache_read_input_tokens":67743,"cache_creation":{"ephemeral_5m_input_tokens":644,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"7d68fa5d-6e5a-4e20-bc65-b1efbfbf1bb0"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Uk7ddZunqrh6gw2EvHumWT","type":"tool_result","content":"  Thread count: 84367\n  Average thread size: 11.85\n  Largest thread: 500 messages\n  Unique participants: 1000\n  Generation time: 3173.82ms\nDatabase insert: 5050 messages/second\nPage at offset 0: 2.27ms (100 threads)\nPage at offset 500: 1.23ms (100 threads)\nPage at offset 1000: 1.28ms (100 threads)\nPage at offset 1500: 1.48ms (100 threads)\nThread detection: 1050 messages/second\nThread listing (10k threads, 100 limit): 0.29ms average\n\n=== Performance Validation Suite ===\n\nDataset: 5150 messages, 1210 threads\nGeneration time: 17.24ms\n\n1. Database insert: 4349 msg/sec (target: >3000)\n2. Thread detection: 1627 msg/sec (target: >200)\n3. Thread listing: 0.27ms (target: <100ms)\n4. Thread count: 0.02ms (target: <50ms)\n5. Pagination avg: 0.15ms (target: <100ms)\n\n=== Validation Complete ===\n\nâ—‡ Test run started.\nâ†³ Testing Library Version: 1501\nâ†³ Target Platform: arm64e-apple-macos14.0\nâœ” Test run with 0 tests in 0 suites passed after 0.001 seconds.","is_error":false}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"21f1fc69-a21c-49a4-93e0-c68727d95c04","tool_use_result":{"stdout":"  Thread count: 84367\n  Average thread size: 11.85\n  Largest thread: 500 messages\n  Unique participants: 1000\n  Generation time: 3173.82ms\nDatabase insert: 5050 messages/second\nPage at offset 0: 2.27ms (100 threads)\nPage at offset 500: 1.23ms (100 threads)\nPage at offset 1000: 1.28ms (100 threads)\nPage at offset 1500: 1.48ms (100 threads)\nThread detection: 1050 messages/second\nThread listing (10k threads, 100 limit): 0.29ms average\n\n=== Performance Validation Suite ===\n\nDataset: 5150 messages, 1210 threads\nGeneration time: 17.24ms\n\n1. Database insert: 4349 msg/sec (target: >3000)\n2. Thread detection: 1627 msg/sec (target: >200)\n3. Thread listing: 0.27ms (target: <100ms)\n4. Thread count: 0.02ms (target: <50ms)\n5. Pagination avg: 0.15ms (target: <100ms)\n\n=== Validation Complete ===\n\nâ—‡ Test run started.\nâ†³ Testing Library Version: 1501\nâ†³ Target Platform: arm64e-apple-macos14.0\nâœ” Test run with 0 tests in 0 suites passed after 0.001 seconds.","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_015YQV6GjAUtrhyakPPHoP7W","type":"message","role":"assistant","content":[{"type":"text","text":"Let me see the full summary:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":505,"cache_read_input_tokens":68387,"cache_creation":{"ephemeral_5m_input_tokens":505,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"89af71c6-98b2-40c9-86b3-d52ae6c2cebf"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_015YQV6GjAUtrhyakPPHoP7W","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015xSt92MdvsV6v6MwU6yirN","name":"Bash","input":{"command":"cd /Users/I852000/Library/Mobile\\ Documents/com~apple~CloudDocs/swiftea && swift test 2>&1 | grep -E \"(passed|failed|executed|Test Suite)\"","description":"Run all tests and get summary","timeout":600000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":505,"cache_read_input_tokens":68387,"cache_creation":{"ephemeral_5m_input_tokens":505,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"089a0fdb-414e-4cef-831f-e9b33b7c79ca"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015xSt92MdvsV6v6MwU6yirN","type":"tool_result","content":"<persisted-output>\nOutput too large (83.4KB). Full output saved to: /Users/I852000/.claude/projects/-Users-I852000-Library-Mobile-Documents-com-apple-CloudDocs-swiftea/5a947bfe-0fe0-45e8-8f0b-a1aaf572731b/tool-results/toolu_015xSt92MdvsV6v6MwU6yirN.txt\n\nPreview (first 2KB):\nTest Suite 'All tests' started at 2026-01-15 19:21:33.992.\nTest Suite 'SwiftEAPackageTests.xctest' started at 2026-01-15 19:21:33.994.\nTest Suite 'AppleScriptServiceTests' started at 2026-01-15 19:21:33.994.\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testAllActionMethodsUseTheMessageVariable]' passed (0.002 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testAmbiguousMatchErrorMapping]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testAppleScriptResultSuccess]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testAppleScriptResultSuccessNoOutput]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testAutomationPermissionDeniedErrorDescription]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testAutomationPermissionDeniedHasRecoveryGuidance]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testAutomationPermissionErrorMapping]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testComposeScript]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testComposeScriptMultipleRecipients]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testComposeScriptReturnsMode]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testComposeScriptVariations]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testComposeScriptWithSend]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testCreateReplyAllScript]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testCreateReplyScript]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testCreateReplyScriptVariations]' passed (0.000 seconds).\n...\n</persisted-output>","is_error":false}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"7ca0cbc4-a920-497d-9252-ac5081df0a8b","tool_use_result":{"stdout":"Test Suite 'All tests' started at 2026-01-15 19:21:33.992.\nTest Suite 'SwiftEAPackageTests.xctest' started at 2026-01-15 19:21:33.994.\nTest Suite 'AppleScriptServiceTests' started at 2026-01-15 19:21:33.994.\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testAllActionMethodsUseTheMessageVariable]' passed (0.002 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testAmbiguousMatchErrorMapping]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testAppleScriptResultSuccess]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testAppleScriptResultSuccessNoOutput]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testAutomationPermissionDeniedErrorDescription]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testAutomationPermissionDeniedHasRecoveryGuidance]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testAutomationPermissionErrorMapping]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testComposeScript]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testComposeScriptMultipleRecipients]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testComposeScriptReturnsMode]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testComposeScriptVariations]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testComposeScriptWithSend]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testCreateReplyAllScript]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testCreateReplyScript]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testCreateReplyScriptVariations]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testDefaultMailLaunchTimeoutIsReasonable]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testDefaultMailPollIntervalIsReasonable]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testDeleteMessageScript]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testDeleteMessageScriptContainsRequiredComponents]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testDeleteScriptReturnsDeleted]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testEnsureMailRunningAcceptsCustomTimeout]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testExecuteInvalidScriptThrows]' passed (0.052 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testExecuteScriptWithStringOutput]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testExecuteSimpleScript]' passed (0.002 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testExecutionFailedErrorDescription]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testExecutionFailedHasNoRecoveryGuidance]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testFlagScriptReturnsFlagged]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testMailAppNotRespondingErrorDescription]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testMailAppNotRespondingErrorMapping]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testMailAppNotRespondingHasRecoveryGuidance]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testMailboxNotFoundErrorDescription]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testMailboxNotFoundErrorMapping]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testMailboxNotFoundHasRecoveryGuidance]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testMailLaunchTimeoutErrorDescription]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testMailLaunchTimeoutHasRecoveryGuidance]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testMessageNotFoundErrorDescription]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testMessageNotFoundErrorMapping]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testMessageNotFoundHasRecoveryGuidance]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testMessageResolutionAmbiguousErrorDescription]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testMessageResolutionAmbiguousHasRecoveryGuidance]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testMessageResolutionHelperGeneratesCorrectScript]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testMoveMessageScript]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testMoveMessageScriptContainsRequiredComponents]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testMoveMessageScriptWithAccount]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testMoveScriptReturnsMoved]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testReadStatusScriptReturnsStatus]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testReplyScriptReturnsMode]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testScriptCompilationFailedErrorDescription]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testScriptEscapesBackslashes]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testScriptEscapesNewlines]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testScriptEscapesQuotes]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testScriptHandlesEmptyStrings]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testScriptHandlesLongBody]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testScriptHandlesUnicodeCharacters]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testServiceCanBeInstantiated]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testSetFlagScript]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testSetFlagScriptContainsRequiredComponents]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testSetReadStatusScript]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testSetReadStatusScriptContainsRequiredComponents]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.AppleScriptServiceTests testSharedInstance]' passed (0.000 seconds).\nTest Suite 'AppleScriptServiceTests' passed at 2026-01-15 19:21:34.060.\nTest Suite 'BindingRegistryTests' started at 2026-01-15 19:21:34.060.\nTest Case '-[SwiftEAKitTests.BindingRegistryTests testBindAccountCreatesRegistry]' passed (0.002 seconds).\nTest Case '-[SwiftEAKitTests.BindingRegistryTests testBindAccountFailsIfBoundToOtherVault]' passed (0.002 seconds).\nTest Case '-[SwiftEAKitTests.BindingRegistryTests testBindAccountStoresBinding]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.BindingRegistryTests testBindAccountSucceedsIfRebindingToSameVault]' passed (0.002 seconds).\nTest Case '-[SwiftEAKitTests.BindingRegistryTests testBindingsForVault]' passed (0.003 seconds).\nTest Case '-[SwiftEAKitTests.BindingRegistryTests testBindMultipleAccounts]' passed (0.002 seconds).\nTest Case '-[SwiftEAKitTests.BindingRegistryTests testEmptyRegistryReturnsEmptyBindings]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.BindingRegistryTests testIsAccountBoundReturnsFalseForUnbound]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.BindingRegistryTests testRegistryPersistsAcrossInstances]' passed (0.002 seconds).\nTest Case '-[SwiftEAKitTests.BindingRegistryTests testUnbindAccountRemovesBinding]' passed (0.002 seconds).\nTest Case '-[SwiftEAKitTests.BindingRegistryTests testUnbindNonexistentAccountDoesNotThrow]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.BindingRegistryTests testVaultPathForAccount]' passed (0.002 seconds).\nTest Suite 'BindingRegistryTests' passed at 2026-01-15 19:21:34.082.\nTest Suite 'CachedThreadDetectionServiceTests' started at 2026-01-15 19:21:34.082.\nTest Case '-[SwiftEAKitTests.CachedThreadDetectionServiceTests testCacheImprovesLookupPerformance]' passed (0.030 seconds).\nTest Case '-[SwiftEAKitTests.CachedThreadDetectionServiceTests testCustomCacheSizeInitialization]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.CachedThreadDetectionServiceTests testDefaultInitialization]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.CachedThreadDetectionServiceTests testDetectThreadIdForStandaloneMessage]' passed (0.002 seconds).\nTest Case '-[SwiftEAKitTests.CachedThreadDetectionServiceTests testDetectThreadIdFromMailMessage]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.CachedThreadDetectionServiceTests testDetectThreadIdFromParsedHeaders]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.CachedThreadDetectionServiceTests testGetThreadCachesMissAndHit]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.CachedThreadDetectionServiceTests testGetThreadReturnsNilForNonexistent]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.CachedThreadDetectionServiceTests testInvalidateAllThreads]' passed (0.012 seconds).\nTest Case '-[SwiftEAKitTests.CachedThreadDetectionServiceTests testInvalidateThread]' passed (0.013 seconds).\nTest Case '-[SwiftEAKitTests.CachedThreadDetectionServiceTests testIsForwarded]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.CachedThreadDetectionServiceTests testIsReply]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.CachedThreadDetectionServiceTests testNormalizeSubject]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.CachedThreadDetectionServiceTests testProcessMessageCreatesNewThread]' passed (0.012 seconds).\nTest Case '-[SwiftEAKitTests.CachedThreadDetectionServiceTests testProcessMessagesInBatch]' passed (0.013 seconds).\nTest Case '-[SwiftEAKitTests.CachedThreadDetectionServiceTests testProcessMessageUpdatesCache]' passed (0.012 seconds).\nTest Case '-[SwiftEAKitTests.CachedThreadDetectionServiceTests testResetCacheStatistics]' passed (0.014 seconds).\nTest Case '-[SwiftEAKitTests.CachedThreadDetectionServiceTests testUpdateThreadMetadataInvalidatesCache]' passed (0.012 seconds).\nTest Suite 'CachedThreadDetectionServiceTests' passed at 2026-01-15 19:21:34.229.\nTest Suite 'CalendarDatabaseTests' started at 2026-01-15 19:21:34.229.\nTest Case '-[SwiftEAKitTests.CalendarDatabaseTests testAllDayEvent]' passed (0.015 seconds).\nTest Case '-[SwiftEAKitTests.CalendarDatabaseTests testAttendeeCascadeDelete]' passed (0.018 seconds).\nTest Case '-[SwiftEAKitTests.CalendarDatabaseTests testAttendeeOperations]' passed (0.008 seconds).\nTest Case '-[SwiftEAKitTests.CalendarDatabaseTests testCalendarCount]' passed (0.007 seconds).\nTest Case '-[SwiftEAKitTests.CalendarDatabaseTests testCalendarUpsertUpdatesExisting]' passed (0.006 seconds).\nTest Case '-[SwiftEAKitTests.CalendarDatabaseTests testDeleteEvent]' passed (0.006 seconds).\nTest Case '-[SwiftEAKitTests.CalendarDatabaseTests testDeleteEventsNotInSet]' passed (0.008 seconds).\nTest Case '-[SwiftEAKitTests.CalendarDatabaseTests testEventCount]' passed (0.007 seconds).\nTest Case '-[SwiftEAKitTests.CalendarDatabaseTests testFTSSearch]' passed (0.007 seconds).\nTest Case '-[SwiftEAKitTests.CalendarDatabaseTests testFTSSearchDescription]' passed (0.007 seconds).\nTest Case '-[SwiftEAKitTests.CalendarDatabaseTests testGetAllCalendars]' passed (0.007 seconds).\nTest Case '-[SwiftEAKitTests.CalendarDatabaseTests testGetEventByEventKitId]' passed (0.007 seconds).\nTest Case '-[SwiftEAKitTests.CalendarDatabaseTests testGetEventsInDateRange]' passed (0.007 seconds).\nTest Case '-[SwiftEAKitTests.CalendarDatabaseTests testGetUpcomingEvents]' passed (0.007 seconds).\nTest Case '-[SwiftEAKitTests.CalendarDatabaseTests testInitializeCreatesDatabase]' passed (0.005 seconds).\nTest Case '-[SwiftEAKitTests.CalendarDatabaseTests testInitializeTwiceSucceeds]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.CalendarDatabaseTests testLastSyncTime]' passed (0.007 seconds).\nTest Case '-[SwiftEAKitTests.CalendarDatabaseTests testQueryWithoutInitialization]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.CalendarDatabaseTests testRecurringEventWithMaster]' passed (0.007 seconds).\nTest Case '-[SwiftEAKitTests.CalendarDatabaseTests testReplaceAttendees]' passed (0.008 seconds).\nTest Case '-[SwiftEAKitTests.CalendarDatabaseTests testSyncStatusOperations]' passed (0.006 seconds).\nTest Case '-[SwiftEAKitTests.CalendarDatabaseTests testSyncStatusUpdate]' passed (0.006 seconds).\nTest Case '-[SwiftEAKitTests.CalendarDatabaseTests testUpsertAndGetCalendar]' passed (0.006 seconds).\nTest Case '-[SwiftEAKitTests.CalendarDatabaseTests testUpsertAndGetEvent]' passed (0.007 seconds).\nTest Suite 'CalendarDatabaseTests' passed at 2026-01-15 19:21:34.412.\nTest Suite 'CalendarIdGeneratorTests' started at 2026-01-15 19:21:34.412.\nTest Case '-[SwiftEAKitTests.CalendarIdGeneratorTests testCalendarIdFallback]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.CalendarIdGeneratorTests testCalendarIdFallbackConsistency]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.CalendarIdGeneratorTests testCalendarIdWithIdentifier]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.CalendarIdGeneratorTests testContentMatchesCaseInsensitive]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.CalendarIdGeneratorTests testContentMatchesDifferentSummaries]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.CalendarIdGeneratorTests testContentMatchesExact]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.CalendarIdGeneratorTests testContentMatchesNilSummaries]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.CalendarIdGeneratorTests testContentMatchesOutsideTolerance]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.CalendarIdGeneratorTests testContentMatchesWithinTolerance]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.CalendarIdGeneratorTests testConveniencePublicIdGeneration]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.CalendarIdGeneratorTests testFallbackIdWithAllComponents]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.CalendarIdGeneratorTests testFallbackIdWithEmptySummary]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.CalendarIdGeneratorTests testFallbackIdWithNilSummary]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.CalendarIdGeneratorTests testIsExternalId]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.CalendarIdGeneratorTests testIsValidId]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.CalendarIdGeneratorTests testPublicIdConsistency]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.CalendarIdGeneratorTests testPublicIdDifferentStartTimes]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.CalendarIdGeneratorTests testPublicIdDifferentSummaries]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.CalendarIdGeneratorTests testPublicIdFallbackWhenNoExternalId]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.CalendarIdGeneratorTests testPublicIdWithExternalIdentifier]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.CalendarIdGeneratorTests testReconciliationBothIdsChanged]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.CalendarIdGeneratorTests testReconciliationEventKitIdChanged]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.CalendarIdGeneratorTests testReconciliationExternalIdChanged]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.CalendarIdGeneratorTests testReconciliationMatch]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.CalendarIdGeneratorTests testReconciliationNewEvent]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.CalendarIdGeneratorTests testReconciliationNotFound]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.CalendarIdGeneratorTests testRecurringInstanceIdConsistency]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.CalendarIdGeneratorTests testRecurringInstanceIdsDiffer]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.CalendarIdGeneratorTests testRecurringInstanceIdWithExternalId]' passed (0.000 seconds).\nTest Suite 'CalendarIdGeneratorTests' passed at 2026-01-15 19:21:34.416.\nTest Suite 'EmlxParserTests' started at 2026-01-15 19:21:34.416.\nTest Case '-[SwiftEAKitTests.EmlxParserTests testAttachmentInfoProperties]' passed (0.005 seconds).\nTest Case '-[SwiftEAKitTests.EmlxParserTests testEmailAddressDisplayString]' passed (0.004 seconds).\nTest Case '-[SwiftEAKitTests.EmlxParserTests testParseDateFormats]' passed (0.005 seconds).\nTest Case '-[SwiftEAKitTests.EmlxParserTests testParseEmailWithAttachment]' passed (0.004 seconds).\nTest Case '-[SwiftEAKitTests.EmlxParserTests testParseEmailWithEmptyBody]' passed (0.005 seconds).\nTest Case '-[SwiftEAKitTests.EmlxParserTests testParseEmailWithThreadingHeaders]' passed (0.005 seconds).\nTest Case '-[SwiftEAKitTests.EmlxParserTests testParseEncodedHeaders]' passed (0.005 seconds).\nTest Case '-[SwiftEAKitTests.EmlxParserTests testParseFromData]' passed (0.004 seconds).\nTest Case '-[SwiftEAKitTests.EmlxParserTests testParseHeaderContinuation]' passed (0.005 seconds).\nTest Case '-[SwiftEAKitTests.EmlxParserTests testParseHtmlEmail]' passed (0.004 seconds).\nTest Case '-[SwiftEAKitTests.EmlxParserTests testParseInvalidFormatThrows]' passed (0.004 seconds).\nTest Case '-[SwiftEAKitTests.EmlxParserTests testParseMultipartEmail]' passed (0.005 seconds).\nTest Case '-[SwiftEAKitTests.EmlxParserTests testParseNonexistentFileThrows]' passed (0.004 seconds).\nTest Case '-[SwiftEAKitTests.EmlxParserTests testParsesApplePlistWhenPresent]' passed (0.005 seconds).\nTest Case '-[SwiftEAKitTests.EmlxParserTests testParseSimplePlainTextEmail]' passed (0.004 seconds).\nTest Case '-[SwiftEAKitTests.EmlxParserTests testParseVariousAddressFormats]' passed (0.004 seconds).\nTest Suite 'EmlxParserTests' passed at 2026-01-15 19:21:34.489.\nTest Suite 'EnvelopeIndexDiscoveryTests' started at 2026-01-15 19:21:34.489.\nTest Case '-[SwiftEAKitTests.EnvelopeIndexDiscoveryTests testCheckPermissionsWithAccessibleDirectory]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.EnvelopeIndexDiscoveryTests testCustomPathWithTildeExpansion]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.EnvelopeIndexDiscoveryTests testDiscoverWithNonexistentCustomPathThrows]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.EnvelopeIndexDiscoveryTests testDiscoverWithValidCustomPath]' passed (0.002 seconds).\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/EnvelopeIndexDiscoveryTests.swift:81: error: -[SwiftEAKitTests.EnvelopeIndexDiscoveryTests testEmlxPathGeneration] : XCTAssertEqual failed: (\"nil\") is not equal to (\"Optional(\"/Users/test/Library/Mail/V10/Mailboxes/INBOX.mbox/Messages/12345.emlx\")\")\nTest Case '-[SwiftEAKitTests.EnvelopeIndexDiscoveryTests testEmlxPathGeneration]' failed (0.268 seconds).\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/EnvelopeIndexDiscoveryTests.swift:90: error: -[SwiftEAKitTests.EnvelopeIndexDiscoveryTests testEmlxPathWithDifferentMailbox] : XCTAssertEqual failed: (\"nil\") is not equal to (\"Optional(\"/Users/test/Library/Mail/V10/Mailboxes/Work/Projects.mbox/Messages/99999.emlx\")\")\nTest Case '-[SwiftEAKitTests.EnvelopeIndexDiscoveryTests testEmlxPathWithDifferentMailbox]' failed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.EnvelopeIndexDiscoveryTests testEnvelopeDiscoveryErrorDescriptions]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.EnvelopeIndexDiscoveryTests testEnvelopeIndexInfoInitialization]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.EnvelopeIndexDiscoveryTests testExtractsVersionFromDeeperPath]' passed (0.003 seconds).\nTest Case '-[SwiftEAKitTests.EnvelopeIndexDiscoveryTests testExtractsVersionFromPath]' passed (0.003 seconds).\nTest Case '-[SwiftEAKitTests.EnvelopeIndexDiscoveryTests testNoVersionInPathUsesDefault]' passed (0.002 seconds).\nTest Case '-[SwiftEAKitTests.EnvelopeIndexDiscoveryTests testVersionDirectoryWithMultipleDigits]' passed (0.003 seconds).\nTest Suite 'EnvelopeIndexDiscoveryTests' failed at 2026-01-15 19:21:34.776.\nTest Suite 'MailCommandTests' started at 2026-01-15 19:21:34.776.\nTest Case '-[SwiftEACLITests.MailCommandTests testMailSyncOptionsCustomParallel]' passed (0.000 seconds).\nTest Case '-[SwiftEACLITests.MailCommandTests testMailSyncOptionsDefaults]' passed (0.000 seconds).\nTest Suite 'MailCommandTests' passed at 2026-01-15 19:21:34.776.\nTest Suite 'MailCommandValidationTests' started at 2026-01-15 19:21:34.776.\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testComposeCommandEmptyToIsInvalid]' passed (0.004 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testComposeCommandValidToIsAccepted]' passed (0.002 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testComposeCommandWhitespaceOnlyToIsInvalid]' passed (0.002 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testExportCommandDefaultFormatIsValid]' passed (0.002 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testExportCommandFormatIsCaseSensitive]' passed (0.003 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testExportCommandInvalidFormatIsRejected]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testExportCommandJsonFormatIsValid]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testExportCommandLimitZeroIsInvalid]' passed (0.002 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testExportCommandMarkdownFormatIsValid]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testExportCommandMdFormatIsValid]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testExportCommandNegativeLimitIsInvalid]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testMailValidationErrorDescriptions]' passed (0.000 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testOutputFormatAllValueStrings]' passed (0.000 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testOutputFormatEnumValues]' passed (0.000 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testOutputFormatFileExtension]' passed (0.000 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testOutputFormatIsJson]' passed (0.000 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testOutputFormatIsMarkdown]' passed (0.000 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testSearchCommandDefaultLimitIsValid]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testSearchCommandLimitZeroIsInvalid]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testSearchCommandNegativeLimitIsInvalid]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testSearchCommandPositiveLimitIsValid]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testShowCommandCombinesFlagsCorrectly]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testShowCommandParsesHtmlFlag]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testShowCommandParsesJsonFlag]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testShowCommandParsesRawFlag]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testShowCommandParsesWithMessageId]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testSyncCommandNoFlagsIsValid]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testSyncCommandStopAloneIsValid]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testSyncCommandWatchAloneIsValid]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testSyncCommandWatchAndStopMutuallyExclusive]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadCommandCombinesAllOptions]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadCommandCombinesIdAndHtml]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadCommandDefaultFormatIsText]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadCommandDefaultsHtmlToFalse]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadCommandInvalidFormatIsRejected]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadCommandParsesFormatJson]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadCommandParsesFormatMarkdown]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadCommandParsesFormatMd]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadCommandParsesFormatText]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadCommandParsesHtmlFlag]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadCommandParsesId]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadCommandRequiresId]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadOutputFormatAllValueStrings]' passed (0.000 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadOutputFormatEnumValues]' passed (0.000 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadOutputFormatIsJson]' passed (0.000 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadOutputFormatIsMarkdown]' passed (0.000 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadOutputFormatIsText]' passed (0.000 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadsCommandCombinesAllOptions]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadsCommandCombinesShortOptions]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadsCommandDefaults]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadsCommandInvalidFormatIsRejected]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadsCommandInvalidSortOptionIsRejected]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadsCommandParsesFormatJsonOption]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadsCommandParsesFormatMarkdownOption]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadsCommandParsesFormatMdOption]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadsCommandParsesFormatTextOption]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadsCommandParsesLimitOption]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadsCommandParsesOffsetOption]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadsCommandParsesPartialParticipant]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadsCommandParsesParticipantOption]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadsCommandParsesShortLimitOption]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadsCommandParsesShortOffsetOption]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadsCommandParsesShortParticipantOption]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadsCommandParsesShortSortOption]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadsCommandParsesSortDateOption]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadsCommandParsesSortMessageCountOption]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadsCommandParsesSortSubjectOption]' passed (0.001 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadSortOptionAllValueStrings]' passed (0.000 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadSortOptionEnumValues]' passed (0.000 seconds).\nTest Case '-[SwiftEACLITests.MailCommandValidationTests testThreadSortOptionToDbSortOrder]' passed (0.000 seconds).\nTest Suite 'MailCommandValidationTests' passed at 2026-01-15 19:21:34.847.\nTest Suite 'MailDatabaseTests' started at 2026-01-15 19:21:34.847.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testAddMessageToThread]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testAddMessageToThreadDuplicateIgnored]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testBatchInsertResultInitialization]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testBatchThreadPositionUpdate]' passed (0.015 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testBatchUpsertMailboxes]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testBatchUpsertMailboxesUpdatesExisting]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testBatchUpsertMessagesConfigMinimumBatchSize]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testBatchUpsertMessagesDefaultConfig]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testBatchUpsertMessagesEmptyArray]' passed (0.012 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testBatchUpsertMessagesInsertsAll]' passed (0.017 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testBatchUpsertMessagesPerformance]' passed (0.071 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testBatchUpsertMessagesUpdatesExisting]' passed (0.020 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testBatchUpsertMessagesWithCustomBatchSize]' passed (0.037 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testBatchUpsertMessagesWithSpecialCharacters]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testBatchUpsertWithV2Fields]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testClearPendingSyncAction]' passed (0.014 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testClearPendingSyncActionNonexistentMessage]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testCloseAndReopenDatabase]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testEmptyThreadPositionUpdateDoesNothing]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testExistingMessagesGetDefaultMailboxStatus]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testExplainQueryPlanUsesThreadIdIndex]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testExplainQueryPlanUsesThreadMessagesIndex]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testGetLastSyncTimeWhenNotSet]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testGetMessageByAppleRowId]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testGetMessageCountByStatus]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testGetMessageCountByStatusEmpty]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testGetMessageCountByStatusExcludesSoftDeleted]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testGetMessageCountInThread]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testGetMessageCountInThreadNonexistent]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testGetMessageIdsInThread]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testGetMessageIdsInThreadEmpty]' passed (0.017 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testGetMessagesByStatus]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testGetMessagesByStatusEmpty]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testGetMessagesByStatusExcludesDeleted]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testGetMessagesByStatusWithLimitAndOffset]' passed (0.013 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testGetMessagesInThreadViaJunction]' passed (0.012 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testGetMessagesInThreadViaJunctionExcludesDeleted]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testGetMessagesInThreadViaJunctionWithLimitAndOffset]' passed (0.015 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testGetMessagesWithPendingActions]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testGetMessagesWithPendingActionsEmpty]' passed (0.018 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testGetMessagesWithPendingActionsExcludesDeleted]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testGetNonexistentMessageReturnsNil]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testGetNonexistentSyncStatus]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testGetSchemaVersionBeforeInitializationThrows]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testGetSchemaVersionReturnsCurrentVersion]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testGetSyncStatusSummaryWhenNoSync]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testGetTableColumnsForMessages]' passed (0.014 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testGetTableColumnsForThreadMessages]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testGetTableColumnsForThreads]' passed (0.008 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testGetThreadIdsForMessage]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testGetThreadIdsForMessageEmpty]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testGetThreadsForMessage]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testGetThreadsForMessageEmpty]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testIndexVerificationMethodsBeforeInitializeThrow]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testInitializeCreatesDatabase]' passed (0.013 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testInitializeTwiceSucceeds]' passed (0.012 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testIsMessageInThread]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testIsMessageInThreadNonexistent]' passed (0.015 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testMailAttachmentInitialization]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testMailboxInitialization]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testMailboxStatusEnumValues]' passed (0.002 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testMailboxStatusUpdateOnUpsert]' passed (0.015 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testMailDatabaseErrorDescriptions]' passed (0.005 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testMailMessageDefaults]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testMailMessageInitialization]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testMailMessageV2DefaultsInInit]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testManyToManyRelationship]' passed (0.018 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testMessageWithAllV2Fields]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testMessageWithSpecialCharactersInSubject]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testMessageWithSqlInjectionAttempt]' passed (0.012 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testMigrationDescriptionsExistForAllVersions]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testMigrationHandlesEmptyDatabase]' passed (0.013 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testMigrationHistoryContainsAllVersions]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testMigrationIsIdempotent]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testMigrationPreservesExistingData]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testMigrationV2CreatesLastKnownMailboxIdColumn]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testMigrationV2CreatesMailboxStatusColumn]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testMigrationV2CreatesPendingSyncActionColumn]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testMigrationV7IndexesExist]' passed (0.008 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testOperationsBeforeInitializeThrow]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testParseQueryDetectsUnknownFilters]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testRecordSyncFailure]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testRecordSyncStart]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testRecordSyncSuccess]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testRemoveMessageFromThread]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testRemoveNonexistentMessageFromThread]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testSearchMessages]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testSearchWithDoubleQuote]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testSearchWithEmptyQuery]' passed (0.008 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testSearchWithFts5Operators]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testSearchWithLimit]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testSearchWithMixedSpecialCharacters]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testSearchWithNoResults]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testSearchWithSingleQuote]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testSearchWithSpecialCharacters]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testSearchWithSqlInjectionAttempt]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testSearchWithUnknownFilterName]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testSetAndGetLastSyncTime]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testSetAndGetSyncStatus]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testSetPendingSyncAction]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testSetPendingSyncActionNonexistentMessage]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testSmallThreadPositionUpdateUsesIndividualQueries]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testStatusMethodsBeforeInitializeThrow]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testSyncActionEnumValues]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testSyncStatusClearsErrorOnSuccess]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testTableExistsForCoreThreadingTables]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testTableExistsReturnsFalseForNonExistentTable]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testThreadDetailViewUsesIndexes]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testThreadIdIndexExistsOnMessagesTable]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testThreadListingByMessageCountUsesIndex]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testThreadListingBySubjectUsesIndex]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testThreadListingUsesLastDateIndex]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testThreadMessageForeignKeyConstraintOnThreadDelete]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testThreadMessageJunctionMethodsBeforeInitializeThrow]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testThreadMessagesIndexesExist]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testThreadQueryWithPaginationBoundsMemory]' passed (0.020 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testThreadsTableHasPrimaryKeyIndex]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateExportPath]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMailbox]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMailboxStatus]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMailboxStatusNonexistentMessage]' passed (0.008 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMessageBodyBeforeInitializeThrows]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMessageBodyHtmlOnly]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMessageBodyOverwritesExistingBody]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMessageBodyTextOnly]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMessageBodyWithBothTextAndHtml]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateMessageBodyWithSpecialCharacters]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpdateSyncStatus]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpsertAndGetMailboxes]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpsertAndGetMessage]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testUpsertUpdatesExistingMessage]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testValidFilterNamesConstant]' passed (0.001 seconds).\nTest Suite 'MailDatabaseTests' passed at 2026-01-15 19:21:36.154.\nTest Suite 'MailExportTests' started at 2026-01-15 19:21:36.155.\nTest Case '-[SwiftEAKitTests.MailExportTests testExportResultTracksThreadsAndUnthreaded]' passed (0.017 seconds).\nTest Case '-[SwiftEAKitTests.MailExportTests testJsonExportHandlesNilValues]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailExportTests testJsonExportStructureContainsAllRequiredFields]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.MailExportTests testLargeThreadExport]' passed (0.024 seconds).\nTest Case '-[SwiftEAKitTests.MailExportTests testMarkdownExportContainsBody]' passed (0.015 seconds).\nTest Case '-[SwiftEAKitTests.MailExportTests testMarkdownExportFilenameIsIdBased]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailExportTests testMarkdownExportFromEmailOnly]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailExportTests testMarkdownExportFromUnknown]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.MailExportTests testMarkdownExportFrontmatterContainsRequiredFields]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.MailExportTests testMarkdownExportIncludesThreadId]' passed (0.014 seconds).\nTest Case '-[SwiftEAKitTests.MailExportTests testMarkdownExportIncludesThreadPosition]' passed (0.026 seconds).\nTest Case '-[SwiftEAKitTests.MailExportTests testMarkdownExportIncludesThreadSubject]' passed (0.041 seconds).\nTest Case '-[SwiftEAKitTests.MailExportTests testMarkdownExportMinimalFrontmatter]' passed (0.014 seconds).\nTest Case '-[SwiftEAKitTests.MailExportTests testMarkdownExportWithNoBody]' passed (0.012 seconds).\nTest Case '-[SwiftEAKitTests.MailExportTests testMarkdownExportWithoutThreadDoesNotIncludeThreadFields]' passed (0.015 seconds).\nTest Case '-[SwiftEAKitTests.MailExportTests testMarkdownExportWithSpecialCharactersInSubject]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailExportTests testSingleMessageThreadExport]' passed (0.016 seconds).\nTest Case '-[SwiftEAKitTests.MailExportTests testThreadExportProducesValidMarkdownOutput]' passed (0.016 seconds).\nTest Case '-[SwiftEAKitTests.MailExportTests testThreadExportWithEmptyBody]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.MailExportTests testThreadExportWithHtmlBodyFallback]' passed (0.013 seconds).\nTest Case '-[SwiftEAKitTests.MailExportTests testThreadWithNoSubjectExport]' passed (0.012 seconds).\nTest Suite 'MailExportTests' passed at 2026-01-15 19:21:36.474.\nTest Suite 'MailSyncBackwardTests' started at 2026-01-15 19:21:36.474.\nTest Case '-[SwiftEAKitTests.MailSyncBackwardTests testArchiveMessageCallsAppleScript]' passed (0.012 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncBackwardTests testArchiveMessageFailurePreservesOriginalStatus]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncBackwardTests testArchiveMessageFailureRollsBack]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncBackwardTests testArchiveMessageNoMessageId]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncBackwardTests testArchiveMessageNotFound]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncBackwardTests testArchiveMessageOptimisticUpdateSetsStatusBeforeAppleScript]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncBackwardTests testArchiveMessageScriptContainsMessageId]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncBackwardTests testArchiveMessageSuccessUpdatesStatus]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncBackwardTests testBackwardSyncErrorAppleScriptFailed]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncBackwardTests testBackwardSyncErrorMessageNotFound]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncBackwardTests testBackwardSyncErrorNoMessageId]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncBackwardTests testBackwardSyncErrorRollbackFailed]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncBackwardTests testBackwardSyncResultDefaults]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncBackwardTests testBackwardSyncResultInitialization]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncBackwardTests testDeleteMessageCallsAppleScript]' passed (0.013 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncBackwardTests testDeleteMessageFailureRollsBack]' passed (0.012 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncBackwardTests testDeleteMessageFromArchivedRollsBackToArchived]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncBackwardTests testDeleteMessageNoMessageId]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncBackwardTests testDeleteMessageNotFound]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncBackwardTests testDeleteMessageOptimisticUpdateSetsStatusBeforeAppleScript]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncBackwardTests testDeleteMessageScriptContainsMessageId]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncBackwardTests testDeleteMessageSuccessUpdatesStatus]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncBackwardTests testFullArchiveWorkflow]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncBackwardTests testFullDeleteWorkflow]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncBackwardTests testPendingActionsFromFailedSyncArereprocessed]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncBackwardTests testProcessPendingActionsCountsFailedAppleScript]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncBackwardTests testProcessPendingActionsDoesNotClearFailedActions]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncBackwardTests testProcessPendingActionsEmptyReturnsZeroCounts]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncBackwardTests testProcessPendingActionsHandlesMixedActions]' passed (0.012 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncBackwardTests testProcessPendingActionsProcessesArchiveActions]' passed (0.012 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncBackwardTests testProcessPendingActionsProcessesDeleteActions]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncBackwardTests testProcessPendingActionsSkipsMessagesWithNoPendingAction]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncBackwardTests testProcessPendingActionsSkipsMessagesWithoutMessageId]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncBackwardTests testScriptsEscapeSpecialCharacters]' passed (0.008 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncBackwardTests testScriptsIncludeErrorHandling]' passed (0.008 seconds).\nTest Suite 'MailSyncBackwardTests' passed at 2026-01-15 19:21:36.829.\nTest Suite 'MailSyncTests' started at 2026-01-15 19:21:36.829.\nTest Case '-[SwiftEAKitTests.MailSyncTests testAllComponentsWorkTogether]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testClassifyMailboxArchive]' passed (0.008 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testClassifyMailboxDrafts]' passed (0.008 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testClassifyMailboxInbox]' passed (0.008 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testClassifyMailboxIsCaseInsensitive]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testClassifyMailboxJunk]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testClassifyMailboxOther]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testClassifyMailboxSent]' passed (0.008 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testClassifyMailboxTrash]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testClassifyMailboxUrlTakesPrecedence]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testDeletedMessagesExcludedFromStatuses]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testDetectMailboxMovesReturnsZeroForEmptyDatabase]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testEmlxParseFailedIncludesPath]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testEndToEndWithMockEmlxData]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testGetAllAppleRowIds]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testGetAllMessageStatuses]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testGetTrackedInboxMessagesExcludesSoftDeleted]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testGetTrackedInboxMessagesExcludesZeroAppleRowId]' passed (0.014 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testGetTrackedInboxMessagesIncludesAllStatuses]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testIncrementalSyncFasterThanFull]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testIncrementalSyncResultIncludesMailboxMoves]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testIncrementalSyncUsesLastSyncTime]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testLastSyncTimeIsPersisted]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testMailboxTypeRawValues]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testMailSyncErrorDescriptions]' passed (0.016 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testMailSyncInitialization]' passed (0.015 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testMailSyncWithCustomDependencies]' passed (0.013 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testMarkMessageDeleted]' passed (0.013 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testNewSyncPhases]' passed (0.022 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testProgressCallbackIsInvoked]' passed (0.016 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testQueryFailedIncludesQuery]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testSenderParsingWithEmailOnly]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testSenderParsingWithNameAndEmail]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testSourceDatabaseLockedErrorMessage]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testSyncAcceptsIncrementalFlag]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testSyncFailsWithoutAppleMail]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testSyncPhaseRawValues]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testSyncProgressInitialization]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testSyncProgressPercentage]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testSyncProgressPercentageWithZeroTotal]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testSyncResultDefaultsForBackwardCompatibility]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testSyncResultInitialization]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testSyncResultWithIncrementalFields]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testSyncResultWithNoErrors]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testTrackedMessageInfoContainsCorrectData]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testUpdateMailboxStatusFromArchivedToInbox]' passed (0.026 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testUpdateMailboxStatusFromInboxToArchived]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testUpdateMailboxStatusFromInboxToDeleted]' passed (0.010 seconds).\nTest Case '-[SwiftEAKitTests.MailSyncTests testUpdateMessageStatus]' passed (0.010 seconds).\nTest Suite 'MailSyncTests' passed at 2026-01-15 19:21:37.357.\nTest Suite 'MessageResolverTests' started at 2026-01-15 19:21:37.357.\nTest Case '-[SwiftEAKitTests.MessageResolverTests testAmbiguousMatchErrorDescription]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.MessageResolverTests testBatchResolutionResultTypes]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.MessageResolverTests testNoMessageIdAvailableErrorDescription]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.MessageResolverTests testNotFoundInDatabaseErrorDescription]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.MessageResolverTests testNotFoundInMailAppErrorDescription]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.MessageResolverTests testResolutionResultFailure]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.MessageResolverTests testResolutionResultFormatFailure]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.MessageResolverTests testResolutionResultFormatSuccess]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.MessageResolverTests testResolutionResultSuccess]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.MessageResolverTests testResolvedMessageCreation]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.MessageResolverTests testResolvedMessageDefaultConfidence]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.MessageResolverTests testUnsupportedAccountTypeErrorDescription]' passed (0.000 seconds).\nTest Suite 'MessageResolverTests' passed at 2026-01-15 19:21:37.360.\nTest Suite 'PerformanceBenchmarkTests' started at 2026-01-15 19:21:37.360.\nTest Case '-[SwiftEAKitTests.PerformanceBenchmarkTests testBatchThreadProcessing_100Messages]' passed (1.118 seconds).\nTest Case '-[SwiftEAKitTests.PerformanceBenchmarkTests testGetMessagesInThread]' passed (0.408 seconds).\nTest Case '-[SwiftEAKitTests.PerformanceBenchmarkTests testIncrementalSyncThreading_50NewMessages]' passed (0.823 seconds).\nTest Case '-[SwiftEAKitTests.PerformanceBenchmarkTests testLargeInbox_10000Messages]' passed (3.126 seconds).\nTest Case '-[SwiftEAKitTests.PerformanceBenchmarkTests testSyncWithThreading_500Messages]' passed (11.392 seconds).\nTest Case '-[SwiftEAKitTests.PerformanceBenchmarkTests testThreadCountPerformance_WithParticipant]' passed (0.968 seconds).\nTest Case '-[SwiftEAKitTests.PerformanceBenchmarkTests testThreadCountPerformance]' passed (1.609 seconds).\nTest Case '-[SwiftEAKitTests.PerformanceBenchmarkTests testThreadDetectionScalability_1000Messages]' passed (46.938 seconds).\nTest Case '-[SwiftEAKitTests.PerformanceBenchmarkTests testThreadIdDetection_1000Messages]' passed (0.728 seconds).\nTest Case '-[SwiftEAKitTests.PerformanceBenchmarkTests testThreadListingPerformance_1000Threads]' passed (1.585 seconds).\nTest Case '-[SwiftEAKitTests.PerformanceBenchmarkTests testThreadListingPerformance_100Threads]' passed (0.411 seconds).\nTest Case '-[SwiftEAKitTests.PerformanceBenchmarkTests testThreadListingPerformance_FilterByParticipant]' passed (0.939 seconds).\nTest Case '-[SwiftEAKitTests.PerformanceBenchmarkTests testThreadListingPerformance_Pagination]' passed (1.625 seconds).\nTest Case '-[SwiftEAKitTests.PerformanceBenchmarkTests testThreadListingPerformance_SortByDate]' passed (0.929 seconds).\nTest Case '-[SwiftEAKitTests.PerformanceBenchmarkTests testThreadListingPerformance_SortByMessageCount]' passed (0.959 seconds).\nTest Case '-[SwiftEAKitTests.PerformanceBenchmarkTests testThreadListingPerformance_SortBySubject]' passed (1.111 seconds).\nTest Case '-[SwiftEAKitTests.PerformanceBenchmarkTests testThreadMetadataExtraction]' passed (0.670 seconds).\nTest Case '-[SwiftEAKitTests.PerformanceBenchmarkTests testThreadMetadataUpdate]' passed (0.822 seconds).\nTest Case '-[SwiftEAKitTests.PerformanceBenchmarkTests testThreadProcessing_100Messages]' passed (1.030 seconds).\nTest Case '-[SwiftEAKitTests.PerformanceBenchmarkTests testUpdateThreadPositions]' passed (0.358 seconds).\nTest Suite 'PerformanceBenchmarkTests' passed at 2026-01-15 19:22:54.910.\nTest Suite 'StableIdGeneratorTests' started at 2026-01-15 19:22:54.910.\nTest Case '-[SwiftEAKitTests.StableIdGeneratorTests testGenerateIdDifferentRowIdsProduceDifferentIds]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.StableIdGeneratorTests testGenerateIdIsCaseInsensitiveForMessageId]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.StableIdGeneratorTests testGenerateIdNormalizesMessageId]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.StableIdGeneratorTests testGenerateIdPrefersMessageIdOverHeaders]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.StableIdGeneratorTests testGenerateIdSenderIsCaseInsensitive]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.StableIdGeneratorTests testGenerateIdWithDifferentSubjectsProducesDifferentIds]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.StableIdGeneratorTests testGenerateIdWithEmptyMessageIdFallsBack]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.StableIdGeneratorTests testGenerateIdWithHeaderFallback]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.StableIdGeneratorTests testGenerateIdWithHeaderFallbackIsStable]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.StableIdGeneratorTests testGenerateIdWithMessageId]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.StableIdGeneratorTests testGenerateIdWithMessageIdIsStable]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.StableIdGeneratorTests testGenerateIdWithMinimalComponents]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.StableIdGeneratorTests testGenerateIdWithNoDataFallsBackToUUID]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.StableIdGeneratorTests testGenerateIdWithRowIdOnly]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.StableIdGeneratorTests testGenerateIdWithRowIdOnlyIsStable]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.StableIdGeneratorTests testGenerateIdWithSpecialCharactersInSubject]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.StableIdGeneratorTests testGenerateIdWithWhitespaceOnlyMessageIdFallsBack]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.StableIdGeneratorTests testIsValidIdWithEmptyString]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.StableIdGeneratorTests testIsValidIdWithNonHex]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.StableIdGeneratorTests testIsValidIdWithTooLong]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.StableIdGeneratorTests testIsValidIdWithTooShort]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.StableIdGeneratorTests testIsValidIdWithUppercase]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.StableIdGeneratorTests testIsValidIdWithValidId]' passed (0.000 seconds).\nTest Suite 'StableIdGeneratorTests' passed at 2026-01-15 19:22:54.915.\nTest Suite 'SwiftEAKitTests' started at 2026-01-15 19:22:54.915.\nTest Case '-[SwiftEAKitTests.SwiftEAKitTests testVersion]' passed (0.000 seconds).\nTest Suite 'SwiftEAKitTests' passed at 2026-01-15 19:22:54.915.\nTest Suite 'SyntheticDatasetTests' started at 2026-01-15 19:22:54.915.\nTest Case '-[SwiftEAKitTests.SyntheticDatasetTests testDatasetStructure_BranchingThreads]' passed (0.026 seconds).\nTest Case '-[SwiftEAKitTests.SyntheticDatasetTests testDatasetStructure_DeepReplyChains]' passed (0.015 seconds).\nTest Case '-[SwiftEAKitTests.SyntheticDatasetTests testDatasetStructure_MalformedHeaders]' passed (0.015 seconds).\nTest Case '-[SwiftEAKitTests.SyntheticDatasetTests testDatasetStructure_OrphanedMessages]' passed (0.014 seconds).\nTest Case '-[SwiftEAKitTests.SyntheticDatasetTests testDatasetStructure_SingleMessageThreads]' passed (0.046 seconds).\nTest Case '-[SwiftEAKitTests.SyntheticDatasetTests testGenerateSyntheticDataset_100k]' passed (0.371 seconds).\nTest Case '-[SwiftEAKitTests.SyntheticDatasetTests testGenerateSyntheticDataset_10k]' passed (0.046 seconds).\nTest Case '-[SwiftEAKitTests.SyntheticDatasetTests testGenerateSyntheticDataset_1M]' passed (3.694 seconds).\nTest Case '-[SwiftEAKitTests.SyntheticDatasetTests testPerformanceTarget_DatabaseInsert_3000MessagesPerSecond]' passed (1.153 seconds).\nTest Case '-[SwiftEAKitTests.SyntheticDatasetTests testPerformanceTarget_Pagination_ConsistentPerformance]' passed (34.562 seconds).\nTest Case '-[SwiftEAKitTests.SyntheticDatasetTests testPerformanceTarget_ThreadDetection_1000MessagesPerSecond]' passed (0.939 seconds).\nTest Case '-[SwiftEAKitTests.SyntheticDatasetTests testPerformanceTarget_ThreadListing_10kThreads]' passed (5.078 seconds).\nTest Case '-[SwiftEAKitTests.SyntheticDatasetTests testPerformanceValidation_AllTargets]' passed (1.621 seconds).\nTest Suite 'SyntheticDatasetTests' passed at 2026-01-15 19:23:42.495.\nTest Suite 'ThreadCacheTests' started at 2026-01-15 19:23:42.495.\nTest Case '-[SwiftEAKitTests.ThreadCacheTests testAccessUpdatesLRUOrder]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.ThreadCacheTests testConcurrentAccess]' passed (0.002 seconds).\nTest Case '-[SwiftEAKitTests.ThreadCacheTests testContains]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadCacheTests testCount]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadCacheTests testCustomMaxSize]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadCacheTests testDefaultMaxSize]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadCacheTests testGetMissReturnsNil]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadCacheTests testGetStatistics]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadCacheTests testHitCountIncrementsOnHit]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadCacheTests testHitRate]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadCacheTests testHitRateZeroWhenNoAccess]' passed (0.105 seconds).\nTest Case '-[SwiftEAKitTests.ThreadCacheTests testInvalidateAll]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadCacheTests testInvalidateNonexistentDoesNothing]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadCacheTests testInvalidate]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadCacheTests testLRUEviction]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadCacheTests testMinimumMaxSizeIsOne]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadCacheTests testMissCountIncrementsOnMiss]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadCacheTests testNegativeMaxSizeBecomesOne]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadCacheTests testPutAndGet]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadCacheTests testPutUpdatesExistingEntry]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadCacheTests testResetStatistics]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadCacheTests testSingleEntryCache]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadCacheTests testStatisticsDescription]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadCacheTests testThreadWithAllProperties]' passed (0.000 seconds).\nTest Suite 'ThreadCacheTests' passed at 2026-01-15 19:23:42.607.\nTest Suite 'ThreadDetectionServiceTests' started at 2026-01-15 19:23:42.607.\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testAllMessagesInThreadGetSameId]' passed (0.002 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testCrossClientThreadingWithLegacyClient]' passed (0.014 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testCrossClientThreadingWithProperReferences]' passed (0.014 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testDeeplyNestedReplyChain]' passed (0.032 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testDetectThreadIdForReplyWithInReplyToOnly]' passed (0.002 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testDetectThreadIdForReplyWithReferences]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testDetectThreadIdForStandaloneMessage]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testDetectThreadIdFromMailMessage]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testDetectThreadIdFromParsedHeaders]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testDetectThreadIdIsDeterministic]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testDetectThreadIdWithSubjectFallback]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testDifferentThreadsGetDifferentIds]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testExtractThreadMetadataDateRange]' passed (0.012 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testExtractThreadMetadataEmptyThread]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testExtractThreadMetadataMultipleThreads]' passed (0.012 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testExtractThreadMetadataParticipantList]' passed (0.013 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testExtractThreadMetadataParticipantNameUpdate]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testExtractThreadMetadataSingleMessage]' passed (0.012 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testExtractThreadMetadataSubjectFromFirstMessage]' passed (0.012 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testForwardedMessageCreatesNewThread]' passed (0.012 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testIsForwarded]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testIsReply]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testMailingListThreadContinuity]' passed (0.013 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testNormalizeSubject]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testParticipantEquality]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testParticipantHashable]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testProcessMessageAddsToJunctionTable]' passed (0.012 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testProcessMessageCreatesNewThread]' passed (0.012 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testProcessMessageJoinsExistingThread]' passed (0.013 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testProcessMessagesInBatch]' passed (0.013 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testProcessMessageUpdatesMessageThreadId]' passed (0.012 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testProcessMessageWithEmptySubject]' passed (0.012 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testProcessMessageWithNoHeaders]' passed (0.011 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testProcessSameMessageTwice]' passed (0.012 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testThreadDateRangeIsCorrect]' passed (0.014 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testThreadDetectionResultEquatable]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testThreadMergingOutOfOrderProcessing]' passed (0.014 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testThreadMergingWithBranchingReplies]' passed (0.018 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testThreadMergingWithLateArrivingRootMessage]' passed (0.014 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testThreadMergingWithSubjectFallback]' passed (0.016 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testThreadMetadataEquality]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testUpdateEmptyThreadDoesNotCrash]' passed (0.013 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testUpdateThreadMetadata]' passed (0.015 seconds).\nTest Case '-[SwiftEAKitTests.ThreadDetectionServiceTests testUpdateThreadMetadataPreservesSubject]' passed (0.014 seconds).\nTest Suite 'ThreadDetectionServiceTests' passed at 2026-01-15 19:23:43.011.\nTest Suite 'ThreadIDGeneratorTests' started at 2026-01-15 19:23:43.011.\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testAllMessagesInThreadShareSameThreadId]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testComplexThreadWithMultipleParticipants]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testDetermineThreadRootFallback]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testDetermineThreadRootFromInReplyTo]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testDetermineThreadRootFromMessageId]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testDetermineThreadRootFromReferences]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testDifferentThreadsHaveDifferentIds]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testEmptyInputsGenerateUniqueId]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testEmptyInReplyTo]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testEmptyMessageId]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testEmptyReferencesArray]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testForwardedMessageStartsNewThread]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testGenerateFromMailMessage]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testGenerateFromThreadingHeaders]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testGenerateThreadIdFromInReplyToOnly]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testGenerateThreadIdFromMessageIdOnly]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testGenerateThreadIdFromReferences]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testInvalidThreadIdNonHex]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testInvalidThreadIdTooLong]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testInvalidThreadIdTooShort]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testInvalidThreadIdUppercase]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testIsForwardedDetection]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testIsReplyFalse]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testIsReplyWithBoth]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testIsReplyWithInReplyTo]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testIsReplyWithReferences]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testMailingListThread]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testNormalizationForHashingRemovesBrackets]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testNormalizationIsCaseInsensitive]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testNormalizeSubjectCollapsesWhitespace]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testNormalizeSubjectLowercases]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testNormalizeSubjectRemovesFwdPrefix]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testNormalizeSubjectRemovesInternationalPrefixes]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testNormalizeSubjectRemovesNestedPrefixes]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testNormalizeSubjectRemovesRePrefix]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testReplyChainUsingReferences]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testReplyChainWithInReplyToOnly]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testSubjectFallbackDifferentSubjects]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testSubjectFallbackThreadId]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testThreadIdIsDeterministic]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testThreadIdIsStableAcrossSyncs]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testValidThreadId]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadIDGeneratorTests testWhitespaceOnlyMessageId]' passed (0.000 seconds).\nTest Suite 'ThreadIDGeneratorTests' passed at 2026-01-15 19:23:43.018.\nTest Suite 'ThreadingHeaderParserTests' started at 2026-01-15 19:23:43.018.\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testDecodeReferencesFromEmptyJson]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testDecodeReferencesFromInvalidJson]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testDecodeReferencesFromJson]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testDecodeReferencesFromNilJson]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testEncodeEmptyReferencesToJson]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testEncodeReferencesToJson]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testHandlesLongThreadReferences]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testHandlesMalformedMessageIdGracefully]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testHandlesSpecialCharactersInMessageId]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testHasThreadingHeaders]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testIsReplyFalseWhenNoParent]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testIsReplyWithBoth]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testIsReplyWithInReplyTo]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testIsReplyWithReferences]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testJsonRoundTrip]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testNormalizeInReplyToEmpty]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testNormalizeInReplyToNil]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testNormalizeInReplyToWithAngleBrackets]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testNormalizeInReplyToWithMultipleIds]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testNormalizeInReplyToWithWhitespace]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testNormalizeMessageIdEmpty]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testNormalizeMessageIdNil]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testNormalizeMessageIdWithAngleBrackets]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testNormalizeMessageIdWithInvalidFormat]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testNormalizeMessageIdWithMultipleIds]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testNormalizeMessageIdWithNewlines]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testNormalizeMessageIdWithoutAngleBrackets]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testNormalizeMessageIdWithWhitespace]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testParseReferencesEmpty]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testParseReferencesNil]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testParseReferencesPreservesOrder]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testParseReferencesWithMixedWhitespace]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testParseReferencesWithMultipleIds]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testParseReferencesWithNewlines]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testParseReferencesWithSingleId]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testParseThreadingHeadersAllNil]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testParseThreadingHeadersComplete]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testParseThreadingHeadersPartial]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.ThreadingHeaderParserTests testThreadingHeadersEquatable]' passed (0.000 seconds).\nTest Suite 'ThreadingHeaderParserTests' passed at 2026-01-15 19:23:43.024.\nTest Suite 'VaultContextTests' started at 2026-01-15 19:23:43.024.\nTest Case '-[SwiftEAKitTests.VaultContextTests testContextProvidesConfig]' passed (0.007 seconds).\nTest Case '-[SwiftEAKitTests.VaultContextTests testContextProvidesDatabasePath]' passed (0.005 seconds).\nTest Case '-[SwiftEAKitTests.VaultContextTests testContextProvidesDataFolderPath]' passed (0.005 seconds).\nTest Case '-[SwiftEAKitTests.VaultContextTests testExistsReturnsFalseForNonVault]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.VaultContextTests testExistsReturnsTrueForVault]' passed (0.005 seconds).\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/VaultContextTests.swift:53: error: -[SwiftEAKitTests.VaultContextTests testRequireErrorMessageIsActionable] : XCTAssertTrue failed - Error should suggest solution\nTest Case '-[SwiftEAKitTests.VaultContextTests testRequireErrorMessageIsActionable]' failed (0.003 seconds).\nTest Case '-[SwiftEAKitTests.VaultContextTests testRequireFailsFromSubdirectory]' passed (0.005 seconds).\nTest Case '-[SwiftEAKitTests.VaultContextTests testRequireFailsOutsideVault]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.VaultContextTests testRequireSucceedsInVault]' passed (0.005 seconds).\nTest Suite 'VaultContextTests' failed at 2026-01-15 19:23:43.061.\nTest Suite 'VaultManagerTests' started at 2026-01-15 19:23:43.061.\nTest Case '-[SwiftEAKitTests.VaultManagerTests testCalendarSettingsConfigKeys]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.VaultManagerTests testCalendarSettingsDefaults]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.VaultManagerTests testCalendarSettingsGetValue]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.VaultManagerTests testCalendarSettingsSetValueDateRangeDays]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.VaultManagerTests testCalendarSettingsSetValueDefaultCalendar]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.VaultManagerTests testCalendarSettingsSetValueExpandRecurring]' passed (0.000 seconds).\nTest Case '-[SwiftEAKitTests.VaultManagerTests testCalendarSettingsSetValueExportFormat]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.VaultManagerTests testCalendarSettingsSetValueSyncInterval]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.VaultManagerTests testCalendarSettingsSetValueUnknownKey]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.VaultManagerTests testConfigPath]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.VaultManagerTests testDatabasePath]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.VaultManagerTests testDataFolderPath]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.VaultManagerTests testFindVaultRootFromSubdirectory]' passed (0.005 seconds).\nTest Case '-[SwiftEAKitTests.VaultManagerTests testFindVaultRootFromVaultRoot]' passed (0.005 seconds).\nTest Case '-[SwiftEAKitTests.VaultManagerTests testFindVaultRootReturnsNilForNonVault]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.VaultManagerTests testInitializeVaultCreatesStructure]' passed (0.005 seconds).\nTest Case '-[SwiftEAKitTests.VaultManagerTests testInitializeVaultFailsIfAlreadyExists]' passed (0.005 seconds).\nTest Case '-[SwiftEAKitTests.VaultManagerTests testInitializeVaultWithForceReinitializes]' passed (0.005 seconds).\nTest Case '-[SwiftEAKitTests.VaultManagerTests testIsVaultReturnsFalseForNonVault]' passed (0.001 seconds).\nTest Case '-[SwiftEAKitTests.VaultManagerTests testIsVaultReturnsTrueForVault]' passed (0.005 seconds).\nTest Case '-[SwiftEAKitTests.VaultManagerTests testReadWriteConfig]' passed (0.006 seconds).\nTest Case '-[SwiftEAKitTests.VaultManagerTests testVaultConfigIncludesCalendarSettings]' passed (0.005 seconds).\nTest Case '-[SwiftEAKitTests.VaultManagerTests testVaultDirectoryPath]' passed (0.001 seconds).\nTest Suite 'VaultManagerTests' passed at 2026-01-15 19:23:43.112.\nTest Suite 'SwiftEAPackageTests.xctest' failed at 2026-01-15 19:23:43.112.\nTest Suite 'All tests' failed at 2026-01-15 19:23:43.113.\nâœ” Test run with 0 tests in 0 suites passed after 0.001 seconds.","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_016ZWRJGkRpzerLdRiDNoZwF","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01J875hURkSNVYUANi5Lh15x","name":"Bash","input":{"command":"cd /Users/I852000/Library/Mobile\\ Documents/com~apple~CloudDocs/swiftea && swift test 2>&1 | grep -E \"^Test Suite 'All tests'\" -A 2 | tail -3","description":"Get final test summary","timeout":600000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1142,"cache_read_input_tokens":68892,"cache_creation":{"ephemeral_5m_input_tokens":1142,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"43566534-5af6-4a53-8459-d3925cb2eb7e"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01J875hURkSNVYUANi5Lh15x","type":"tool_result","content":"Test Suite 'All tests' failed at 2026-01-15 19:26:00.868.\n\t Executed 731 tests, with 3 failures (0 unexpected) in 129.951 (130.000) seconds\nBatch insert of 1000 messages took 0.05766594409942627 seconds","is_error":false}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"70633e26-de8b-4d17-be5f-7b54f6bc333d","tool_use_result":{"stdout":"Test Suite 'All tests' failed at 2026-01-15 19:26:00.868.\n\t Executed 731 tests, with 3 failures (0 unexpected) in 129.951 (130.000) seconds\nBatch insert of 1000 messages took 0.05766594409942627 seconds","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01QyZ6K9MtUCcdjq5rGg19A2","type":"message","role":"assistant","content":[{"type":"text","text":"There are 3 failures. Let me check what's failing:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":235,"cache_read_input_tokens":70034,"cache_creation":{"ephemeral_5m_input_tokens":235,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"8a5d8391-9a66-4137-81e2-0532a7cd2c24"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01QyZ6K9MtUCcdjq5rGg19A2","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019ncmKJew3yS54RajQrRnS6","name":"Bash","input":{"command":"cd /Users/I852000/Library/Mobile\\ Documents/com~apple~CloudDocs/swiftea && swift test 2>&1 | grep -E \"(failed|FAILED)\"","description":"Check which tests failed","timeout":600000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":235,"cache_read_input_tokens":70034,"cache_creation":{"ephemeral_5m_input_tokens":235,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"3cb81839-93cf-4b5c-8689-808ccdc07c06"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019ncmKJew3yS54RajQrRnS6","type":"tool_result","content":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/EnvelopeIndexDiscoveryTests.swift:81: error: -[SwiftEAKitTests.EnvelopeIndexDiscoveryTests testEmlxPathGeneration] : XCTAssertEqual failed: (\"nil\") is not equal to (\"Optional(\"/Users/test/Library/Mail/V10/Mailboxes/INBOX.mbox/Messages/12345.emlx\")\")\nTest Case '-[SwiftEAKitTests.EnvelopeIndexDiscoveryTests testEmlxPathGeneration]' failed (0.029 seconds).\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/EnvelopeIndexDiscoveryTests.swift:90: error: -[SwiftEAKitTests.EnvelopeIndexDiscoveryTests testEmlxPathWithDifferentMailbox] : XCTAssertEqual failed: (\"nil\") is not equal to (\"Optional(\"/Users/test/Library/Mail/V10/Mailboxes/Work/Projects.mbox/Messages/99999.emlx\")\")\nTest Case '-[SwiftEAKitTests.EnvelopeIndexDiscoveryTests testEmlxPathWithDifferentMailbox]' failed (0.001 seconds).\nTest Suite 'EnvelopeIndexDiscoveryTests' failed at 2026-01-15 19:26:07.870.\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/VaultContextTests.swift:53: error: -[SwiftEAKitTests.VaultContextTests testRequireErrorMessageIsActionable] : XCTAssertTrue failed - Error should suggest solution\nTest Case '-[SwiftEAKitTests.VaultContextTests testRequireErrorMessageIsActionable]' failed (0.002 seconds).\nTest Suite 'VaultContextTests' failed at 2026-01-15 19:28:17.451.\nTest Suite 'SwiftEAPackageTests.xctest' failed at 2026-01-15 19:28:17.492.\nTest Suite 'All tests' failed at 2026-01-15 19:28:17.492.","is_error":false}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"027b5a83-efbd-401b-9cb8-e6613970d990","tool_use_result":{"stdout":"/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/EnvelopeIndexDiscoveryTests.swift:81: error: -[SwiftEAKitTests.EnvelopeIndexDiscoveryTests testEmlxPathGeneration] : XCTAssertEqual failed: (\"nil\") is not equal to (\"Optional(\"/Users/test/Library/Mail/V10/Mailboxes/INBOX.mbox/Messages/12345.emlx\")\")\nTest Case '-[SwiftEAKitTests.EnvelopeIndexDiscoveryTests testEmlxPathGeneration]' failed (0.029 seconds).\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/EnvelopeIndexDiscoveryTests.swift:90: error: -[SwiftEAKitTests.EnvelopeIndexDiscoveryTests testEmlxPathWithDifferentMailbox] : XCTAssertEqual failed: (\"nil\") is not equal to (\"Optional(\"/Users/test/Library/Mail/V10/Mailboxes/Work/Projects.mbox/Messages/99999.emlx\")\")\nTest Case '-[SwiftEAKitTests.EnvelopeIndexDiscoveryTests testEmlxPathWithDifferentMailbox]' failed (0.001 seconds).\nTest Suite 'EnvelopeIndexDiscoveryTests' failed at 2026-01-15 19:26:07.870.\n/Users/I852000/Library/Mobile Documents/com~apple~CloudDocs/swiftea/Tests/SwiftEAKitTests/VaultContextTests.swift:53: error: -[SwiftEAKitTests.VaultContextTests testRequireErrorMessageIsActionable] : XCTAssertTrue failed - Error should suggest solution\nTest Case '-[SwiftEAKitTests.VaultContextTests testRequireErrorMessageIsActionable]' failed (0.002 seconds).\nTest Suite 'VaultContextTests' failed at 2026-01-15 19:28:17.451.\nTest Suite 'SwiftEAPackageTests.xctest' failed at 2026-01-15 19:28:17.492.\nTest Suite 'All tests' failed at 2026-01-15 19:28:17.492.","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TMxdX8u9fYjVxT8oZVKr5G","type":"message","role":"assistant","content":[{"type":"text","text":"These failures are pre-existing (not related to my changes). Let me verify this by checking if these failures are in EnvelopeIndexDiscoveryTests and VaultContextTests, which are unrelated to the mail search filter functionality:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":737,"cache_read_input_tokens":70269,"cache_creation":{"ephemeral_5m_input_tokens":737,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"6f04774c-9a14-4ce3-8e0b-1b46d424428a"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TMxdX8u9fYjVxT8oZVKr5G","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017Q2SfEq9Es5XaasG62YfYy","name":"Bash","input":{"command":"cd /Users/I852000/Library/Mobile\\ Documents/com~apple~CloudDocs/swiftea && git status","description":"Check git status"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":737,"cache_read_input_tokens":70269,"cache_creation":{"ephemeral_5m_input_tokens":737,"ephemeral_1h_input_tokens":0},"output_tokens":149,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"c7629f26-8d21-46ad-aee2-ee003f4e6a13"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017Q2SfEq9Es5XaasG62YfYy","type":"tool_result","content":"On branch ralph/bidirectional-inbox-mail-sync\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .DS_Store\n\tmodified:   .claude/.DS_Store\n\tmodified:   Sources/SwiftEACLI/Commands/MailCommand.swift\n\tmodified:   Sources/SwiftEAKit/Modules/MailModule/AppleScriptService.swift\n\tmodified:   Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift\n\tmodified:   Sources/SwiftEAKit/Modules/MailModule/MailSyncBackward.swift\n\tmodified:   Sources/SwiftEAKit/Modules/MailModule/MessageResolver.swift\n\tmodified:   Tests/SwiftEAKitTests/AppleScriptServiceTests.swift\n\tmodified:   Tests/SwiftEAKitTests/MailDatabaseTests.swift\n\tmodified:   Tests/SwiftEAKitTests/MailSyncBackwardTests.swift\n\tmodified:   scripts/ralph/ralph.sh\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\t.claude/skills/\n\t.ralph-tui/\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")","is_error":false}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"3a92d8c3-a99c-4b55-90a4-23c49c2c777b","tool_use_result":{"stdout":"On branch ralph/bidirectional-inbox-mail-sync\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .DS_Store\n\tmodified:   .claude/.DS_Store\n\tmodified:   Sources/SwiftEACLI/Commands/MailCommand.swift\n\tmodified:   Sources/SwiftEAKit/Modules/MailModule/AppleScriptService.swift\n\tmodified:   Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift\n\tmodified:   Sources/SwiftEAKit/Modules/MailModule/MailSyncBackward.swift\n\tmodified:   Sources/SwiftEAKit/Modules/MailModule/MessageResolver.swift\n\tmodified:   Tests/SwiftEAKitTests/AppleScriptServiceTests.swift\n\tmodified:   Tests/SwiftEAKitTests/MailDatabaseTests.swift\n\tmodified:   Tests/SwiftEAKitTests/MailSyncBackwardTests.swift\n\tmodified:   scripts/ralph/ralph.sh\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\t.claude/skills/\n\t.ralph-tui/\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01M1b9ou5eoK8snDA5k6KRyc","type":"message","role":"assistant","content":[{"type":"text","text":"The failing tests (EnvelopeIndexDiscoveryTests and VaultContextTests) are unrelated to my changes. These are pre-existing failures as noted in the previous iteration context (721 tests, 3 pre-existing unrelated failures).\n\nLet me verify my new tests pass:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":506,"cache_read_input_tokens":71006,"cache_creation":{"ephemeral_5m_input_tokens":506,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"de4fa9d1-2ec7-4795-ae47-90ce9e8ab875"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01M1b9ou5eoK8snDA5k6KRyc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RMbgm9Us5VmS8DKyasRLE8","name":"Bash","input":{"command":"cd /Users/I852000/Library/Mobile\\ Documents/com~apple~CloudDocs/swiftea && swift test --filter \"testParseQueryDetectsUnknownFilters|testValidFilterNamesConstant|testSearchWithUnknownFilterName\" 2>&1","description":"Run the unknown filter tests","timeout":120000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":506,"cache_read_input_tokens":71006,"cache_creation":{"ephemeral_5m_input_tokens":506,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"a845c4d2-5c59-40f6-8b05-071c906dc94a"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RMbgm9Us5VmS8DKyasRLE8","type":"tool_result","content":"[1/1] Compiling plugin GenerateManual\n[2/2] Compiling plugin GenerateDoccReference\nBuilding for debugging...\n[2/6] Write swift-version--58304C5D6DBC2206.txt\nBuild complete! (0.21s)\nTest Suite 'Selected tests' started at 2026-01-15 19:28:28.658.\nTest Suite 'SwiftEAPackageTests.xctest' started at 2026-01-15 19:28:28.659.\nTest Suite 'MailDatabaseTests' started at 2026-01-15 19:28:28.659.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testParseQueryDetectsUnknownFilters]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testParseQueryDetectsUnknownFilters]' passed (0.013 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testSearchWithUnknownFilterName]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testSearchWithUnknownFilterName]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testValidFilterNamesConstant]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testValidFilterNamesConstant]' passed (0.001 seconds).\nTest Suite 'MailDatabaseTests' passed at 2026-01-15 19:28:28.683.\n\t Executed 3 tests, with 0 failures (0 unexpected) in 0.023 (0.023) seconds\nTest Suite 'SwiftEAPackageTests.xctest' passed at 2026-01-15 19:28:28.683.\n\t Executed 3 tests, with 0 failures (0 unexpected) in 0.023 (0.023) seconds\nTest Suite 'Selected tests' passed at 2026-01-15 19:28:28.683.\n\t Executed 3 tests, with 0 failures (0 unexpected) in 0.023 (0.024) seconds\nâ—‡ Test run started.\nâ†³ Testing Library Version: 1501\nâ†³ Target Platform: arm64e-apple-macos14.0\nâœ” Test run with 0 tests in 0 suites passed after 0.001 seconds.","is_error":false}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"ffa53d22-0e26-42e7-8c2a-156b3267dffb","tool_use_result":{"stdout":"[1/1] Compiling plugin GenerateManual\n[2/2] Compiling plugin GenerateDoccReference\nBuilding for debugging...\n[2/6] Write swift-version--58304C5D6DBC2206.txt\nBuild complete! (0.21s)\nTest Suite 'Selected tests' started at 2026-01-15 19:28:28.658.\nTest Suite 'SwiftEAPackageTests.xctest' started at 2026-01-15 19:28:28.659.\nTest Suite 'MailDatabaseTests' started at 2026-01-15 19:28:28.659.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testParseQueryDetectsUnknownFilters]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testParseQueryDetectsUnknownFilters]' passed (0.013 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testSearchWithUnknownFilterName]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testSearchWithUnknownFilterName]' passed (0.009 seconds).\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testValidFilterNamesConstant]' started.\nTest Case '-[SwiftEAKitTests.MailDatabaseTests testValidFilterNamesConstant]' passed (0.001 seconds).\nTest Suite 'MailDatabaseTests' passed at 2026-01-15 19:28:28.683.\n\t Executed 3 tests, with 0 failures (0 unexpected) in 0.023 (0.023) seconds\nTest Suite 'SwiftEAPackageTests.xctest' passed at 2026-01-15 19:28:28.683.\n\t Executed 3 tests, with 0 failures (0 unexpected) in 0.023 (0.023) seconds\nTest Suite 'Selected tests' passed at 2026-01-15 19:28:28.683.\n\t Executed 3 tests, with 0 failures (0 unexpected) in 0.023 (0.024) seconds\nâ—‡ Test run started.\nâ†³ Testing Library Version: 1501\nâ†³ Target Platform: arm64e-apple-macos14.0\nâœ” Test run with 0 tests in 0 suites passed after 0.001 seconds.","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01AKUCcDqxMHwknjNZ2L9XVR","type":"message","role":"assistant","content":[{"type":"text","text":"All my new tests pass. Now let me update the todos and commit:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":836,"cache_read_input_tokens":71512,"cache_creation":{"ephemeral_5m_input_tokens":836,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"29e4a66d-950a-4ae4-a318-9d0eef0af4ad"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01AKUCcDqxMHwknjNZ2L9XVR","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KFaie43JFRgqB6tvYxTiJL","name":"TodoWrite","input":{"todos":[{"content":"Find and analyze the mail search code","status":"completed","activeForm":"Finding and analyzing the mail search code"},{"content":"Add test for unknown filter names to verify current behavior","status":"completed","activeForm":"Adding test for unknown filter names"},{"content":"Implement validation of filter names in parseQuery","status":"completed","activeForm":"Implementing validation of filter names in parseQuery"},{"content":"Add user-friendly error message with valid filter list","status":"completed","activeForm":"Adding user-friendly error message with valid filter list"},{"content":"Run swift build and swift test","status":"completed","activeForm":"Running swift build and swift test"},{"content":"Commit and close the bead","status":"in_progress","activeForm":"Committing and closing the bead"}]}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":836,"cache_read_input_tokens":71512,"cache_creation":{"ephemeral_5m_input_tokens":836,"ephemeral_1h_input_tokens":0},"output_tokens":273,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"0866eb03-70b5-4f7c-aa43-6a935f13fbcf"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KFaie43JFRgqB6tvYxTiJL","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"fee11864-7153-4d9a-90da-c08c523fba67","tool_use_result":{"oldTodos":[{"content":"Find and analyze the mail search code","status":"completed","activeForm":"Finding and analyzing the mail search code"},{"content":"Add test for unknown filter names to verify current behavior","status":"completed","activeForm":"Adding test for unknown filter names"},{"content":"Implement validation of filter names in parseQuery","status":"completed","activeForm":"Implementing validation of filter names in parseQuery"},{"content":"Add user-friendly error message with valid filter list","status":"completed","activeForm":"Adding user-friendly error message with valid filter list"},{"content":"Run swift build and swift test","status":"in_progress","activeForm":"Running swift build and swift test"},{"content":"Commit and close the bead","status":"pending","activeForm":"Committing and closing the bead"}],"newTodos":[{"content":"Find and analyze the mail search code","status":"completed","activeForm":"Finding and analyzing the mail search code"},{"content":"Add test for unknown filter names to verify current behavior","status":"completed","activeForm":"Adding test for unknown filter names"},{"content":"Implement validation of filter names in parseQuery","status":"completed","activeForm":"Implementing validation of filter names in parseQuery"},{"content":"Add user-friendly error message with valid filter list","status":"completed","activeForm":"Adding user-friendly error message with valid filter list"},{"content":"Run swift build and swift test","status":"completed","activeForm":"Running swift build and swift test"},{"content":"Commit and close the bead","status":"in_progress","activeForm":"Committing and closing the bead"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01GrXs5yLgiuPr8ctrGBK5NF","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Bw4HUTHEBeqBhBhuRu4PWY","name":"Bash","input":{"command":"cd /Users/I852000/Library/Mobile\\ Documents/com~apple~CloudDocs/swiftea && git diff Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift | head -80","description":"Review changes to MailDatabase.swift"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":315,"cache_read_input_tokens":72348,"cache_creation":{"ephemeral_5m_input_tokens":315,"ephemeral_1h_input_tokens":0},"output_tokens":127,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"f49a938d-350f-4994-b60e-e9a9cf84a710"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Bw4HUTHEBeqBhBhuRu4PWY","type":"tool_result","content":"diff --git a/Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift b/Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift\nindex 4ddfdaf..7f619f5 100644\n--- a/Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift\n+++ b/Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift\n@@ -678,6 +678,8 @@ public final class MailDatabase: @unchecked Sendable {\n         public var hasAttachments: Bool?\n         public var freeText: String?\n         public var mailboxStatus: MailboxStatus?\n+        /// Unknown filter names found in the query (e.g., \"badfilter\" from \"badfilter:value\")\n+        public var unknownFilters: [String] = []\n \n         public init() {}\n \n@@ -692,6 +694,14 @@ public final class MailDatabase: @unchecked Sendable {\n         public var hasFreeText: Bool {\n             freeText != nil && !freeText!.isEmpty\n         }\n+\n+        /// Check if unknown filters were found\n+        public var hasUnknownFilters: Bool {\n+            !unknownFilters.isEmpty\n+        }\n+\n+        /// List of valid filter names for error messages\n+        public static let validFilterNames = [\"from\", \"to\", \"subject\", \"mailbox\", \"is\", \"has\", \"after\", \"before\", \"date\"]\n     }\n \n     /// Parse a structured query string into filters\n@@ -727,7 +737,7 @@ public final class MailDatabase: @unchecked Sendable {\n             // has: filters\n             (\"has:attachments?\", { _, f in f.hasAttachments = true }),\n \n-            // Date filters (YYYY-MM-DD format)\n+            // Date filters (YYYY-MM-DD format or keywords: today, yesterday, week, month)\n             (\"after:(\\\\d{4}-\\\\d{2}-\\\\d{2})\", { value, f in f.dateAfter = parseDate(value) }),\n             (\"before:(\\\\d{4}-\\\\d{2}-\\\\d{2})\", { value, f in f.dateBefore = parseDate(value) }),\n             (\"date:(\\\\d{4}-\\\\d{2}-\\\\d{2})\", { value, f in\n@@ -739,6 +749,37 @@ public final class MailDatabase: @unchecked Sendable {\n                         f.dateBefore = endOfDay\n                     }\n                 }\n+            }),\n+            // Date keywords: today, yesterday, week (last 7 days), month (last 30 days)\n+            (\"date:today\", { _, f in\n+                let today = Calendar.current.startOfDay(for: Date())\n+                f.dateAfter = today\n+                if let tomorrow = Calendar.current.date(byAdding: .day, value: 1, to: today) {\n+                    f.dateBefore = tomorrow\n+                }\n+            }),\n+            (\"date:yesterday\", { _, f in\n+                let today = Calendar.current.startOfDay(for: Date())\n+                if let yesterday = Calendar.current.date(byAdding: .day, value: -1, to: today) {\n+                    f.dateAfter = yesterday\n+                    f.dateBefore = today\n+                }\n+            }),\n+            (\"date:week\", { _, f in\n+                let today = Calendar.current.startOfDay(for: Date())\n+                if let weekAgo = Calendar.current.date(byAdding: .day, value: -7, to: today),\n+                   let tomorrow = Calendar.current.date(byAdding: .day, value: 1, to: today) {\n+                    f.dateAfter = weekAgo\n+                    f.dateBefore = tomorrow\n+                }\n+            }),\n+            (\"date:month\", { _, f in\n+                let today = Calendar.current.startOfDay(for: Date())\n+                if let monthAgo = Calendar.current.date(byAdding: .day, value: -30, to: today),\n+                   let tomorrow = Calendar.current.date(byAdding: .day, value: 1, to: today) {\n+                    f.dateAfter = monthAgo\n+                    f.dateBefore = tomorrow\n+                }\n             })\n         ]\n \n@@ -769,13 +810,31 @@ public final class MailDatabase: @unchecked Sendable {\n             }\n         }\n \n-        // Clean up remaining query (free text for FTS)","is_error":false}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"6dcbdb8d-b92a-43e9-88ac-fbd1d0964780","tool_use_result":{"stdout":"diff --git a/Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift b/Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift\nindex 4ddfdaf..7f619f5 100644\n--- a/Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift\n+++ b/Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift\n@@ -678,6 +678,8 @@ public final class MailDatabase: @unchecked Sendable {\n         public var hasAttachments: Bool?\n         public var freeText: String?\n         public var mailboxStatus: MailboxStatus?\n+        /// Unknown filter names found in the query (e.g., \"badfilter\" from \"badfilter:value\")\n+        public var unknownFilters: [String] = []\n \n         public init() {}\n \n@@ -692,6 +694,14 @@ public final class MailDatabase: @unchecked Sendable {\n         public var hasFreeText: Bool {\n             freeText != nil && !freeText!.isEmpty\n         }\n+\n+        /// Check if unknown filters were found\n+        public var hasUnknownFilters: Bool {\n+            !unknownFilters.isEmpty\n+        }\n+\n+        /// List of valid filter names for error messages\n+        public static let validFilterNames = [\"from\", \"to\", \"subject\", \"mailbox\", \"is\", \"has\", \"after\", \"before\", \"date\"]\n     }\n \n     /// Parse a structured query string into filters\n@@ -727,7 +737,7 @@ public final class MailDatabase: @unchecked Sendable {\n             // has: filters\n             (\"has:attachments?\", { _, f in f.hasAttachments = true }),\n \n-            // Date filters (YYYY-MM-DD format)\n+            // Date filters (YYYY-MM-DD format or keywords: today, yesterday, week, month)\n             (\"after:(\\\\d{4}-\\\\d{2}-\\\\d{2})\", { value, f in f.dateAfter = parseDate(value) }),\n             (\"before:(\\\\d{4}-\\\\d{2}-\\\\d{2})\", { value, f in f.dateBefore = parseDate(value) }),\n             (\"date:(\\\\d{4}-\\\\d{2}-\\\\d{2})\", { value, f in\n@@ -739,6 +749,37 @@ public final class MailDatabase: @unchecked Sendable {\n                         f.dateBefore = endOfDay\n                     }\n                 }\n+            }),\n+            // Date keywords: today, yesterday, week (last 7 days), month (last 30 days)\n+            (\"date:today\", { _, f in\n+                let today = Calendar.current.startOfDay(for: Date())\n+                f.dateAfter = today\n+                if let tomorrow = Calendar.current.date(byAdding: .day, value: 1, to: today) {\n+                    f.dateBefore = tomorrow\n+                }\n+            }),\n+            (\"date:yesterday\", { _, f in\n+                let today = Calendar.current.startOfDay(for: Date())\n+                if let yesterday = Calendar.current.date(byAdding: .day, value: -1, to: today) {\n+                    f.dateAfter = yesterday\n+                    f.dateBefore = today\n+                }\n+            }),\n+            (\"date:week\", { _, f in\n+                let today = Calendar.current.startOfDay(for: Date())\n+                if let weekAgo = Calendar.current.date(byAdding: .day, value: -7, to: today),\n+                   let tomorrow = Calendar.current.date(byAdding: .day, value: 1, to: today) {\n+                    f.dateAfter = weekAgo\n+                    f.dateBefore = tomorrow\n+                }\n+            }),\n+            (\"date:month\", { _, f in\n+                let today = Calendar.current.startOfDay(for: Date())\n+                if let monthAgo = Calendar.current.date(byAdding: .day, value: -30, to: today),\n+                   let tomorrow = Calendar.current.date(byAdding: .day, value: 1, to: today) {\n+                    f.dateAfter = monthAgo\n+                    f.dateBefore = tomorrow\n+                }\n             })\n         ]\n \n@@ -769,13 +810,31 @@ public final class MailDatabase: @unchecked Sendable {\n             }\n         }\n \n-        // Clean up remaining query (free text for FTS)","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01PyoqZ4gywvwF3whYxnDXLt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Y4eS8J8abEUtfiyQSWibaK","name":"Bash","input":{"command":"cd /Users/I852000/Library/Mobile\\ Documents/com~apple~CloudDocs/swiftea && git diff Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift | tail -60","description":"Review rest of changes to MailDatabase.swift"}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1299,"cache_read_input_tokens":72663,"cache_creation":{"ephemeral_5m_input_tokens":1299,"ephemeral_1h_input_tokens":0},"output_tokens":129,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"be4a0f58-81d7-40c9-adac-d025f68ad7ff"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Y4eS8J8abEUtfiyQSWibaK","type":"tool_result","content":"+            (\"date:yesterday\", { _, f in\n+                let today = Calendar.current.startOfDay(for: Date())\n+                if let yesterday = Calendar.current.date(byAdding: .day, value: -1, to: today) {\n+                    f.dateAfter = yesterday\n+                    f.dateBefore = today\n+                }\n+            }),\n+            (\"date:week\", { _, f in\n+                let today = Calendar.current.startOfDay(for: Date())\n+                if let weekAgo = Calendar.current.date(byAdding: .day, value: -7, to: today),\n+                   let tomorrow = Calendar.current.date(byAdding: .day, value: 1, to: today) {\n+                    f.dateAfter = weekAgo\n+                    f.dateBefore = tomorrow\n+                }\n+            }),\n+            (\"date:month\", { _, f in\n+                let today = Calendar.current.startOfDay(for: Date())\n+                if let monthAgo = Calendar.current.date(byAdding: .day, value: -30, to: today),\n+                   let tomorrow = Calendar.current.date(byAdding: .day, value: 1, to: today) {\n+                    f.dateAfter = monthAgo\n+                    f.dateBefore = tomorrow\n+                }\n             })\n         ]\n \n@@ -769,13 +810,31 @@ public final class MailDatabase: @unchecked Sendable {\n             }\n         }\n \n-        // Clean up remaining query (free text for FTS)\n-        let cleanedFreeText = remainingQuery\n+        // Clean up remaining query and detect unknown filters\n+        let tokens = remainingQuery\n             .trimmingCharacters(in: .whitespaces)\n             .components(separatedBy: .whitespaces)\n             .filter { !$0.isEmpty }\n-            .joined(separator: \" \")\n \n+        // Check for unknown filter patterns (word:value format)\n+        // Valid filter prefixes: from, to, subject, mailbox, is, has, after, before, date\n+        let unknownFilterRegex = try? NSRegularExpression(pattern: \"^([a-zA-Z]+):\", options: [])\n+        var freeTextTokens: [String] = []\n+\n+        for token in tokens {\n+            let range = NSRange(token.startIndex..., in: token)\n+            if let match = unknownFilterRegex?.firstMatch(in: token, options: [], range: range),\n+               let filterNameRange = Range(match.range(at: 1), in: token) {\n+                let filterName = String(token[filterNameRange]).lowercased()\n+                // Check if this is an unknown filter name\n+                if !SearchFilter.validFilterNames.contains(filterName) {\n+                    filter.unknownFilters.append(filterName)\n+                }\n+            }\n+            freeTextTokens.append(token)\n+        }\n+\n+        let cleanedFreeText = freeTextTokens.joined(separator: \" \")\n         if !cleanedFreeText.isEmpty {\n             filter.freeText = cleanedFreeText\n         }","is_error":false}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"9afbdeeb-38ab-4b5f-bdcb-ea5297fb15fc","tool_use_result":{"stdout":"+            (\"date:yesterday\", { _, f in\n+                let today = Calendar.current.startOfDay(for: Date())\n+                if let yesterday = Calendar.current.date(byAdding: .day, value: -1, to: today) {\n+                    f.dateAfter = yesterday\n+                    f.dateBefore = today\n+                }\n+            }),\n+            (\"date:week\", { _, f in\n+                let today = Calendar.current.startOfDay(for: Date())\n+                if let weekAgo = Calendar.current.date(byAdding: .day, value: -7, to: today),\n+                   let tomorrow = Calendar.current.date(byAdding: .day, value: 1, to: today) {\n+                    f.dateAfter = weekAgo\n+                    f.dateBefore = tomorrow\n+                }\n+            }),\n+            (\"date:month\", { _, f in\n+                let today = Calendar.current.startOfDay(for: Date())\n+                if let monthAgo = Calendar.current.date(byAdding: .day, value: -30, to: today),\n+                   let tomorrow = Calendar.current.date(byAdding: .day, value: 1, to: today) {\n+                    f.dateAfter = monthAgo\n+                    f.dateBefore = tomorrow\n+                }\n             })\n         ]\n \n@@ -769,13 +810,31 @@ public final class MailDatabase: @unchecked Sendable {\n             }\n         }\n \n-        // Clean up remaining query (free text for FTS)\n-        let cleanedFreeText = remainingQuery\n+        // Clean up remaining query and detect unknown filters\n+        let tokens = remainingQuery\n             .trimmingCharacters(in: .whitespaces)\n             .components(separatedBy: .whitespaces)\n             .filter { !$0.isEmpty }\n-            .joined(separator: \" \")\n \n+        // Check for unknown filter patterns (word:value format)\n+        // Valid filter prefixes: from, to, subject, mailbox, is, has, after, before, date\n+        let unknownFilterRegex = try? NSRegularExpression(pattern: \"^([a-zA-Z]+):\", options: [])\n+        var freeTextTokens: [String] = []\n+\n+        for token in tokens {\n+            let range = NSRange(token.startIndex..., in: token)\n+            if let match = unknownFilterRegex?.firstMatch(in: token, options: [], range: range),\n+               let filterNameRange = Range(match.range(at: 1), in: token) {\n+                let filterName = String(token[filterNameRange]).lowercased()\n+                // Check if this is an unknown filter name\n+                if !SearchFilter.validFilterNames.contains(filterName) {\n+                    filter.unknownFilters.append(filterName)\n+                }\n+            }\n+            freeTextTokens.append(token)\n+        }\n+\n+        let cleanedFreeText = freeTextTokens.joined(separator: \" \")\n         if !cleanedFreeText.isEmpty {\n             filter.freeText = cleanedFreeText\n         }","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_016VUqEGzMU9mBPaPvntFTuZ","type":"message","role":"assistant","content":[{"type":"text","text":"I see there are additional date keyword changes in the diff that were already on the branch from a previous session. Those are fine. Let me look at the MailCommand changes:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":934,"cache_read_input_tokens":73962,"cache_creation":{"ephemeral_5m_input_tokens":934,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"e60e00eb-4911-44f5-883d-da2b8846f4f5"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_016VUqEGzMU9mBPaPvntFTuZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01M2C74qxa2Ek1aQgkrTe8bV","name":"Bash","input":{"command":"cd /Users/I852000/Library/Mobile\\ Documents/com~apple~CloudDocs/swiftea && git diff Sources/SwiftEACLI/Commands/MailCommand.swift | head -80","description":"Review changes to MailCommand.swift"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":934,"cache_read_input_tokens":73962,"cache_creation":{"ephemeral_5m_input_tokens":934,"ephemeral_1h_input_tokens":0},"output_tokens":160,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"edb16d20-141e-4be6-ba1c-c606dc62ed3c"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01M2C74qxa2Ek1aQgkrTe8bV","type":"tool_result","content":"diff --git a/Sources/SwiftEACLI/Commands/MailCommand.swift b/Sources/SwiftEACLI/Commands/MailCommand.swift\nindex 5b719da..82e98e9 100644\n--- a/Sources/SwiftEACLI/Commands/MailCommand.swift\n+++ b/Sources/SwiftEACLI/Commands/MailCommand.swift\n@@ -1220,6 +1220,10 @@ struct MailSearchCommand: ParsableCommand {\n               after:YYYY-MM-DD - Messages received after date\n               before:YYYY-MM-DD - Messages received before date\n               date:YYYY-MM-DD  - Messages received on specific date\n+              date:today       - Messages received today\n+              date:yesterday   - Messages received yesterday\n+              date:week        - Messages from the last 7 days\n+              date:month       - Messages from the last 30 days\n \n             STATUS FILTER (--status):\n               inbox    - Messages in your inbox\n@@ -1277,6 +1281,14 @@ struct MailSearchCommand: ParsableCommand {\n         // Parse the query for structured filters\n         var filter = mailDatabase.parseQuery(query)\n \n+        // Check for unknown filter names and fail with helpful error\n+        if filter.hasUnknownFilters {\n+            throw MailValidationError.unknownFilter(\n+                names: filter.unknownFilters,\n+                validFilters: MailDatabase.SearchFilter.validFilterNames\n+            )\n+        }\n+\n         // Apply --status option if provided\n         if let statusValue = status {\n             filter.mailboxStatus = MailboxStatus(rawValue: statusValue.lowercased())\n@@ -2800,6 +2812,7 @@ public enum MailValidationError: Error, LocalizedError, Equatable {\n     case watchAndStopMutuallyExclusive\n     case invalidInterval(minimum: Int)\n     case invalidStatus(value: String)\n+    case unknownFilter(names: [String], validFilters: [String])\n \n     public var errorDescription: String? {\n         switch self {\n@@ -2813,6 +2826,14 @@ public enum MailValidationError: Error, LocalizedError, Equatable {\n             return \"--interval must be at least \\(minimum) seconds\"\n         case .invalidStatus(let value):\n             return \"Invalid status '\\(value)'. Valid options: inbox, archived, deleted\"\n+        case .unknownFilter(let names, let validFilters):\n+            let unknownList = names.map { \"'\\($0)'\" }.joined(separator: \", \")\n+            let validList = validFilters.joined(separator: \", \")\n+            if names.count == 1 {\n+                return \"Unknown filter \\(unknownList). Valid filters: \\(validList)\"\n+            } else {\n+                return \"Unknown filters \\(unknownList). Valid filters: \\(validList)\"\n+            }\n         }\n     }\n }","is_error":false}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"a5ee8905-fd97-4c78-9da0-f75c9b2fdc0a","tool_use_result":{"stdout":"diff --git a/Sources/SwiftEACLI/Commands/MailCommand.swift b/Sources/SwiftEACLI/Commands/MailCommand.swift\nindex 5b719da..82e98e9 100644\n--- a/Sources/SwiftEACLI/Commands/MailCommand.swift\n+++ b/Sources/SwiftEACLI/Commands/MailCommand.swift\n@@ -1220,6 +1220,10 @@ struct MailSearchCommand: ParsableCommand {\n               after:YYYY-MM-DD - Messages received after date\n               before:YYYY-MM-DD - Messages received before date\n               date:YYYY-MM-DD  - Messages received on specific date\n+              date:today       - Messages received today\n+              date:yesterday   - Messages received yesterday\n+              date:week        - Messages from the last 7 days\n+              date:month       - Messages from the last 30 days\n \n             STATUS FILTER (--status):\n               inbox    - Messages in your inbox\n@@ -1277,6 +1281,14 @@ struct MailSearchCommand: ParsableCommand {\n         // Parse the query for structured filters\n         var filter = mailDatabase.parseQuery(query)\n \n+        // Check for unknown filter names and fail with helpful error\n+        if filter.hasUnknownFilters {\n+            throw MailValidationError.unknownFilter(\n+                names: filter.unknownFilters,\n+                validFilters: MailDatabase.SearchFilter.validFilterNames\n+            )\n+        }\n+\n         // Apply --status option if provided\n         if let statusValue = status {\n             filter.mailboxStatus = MailboxStatus(rawValue: statusValue.lowercased())\n@@ -2800,6 +2812,7 @@ public enum MailValidationError: Error, LocalizedError, Equatable {\n     case watchAndStopMutuallyExclusive\n     case invalidInterval(minimum: Int)\n     case invalidStatus(value: String)\n+    case unknownFilter(names: [String], validFilters: [String])\n \n     public var errorDescription: String? {\n         switch self {\n@@ -2813,6 +2826,14 @@ public enum MailValidationError: Error, LocalizedError, Equatable {\n             return \"--interval must be at least \\(minimum) seconds\"\n         case .invalidStatus(let value):\n             return \"Invalid status '\\(value)'. Valid options: inbox, archived, deleted\"\n+        case .unknownFilter(let names, let validFilters):\n+            let unknownList = names.map { \"'\\($0)'\" }.joined(separator: \", \")\n+            let validList = validFilters.joined(separator: \", \")\n+            if names.count == 1 {\n+                return \"Unknown filter \\(unknownList). Valid filters: \\(validList)\"\n+            } else {\n+                return \"Unknown filters \\(unknownList). Valid filters: \\(validList)\"\n+            }\n         }\n     }\n }","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_016Zb6Xhpr7eNSUBwrM3Uq5U","type":"message","role":"assistant","content":[{"type":"text","text":"The changes look good. Now let me stage only the files I changed for this fix:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":908,"cache_read_input_tokens":74896,"cache_creation":{"ephemeral_5m_input_tokens":908,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"d5926be8-b6ad-435c-91e7-735478bb45e9"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_016Zb6Xhpr7eNSUBwrM3Uq5U","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Xf8UoCGTeED38ZRtNret2B","name":"Bash","input":{"command":"cd /Users/I852000/Library/Mobile\\ Documents/com~apple~CloudDocs/swiftea && git add Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift Sources/SwiftEACLI/Commands/MailCommand.swift Tests/SwiftEAKitTests/MailDatabaseTests.swift","description":"Stage the changed files"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":908,"cache_read_input_tokens":74896,"cache_creation":{"ephemeral_5m_input_tokens":908,"ephemeral_1h_input_tokens":0},"output_tokens":171,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"88bb85fd-e020-4c58-81e5-5871ad240f4e"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Xf8UoCGTeED38ZRtNret2B","type":"tool_result","content":"","is_error":false}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"cb950d1f-6415-4d15-9eb1-7bf22b691c47","tool_use_result":{"stdout":"","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01HHTtbz7wbzjb8oJe8nGCwh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01ChV7mPKn4XCocrYsNZnodh","name":"Bash","input":{"command":"cd /Users/I852000/Library/Mobile\\ Documents/com~apple~CloudDocs/swiftea && git diff --cached --stat","description":"Check staged changes"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":197,"cache_read_input_tokens":75804,"cache_creation":{"ephemeral_5m_input_tokens":197,"ephemeral_1h_input_tokens":0},"output_tokens":102,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"99ae9b6e-df15-467f-9c20-9d3374114935"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01ChV7mPKn4XCocrYsNZnodh","type":"tool_result","content":" Sources/SwiftEACLI/Commands/MailCommand.swift      | 21 +++++++\n .../Modules/MailModule/MailDatabase.swift          | 67 ++++++++++++++++++++--\n Tests/SwiftEAKitTests/MailDatabaseTests.swift      | 59 +++++++++++++++++++\n 3 files changed, 143 insertions(+), 4 deletions(-)","is_error":false}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"cfca323a-e8c7-442e-b520-c136cca80e40","tool_use_result":{"stdout":" Sources/SwiftEACLI/Commands/MailCommand.swift      | 21 +++++++\n .../Modules/MailModule/MailDatabase.swift          | 67 ++++++++++++++++++++--\n Tests/SwiftEAKitTests/MailDatabaseTests.swift      | 59 +++++++++++++++++++\n 3 files changed, 143 insertions(+), 4 deletions(-)","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01LCvw5TGgmc88jigftCFXck","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Y14WbUDnEdRXjEPaKMdX6b","name":"Bash","input":{"command":"cd /Users/I852000/Library/Mobile\\ Documents/com~apple~CloudDocs/swiftea && git commit -m \"$(cat <<'EOF'\nfeat: swiftea-2hz.2 - US-002: Fix crash on unknown search filter\n\nAdd validation for unknown filter names in mail search queries to provide\nuser-friendly error messages instead of cryptic SQLite errors:\n\n- Add unknownFilters array to SearchFilter to track unrecognized filters\n- Detect filter patterns (word:value) that don't match known filters\n- Show helpful error message listing valid filters when unknown filter used\n- Example: `swea mail search \"badfilter:test\"` now shows:\n  \"Unknown filter 'badfilter'. Valid filters: from, to, subject, mailbox,\n   is, has, after, before, date\"\n\nAlso adds date keyword shortcuts: date:today, date:yesterday, date:week,\ndate:month for convenience.\n\nCo-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\nEOF\n)\"","description":"Commit the changes"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":219,"cache_read_input_tokens":76001,"cache_creation":{"ephemeral_5m_input_tokens":219,"ephemeral_1h_input_tokens":0},"output_tokens":317,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"d21bdbd1-fff4-4c80-8422-35a682c8f560"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Y14WbUDnEdRXjEPaKMdX6b","type":"tool_result","content":"[ralph/bidirectional-inbox-mail-sync 95bd2d5] feat: swiftea-2hz.2 - US-002: Fix crash on unknown search filter\n 3 files changed, 143 insertions(+), 4 deletions(-)","is_error":false}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"3efd8b84-5c94-413d-ae18-8b8169415256","tool_use_result":{"stdout":"[ralph/bidirectional-inbox-mail-sync 95bd2d5] feat: swiftea-2hz.2 - US-002: Fix crash on unknown search filter\n 3 files changed, 143 insertions(+), 4 deletions(-)","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TAYy9koHG1DyxkNbffPEiz","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me close the bead:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":390,"cache_read_input_tokens":76220,"cache_creation":{"ephemeral_5m_input_tokens":390,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"fe61fdd9-15e8-4f12-945c-071a0af6c638"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TAYy9koHG1DyxkNbffPEiz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Vve5HVAQxp2W1gdrgy4LCy","name":"Bash","input":{"command":"cd /Users/I852000/Library/Mobile\\ Documents/com~apple~CloudDocs/swiftea && bd close swiftea-2hz.2 --reason=\"Implemented unknown filter validation with user-friendly error messages. Added tests verifying parseQuery detects unknown filters and returns them in unknownFilters array.\"","description":"Close the bead"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":390,"cache_read_input_tokens":76220,"cache_creation":{"ephemeral_5m_input_tokens":390,"ephemeral_1h_input_tokens":0},"output_tokens":152,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"9ec678ab-8449-4cc9-9eb1-df1acf50b28f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Vve5HVAQxp2W1gdrgy4LCy","type":"tool_result","content":"âœ“ Closed swiftea-2hz.2: Implemented unknown filter validation with user-friendly error messages. Added tests verifying parseQuery detects unknown filters and returns them in unknownFilters array.","is_error":false}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"71ceb2c8-fa9a-4c37-9561-7f505dbcc7e2","tool_use_result":{"stdout":"âœ“ Closed swiftea-2hz.2: Implemented unknown filter validation with user-friendly error messages. Added tests verifying parseQuery detects unknown filters and returns them in unknownFilters array.","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BYCnrMUVgdZLkvdKZ7m5PR","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Mxc259YY4HfXRJPVTggmTY","name":"TodoWrite","input":{"todos":[{"content":"Find and analyze the mail search code","status":"completed","activeForm":"Finding and analyzing the mail search code"},{"content":"Add test for unknown filter names to verify current behavior","status":"completed","activeForm":"Adding test for unknown filter names"},{"content":"Implement validation of filter names in parseQuery","status":"completed","activeForm":"Implementing validation of filter names in parseQuery"},{"content":"Add user-friendly error message with valid filter list","status":"completed","activeForm":"Adding user-friendly error message with valid filter list"},{"content":"Run swift build and swift test","status":"completed","activeForm":"Running swift build and swift test"},{"content":"Commit and close the bead","status":"completed","activeForm":"Committing and closing the bead"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":413,"cache_read_input_tokens":76610,"cache_creation":{"ephemeral_5m_input_tokens":413,"ephemeral_1h_input_tokens":0},"output_tokens":255,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"1a05b16b-f3e0-40ee-8009-13a014932866"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Mxc259YY4HfXRJPVTggmTY","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"dcc444a7-c457-4d63-a221-e3fa15e8cbd7","tool_use_result":{"oldTodos":[{"content":"Find and analyze the mail search code","status":"completed","activeForm":"Finding and analyzing the mail search code"},{"content":"Add test for unknown filter names to verify current behavior","status":"completed","activeForm":"Adding test for unknown filter names"},{"content":"Implement validation of filter names in parseQuery","status":"completed","activeForm":"Implementing validation of filter names in parseQuery"},{"content":"Add user-friendly error message with valid filter list","status":"completed","activeForm":"Adding user-friendly error message with valid filter list"},{"content":"Run swift build and swift test","status":"completed","activeForm":"Running swift build and swift test"},{"content":"Commit and close the bead","status":"in_progress","activeForm":"Committing and closing the bead"}],"newTodos":[{"content":"Find and analyze the mail search code","status":"completed","activeForm":"Finding and analyzing the mail search code"},{"content":"Add test for unknown filter names to verify current behavior","status":"completed","activeForm":"Adding test for unknown filter names"},{"content":"Implement validation of filter names in parseQuery","status":"completed","activeForm":"Implementing validation of filter names in parseQuery"},{"content":"Add user-friendly error message with valid filter list","status":"completed","activeForm":"Adding user-friendly error message with valid filter list"},{"content":"Run swift build and swift test","status":"completed","activeForm":"Running swift build and swift test"},{"content":"Commit and close the bead","status":"completed","activeForm":"Committing and closing the bead"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01NEPqR2jEkN1uY8KCCU7irx","type":"message","role":"assistant","content":[{"type":"text","text":"<promise>COMPLETE</promise>\n\n## Summary\n\nI successfully completed **swiftea-2hz.2 - US-002: Fix crash on unknown search filter**.\n\n### Changes Made:\n\n1. **MailDatabase.swift** (`Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift:668-704`):\n   - Added `unknownFilters: [String]` property to `SearchFilter` struct\n   - Added `hasUnknownFilters` computed property\n   - Added `validFilterNames` static constant listing valid filters\n   - Modified `parseQuery()` to detect unknown filter patterns (word:value format) and store them in `unknownFilters`\n\n2. **MailCommand.swift** (`Sources/SwiftEACLI/Commands/MailCommand.swift:1280-1286, 2803, 2817-2824`):\n   - Added check for unknown filters in `MailSearchCommand.run()` that throws with helpful error\n   - Added `unknownFilter(names:validFilters:)` case to `MailValidationError` enum\n   - Error message format: \"Unknown filter 'badfilter'. Valid filters: from, to, subject, mailbox, is, has, after, before, date\"\n\n3. **MailDatabaseTests.swift** (`Tests/SwiftEAKitTests/MailDatabaseTests.swift:298-342`):\n   - Added `testParseQueryDetectsUnknownFilters()` with comprehensive test cases\n   - Added `testValidFilterNamesConstant()` to verify the list of valid filters\n\n### Acceptance Criteria:\n- [x] Unknown filter names produce user-friendly error message\n- [x] Error message lists valid filter names (from, to, subject, mailbox, is, has, after, before, date)\n- [x] Application exits with code 1 (not crash/abort) - throws `MailValidationError` which ArgumentParser handles\n- [x] `swea mail search \"badfilter:test\"` shows: \"Unknown filter 'badfilter'. Valid filters: from, to, subject, mailbox, is, has, after, before, date\"\n- [x] `swift build` passes\n- [x] `swift test` passes (731 tests, 3 pre-existing unrelated failures in EnvelopeIndexDiscoveryTests and VaultContextTests)"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":297,"cache_read_input_tokens":77023,"cache_creation":{"ephemeral_5m_input_tokens":297,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","uuid":"e751bcbf-97d9-4fc5-bede-e96efb04a879"}
{"type":"result","subtype":"success","is_error":false,"duration_ms":922341,"duration_api_ms":377282,"num_turns":67,"result":"<promise>COMPLETE</promise>\n\n## Summary\n\nI successfully completed **swiftea-2hz.2 - US-002: Fix crash on unknown search filter**.\n\n### Changes Made:\n\n1. **MailDatabase.swift** (`Sources/SwiftEAKit/Modules/MailModule/MailDatabase.swift:668-704`):\n   - Added `unknownFilters: [String]` property to `SearchFilter` struct\n   - Added `hasUnknownFilters` computed property\n   - Added `validFilterNames` static constant listing valid filters\n   - Modified `parseQuery()` to detect unknown filter patterns (word:value format) and store them in `unknownFilters`\n\n2. **MailCommand.swift** (`Sources/SwiftEACLI/Commands/MailCommand.swift:1280-1286, 2803, 2817-2824`):\n   - Added check for unknown filters in `MailSearchCommand.run()` that throws with helpful error\n   - Added `unknownFilter(names:validFilters:)` case to `MailValidationError` enum\n   - Error message format: \"Unknown filter 'badfilter'. Valid filters: from, to, subject, mailbox, is, has, after, before, date\"\n\n3. **MailDatabaseTests.swift** (`Tests/SwiftEAKitTests/MailDatabaseTests.swift:298-342`):\n   - Added `testParseQueryDetectsUnknownFilters()` with comprehensive test cases\n   - Added `testValidFilterNamesConstant()` to verify the list of valid filters\n\n### Acceptance Criteria:\n- [x] Unknown filter names produce user-friendly error message\n- [x] Error message lists valid filter names (from, to, subject, mailbox, is, has, after, before, date)\n- [x] Application exits with code 1 (not crash/abort) - throws `MailValidationError` which ArgumentParser handles\n- [x] `swea mail search \"badfilter:test\"` shows: \"Unknown filter 'badfilter'. Valid filters: from, to, subject, mailbox, is, has, after, before, date\"\n- [x] `swift build` passes\n- [x] `swift test` passes (731 tests, 3 pre-existing unrelated failures in EnvelopeIndexDiscoveryTests and VaultContextTests)","session_id":"5a947bfe-0fe0-45e8-8f0b-a1aaf572731b","total_cost_usd":2.5368579999999996,"usage":{"input_tokens":68,"cache_creation_input_tokens":60432,"cache_read_input_tokens":3305118,"output_tokens":17570,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":60432}},"modelUsage":{"claude-opus-4-5-20251101":{"inputTokens":68,"outputTokens":17570,"cacheReadInputTokens":3305118,"cacheCreationInputTokens":60432,"webSearchRequests":0,"costUSD":2.469848999999999,"contextWindow":200000,"maxOutputTokens":64000},"claude-haiku-4-5-20251001":{"inputTokens":61384,"outputTokens":1125,"cacheReadInputTokens":0,"cacheCreationInputTokens":0,"webSearchRequests":0,"costUSD":0.06700899999999999,"contextWindow":200000,"maxOutputTokens":64000}},"permission_denials":[],"uuid":"7aa26442-a4f7-49a9-a5cd-74e5c4165883"}
